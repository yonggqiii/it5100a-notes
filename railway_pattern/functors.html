<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functors - Typed Functional Programming</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../about.html">About IT5100A</a></li><li class="chapter-item expanded affix "><li class="part-title">Typed Functional Programming</li><li class="chapter-item expanded "><a href="../course_introduction/index.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../course_introduction/sections/course_admin.html"><strong aria-hidden="true">1.1.</strong> Course Administration</a></li><li class="chapter-item expanded "><a href="../course_introduction/sections/functional_programming.html"><strong aria-hidden="true">1.2.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../course_introduction/sections/haskell.html"><strong aria-hidden="true">1.3.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../course_introduction/sections/exercises.html"><strong aria-hidden="true">1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../types/index.html"><strong aria-hidden="true">2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../types/sections/type_systems.html"><strong aria-hidden="true">2.1.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../types/sections/polymorphism.html"><strong aria-hidden="true">2.2.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../types/sections/algebraic_data_types.html"><strong aria-hidden="true">2.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="../types/sections/pattern_matching.html"><strong aria-hidden="true">2.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="../types/sections/exercises.html"><strong aria-hidden="true">2.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../typeclasses/index.html"><strong aria-hidden="true">3.</strong> Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../typeclasses/sections/ad-hoc-polymorphism.html"><strong aria-hidden="true">3.1.</strong> Ad-Hoc Polymorphism</a></li><li class="chapter-item expanded "><a href="../typeclasses/sections/typeclasses.html"><strong aria-hidden="true">3.2.</strong> Typeclasses</a></li><li class="chapter-item expanded "><a href="../typeclasses/sections/commonly-used-typeclasses.html"><strong aria-hidden="true">3.3.</strong> Commonly Used Typeclasses</a></li><li class="chapter-item expanded "><a href="../typeclasses/sections/functional-dependencies.html"><strong aria-hidden="true">3.4.</strong> Functional Dependencies</a></li><li class="chapter-item expanded "><a href="../typeclasses/sections/existential.html"><strong aria-hidden="true">3.5.</strong> Existential Typeclass Antipattern</a></li><li class="chapter-item expanded "><a href="../typeclasses/sections/exercises.html"><strong aria-hidden="true">3.6.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../railway_pattern/index.html"><strong aria-hidden="true">4.</strong> Railway Pattern</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../railway_pattern/context.html"><strong aria-hidden="true">4.1.</strong> Context/Notions of Computation</a></li><li class="chapter-item expanded "><a href="../railway_pattern/functors.html" class="active"><strong aria-hidden="true">4.2.</strong> Functors</a></li><li class="chapter-item expanded "><a href="../railway_pattern/applicative.html"><strong aria-hidden="true">4.3.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="../railway_pattern/validation.html"><strong aria-hidden="true">4.4.</strong> Validation</a></li><li class="chapter-item expanded "><a href="../railway_pattern/monad.html"><strong aria-hidden="true">4.5.</strong> Monads</a></li><li class="chapter-item expanded "><a href="../railway_pattern/railway_python.html"><strong aria-hidden="true">4.6.</strong> Railway Pattern in Python</a></li><li class="chapter-item expanded "><a href="../railway_pattern/exercises.html"><strong aria-hidden="true">4.7.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../monads/index.html"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../monads/more_monads.html"><strong aria-hidden="true">5.1.</strong> More on Monads</a></li><li class="chapter-item expanded "><a href="../monads/common_monads.html"><strong aria-hidden="true">5.2.</strong> Commonly Used Monads</a></li><li class="chapter-item expanded "><a href="../monads/monadtrans.html"><strong aria-hidden="true">5.3.</strong> Monad Transformers</a></li><li class="chapter-item expanded "><a href="../monads/monads_wild.html"><strong aria-hidden="true">5.4.</strong> Monads in the Wild</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Exercises</div></li></ol></li><li class="chapter-item expanded "><a href="../concurrent/index.html"><strong aria-hidden="true">6.</strong> Concurrent and Parallel Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../concurrent/concurrency.html"><strong aria-hidden="true">6.1.</strong> Concurrent Programming</a></li><li class="chapter-item expanded "><a href="../concurrent/parallel.html"><strong aria-hidden="true">6.2.</strong> Parallel Programming</a></li><li class="chapter-item expanded "><a href="../concurrent/stm.html"><strong aria-hidden="true">6.3.</strong> Software Transactional Memory</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../solutions/index.html"><strong aria-hidden="true">7.</strong> Solutions to Exercises</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../solutions/course_introduction.html"><strong aria-hidden="true">7.1.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="../solutions/types.html"><strong aria-hidden="true">7.2.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="../solutions/typeclasses.html"><strong aria-hidden="true">7.3.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="../solutions/railway.html"><strong aria-hidden="true">7.4.</strong> Chapter 4</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Chapter 5</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Chapter 6</div></li></ol></li><li class="chapter-item expanded "><a href="../recap/index.html"><strong aria-hidden="true">8.</strong> Recap of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../recap/sections/recursion.html"><strong aria-hidden="true">8.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../recap/sections/first-class-functions.html"><strong aria-hidden="true">8.2.</strong> First-Class Functions</a></li><li class="chapter-item expanded "><a href="../recap/sections/lambda.html"><strong aria-hidden="true">8.3.</strong> Lambda Calculus</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typed Functional Programming</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="category-theory"><a class="header" href="#category-theory">Category Theory</a></h1>
<p>We can borrow some ideas from a branch of mathematics, known as <em>Category Theory</em>, to improve the ergonomics of these structures. Part of the reason why we are able to do so is that all the types that we have described have kind <code>* -&gt; *</code>, i.e. they "wrap" around another type. As such, they should be able to behave as <em>functors</em>, which we will formalize shortly.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>However, before we even talk about what a functor is and how the data structures we have described are functors, we first need to describe what category theory is. Intuitively, most theories (especially the algebraic ones) study mathematical structures that abstract over things; <em>groups</em> are abstractions of <em>symmetries</em>, and <em>geometric spaces</em> are abstractions of <em>space</em>. Category theory takes things one step further and studies <em>abstraction itself</em>.</p>
<p>Effectively the goal of category theory is to observe similar underlying structures between collections of mathematical structures. What is nice about this is that a result from category theory generalizes to all other theories that fit the structure of a category. As such it should be no surprise that computation can be, and is, studied through the lens of category theory too!</p>
<p>On the other hand, the generality of category theory also makes it incredibly abstract and difficult to understand—this is indeed the case in our very first definition. As such, I will, as much as possible, show you "concrete" examples of each definition and reason about them if I can. With this in mind, let us start with the definition of a category, as seen in many sources.</p>
<blockquote>
<p><strong>Definition (Category)</strong>. A category \(\mathcal{C}\) consists of</p>
<ul>
<li>a collection of <em>objects</em> \(X\), \(Y\), \(Z\), ... denoted \(\text{ob}(\mathcal{C})\)</li>
<li>a collection of <em>morphisms</em>, \(f, g, h, \dots\), denoted \(\text{mor}(\mathcal{C})\)</li>
</ul>
<p>so that:</p>
<ul>
<li>Each morphism has specified <em>domain</em> and <em>codomain</em> objects; when we write \(f: X \to Y\), we mean that the morphism \(f\) has domain \(X\) and codomain \(Y\).</li>
<li>Each object has an <em>identity morphism</em> \(1_X:X\rightarrow X\).</li>
<li>For any pair of morphisms \(f\), \(g\) with the codomain of \(f\) equal to the domain of \(g\) (i.e. \(f\) and \(g\) are composable), there exists a <em>composite morphism</em> \(g \circ f\) whose domain is equal to the domain of \(f\) and whose codomain is equal to the codomain of \(g\), i.e.
\[f: X\rightarrow Y, ~~~g: Y \rightarrow Z ~~~~~ \rightsquigarrow ~~~~~ g\circ f:X\rightarrow Z\]</li>
</ul>
<p>Composition of morphisms is subject to the two following axioms:</p>
<ul>
<li><em>Unity</em>. For any \(f: X \rightarrow Y\), \(f\circ1_X = 1_Y \circ f = f\).</li>
<li><em>Associativity</em>. For any composable \(f\), \(g\) and \(h\), \((h\circ g)\circ f = h \circ (g \circ f)\).</li>
</ul>
</blockquote>
<p>This, of course, is incredibly abstract and quite hard to take in. Instead, let us use a simpler definition to get some "ideas" across:</p>
<blockquote>
<p>A category \(\mathcal{C}\) consists of</p>
<ul>
<li>Dots \(X\), \(Y\), \(Z\)</li>
<li>Arrows between dots \(f, g, h, \dots\)</li>
</ul>
<p>such that:</p>
<ul>
<li>Joining two arrows together gives another arrow</li>
<li>There is a unique way to join three arrows together</li>
<li>Every dot has an arrow pointing to itself, such that joining it with any other arrow \(f\) just gives \(f\)</li>
</ul>
</blockquote>
<p>Here is an example category:</p>
<pre><code>    f
A ----&gt; B
 \      |
  \     | g
 h \    |
    \   v 
     -&gt; C
</code></pre>
<p>Here we have three objects <code>A</code> <code>B</code> and <code>C</code>, and the morphisms <code>f: A -&gt; B</code>, <code>g: B -&gt; C</code> and <code>h: A -&gt; C</code>. The identity morphisms for the objects are omitted for simplicity. Note that the composition of <code>f</code> and <code>g</code> exists in the category (assume in the example <code>g . f == h</code>).</p>
<p>Why do we care? Well, it turns out that types and functions in Haskell assemble into a category \(\mathcal{H}\)!<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<ul>
<li>Objects in \(\mathcal{H}\) are types like <code>Int</code>, <code>String</code> etc.</li>
<li>Morphisms in \(\mathcal{H}\) are functions like <code>(+1)</code> and <code>head</code></li>
</ul>
<p>Furthermore,</p>
<ul>
<li>The composition of two functions with <code>(.)</code> is also a function</li>
<li>Every type has the identity function <code>id x = x</code>, where for all functions <code>f</code>, <code>id . f</code> = <code>f . id</code> = <code>f</code></li>
</ul>
<pre><code>    show
Int ---&gt; String
   \      |
    \     | head
     \    |
      \   v 
       -&gt; Char
</code></pre>
<p>The above is a fragment of \(\mathcal{H}\). We can see that <code>show</code> is a function from <code>Int</code> to <code>String</code>, and <code>head</code> is a function from <code>String</code> to <code>Char</code>. In addition, the function <code>head . show</code> is a function from <code>Int</code> to <code>Char</code>! Furthermore, all of these types have the identity function <code>id</code> which we omit in the diagram.</p>
<p><mark>Still, who cares?</mark></p>
<p>Because the types in Haskell assemble into categories, let's see if there is anything that category theory has to tell us.</p>
<h1 id="functors"><a class="header" href="#functors">Functors</a></h1>
<p>In mathematics, the relationships between objects are frequently far more interesting
than the objects themselves. Of course, we do not just focus on <em>any</em> relationship
between objects, but of keen interest, the <em>structure preserving</em> relationships between
them, such as group homomorphisms that preserve group structures, or monotonic functions
between preordered sets that preserve ordering. In category theory, <em>functors</em> are
maps between categories that preserve the structure of the domain category,
especially the compositions and identities.</p>
<blockquote>
<p>Let \(\mathcal{C}\) and \(\mathcal{D}\) be categories. A (<em>covariant</em>)
<em>functor</em> \(F: \mathcal{C} \rightarrow \mathcal{D}\) consists of:</p>
<ul>
<li>An object \(F(C) \in \text{ob}(\mathcal{D})\) for each object \(C \in \text{ob}(\mathcal{C})\)<sup class="footnote-reference"><a href="#3">3</a></sup>.</li>
<li>A morphism \(F(f): F(C) \rightarrow F(D) \in \text{mor}(\mathcal{D})\) for each morphism \(f: C\rightarrow D \in \text{mor}(\mathcal{C})\).</li>
</ul>
<p>subject to the two <em>functoriality axioms</em>:</p>
<ul>
<li>For any composable pair of morphisms \(f, g\in\text{mor}(\mathcal{C})\), \(F(g)\circ F(f) = F(g\circ f)\).</li>
<li>For each \(C \in \text{ob}(\mathcal{C})\), \(F(1_C)=1_{F(C)}\).</li>
</ul>
<p>in other words, functors map dots and arrows between two categories, preserving composition and identities.</p>
</blockquote>
<pre><code>    f                          F(f)
A ----&gt; B                F(A) ----&gt; F(B)
 \      |        F            \      |
  \     | g   ======&gt;          \     | F(g)
 h \    |                  F(h) \    |
    \   v                        \   v
     -&gt; C                         &gt; F(C)
</code></pre>
<p>What's so special about categories and functors, especially since categories are so abstract and have so little requirements for being one? This is precisely the beauty of category theory—it is abstract and simple enough for many things to assemble into one, yet the requirement of associativity and unity of the composition of morphisms and identities make things that assemble into categories behave in the <em>most obvious way</em>!</p>
<h2 id="types-as-functors"><a class="header" href="#types-as-functors">Types as Functors</a></h2>
<p>There are two parts two a functor in \(\mathcal{H}\):</p>
<ul>
<li>Maps types to types</li>
<li>Maps functions to functions</li>
</ul>
<p>We already know that the <code>[]</code> type constructor maps <code>a</code> to <code>[a]</code> for all <code>a</code> in \(\mathcal{H}\).
How do we map functions <code>f :: a -&gt; b</code> to <code>F(f) :: [a] -&gt; [b]</code> in the <em>most obvious way</em>, i.e. in a way that preserves function composition and identities?</p>
<p>It is simple! Recall the <code>map</code> function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(x: int) -&gt; str:
...     return str(x + 2)
&gt;&gt;&gt; f(3)
'5'
&gt;&gt;&gt; list(map(f, [3]))
['5']
</code></pre>
<pre><code class="language-haskell">ghci&gt; :{
ghci| f :: Int -&gt; String
ghci| f x = show (x + 2)
ghci| :}
ghci&gt; f 3
"5"
ghci&gt; :t map f
map f :: [Int] -&gt; [String]
ghci&gt; map f [3]
["5"]
</code></pre>
<p><code>map</code> preserves composition:</p>
<pre><code class="language-haskell">ghci&gt; (map (*2) . map (+3)) [1, 2, 3]
[8, 10, 12]
ghci&gt; map ((*2) . (+3)) [1, 2, 3]
[8, 10, 12]
</code></pre>
<p><code>map</code> also preserves identities:</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications
ghci&gt; map (id @Int) [1, 2, 3]
[1, 2, 3]
ghci&gt; id @[Int] [1, 2, 3]
[1, 2, 3]
</code></pre>
<p>That is great! <code>[]</code> and <code>map</code> form a functor over \(\mathcal{H}\), which means that we no longer have to worry if someone wants to work in the <code>[]</code> context. This is because if we have functions from <code>a</code> to <code>b</code>, we can <em>lift</em> it into a function from <code>[a]</code> to <code>[b]</code> using <code>map</code> and it will behave in the most obvious way!</p>
<p>Can we say the same about <code>Maybe</code> and the other type constructors we saw earlier? Fret not! Let's see how we can define a function for <code>Maybe</code> so that it can behave as a functor as well! Let's look at <code>maybeMap</code>:</p>
<pre><code class="language-haskell">maybeMap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
maybeMap _ Nothing = Nothing
maybeMap f (Just x) = Just $ f x
</code></pre>
<p><code>maybeMap</code> also preserves composition and identities!</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications
ghci&gt; (maybeMap (*2) . maybeMap (+3)) (Just 1)
Just 8
ghci&gt; maybeMap ((*2) . (+3)) (Just 1)
Just 8
ghci&gt; maybeMap (id @Int) (Just 1)
Just 1
ghci&gt; id @(Maybe Int) (Just 1)
Just 1
</code></pre>
<p>Like we have seen before, all of these types have some <code>map</code>-like method that allows us to lift functions into its context; however, they all have their type-specific implementations. This is the reason why Haskell has a <code>Functor</code> typeclass!</p>
<pre><code class="language-haskell">class Functor (f :: * -&gt; *) where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b

instance Functor [] where
    fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]
    fmap _ [] = []
    fmap f (x : xs) = f x : fmap f xs

instance Functor Maybe where
    fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just $ f x

instance Functor (Either a) where -- `a`, a.k.a. sad path is fixed!
    fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c
    fmap _ (Left x) = Left x
    fmap f (Right x) = Right $ f x
</code></pre>
<p>The key point of <code>[]</code>, <code>Maybe</code>, <code>Either</code> etc being functors is as such:</p>
<blockquote>
<p>Given any functor <code>F</code> and a function <code>f</code> from <code>A</code> to <code>B</code>, <code>fmap f</code> is a function from <code>F A</code> to <code>F B</code> and <strong>behaves as we should expect</strong>.</p>
</blockquote>
<pre><code>       f
  A ------&gt; B
       |
       |
       v
F A ------&gt; F B
    fmap f
</code></pre>
<p>Whenever we are presented with a situation that requires us to map a function <code>f :: A -&gt; B</code> over a functor <code>fa :: F A</code>, just use <code>fmap f fa</code> to give us some <code>fb :: F B</code>. There is no need to unwrap the <code>A</code> from the <code>F A</code> (which may not be possible), apply <code>f</code> then wrap it back in the <code>F</code>; just use <code>fmap</code>!</p>
<p>A simple example is as follows. Suppose we have our <code>head'</code> function that returns a <code>Maybe a</code>, as we have defined earlier. A possible program that we could write that operates on the result of <code>head'</code> is the following:</p>
<pre><code class="language-haskell">ls = [1, 2, 3]
x = head' ls
y = case x of 
    Just z -&gt; Just $ z + 1
    Nothing -&gt; Nothing
</code></pre>
<p>This <code>case</code> expression is actually just boilerplate and is not idiomatic! The <code>Maybe</code>-specific definition of <code>fmap</code> already handles this, therefore, we can re-write this program much more simply as such:</p>
<pre><code class="language-haskell">ls = [1, 2, 3]
x = head' ls
y = fmap (+1) x
</code></pre>
<h2 id="category-theory-and-functional-programming"><a class="header" href="#category-theory-and-functional-programming">Category Theory and Functional Programming</a></h2>
<p>Although we introduced some formalisms of category theory, rest assured that category theory is <strong>not the main point</strong> of this chapter. Instead, category theory <em>inspires</em> tools that support <em>commonly-used programming patterns</em> backed by <em>well-defined theoretical notions</em>. Therefore, when we say that a type is a functor, not only do we mean that it has an <code>fmap</code> definition, we also mean that this definition of <code>fmap</code> obeys well-understood laws (in the case of functors, <code>fmap</code> preserves compositions and identities) and you can use it assuredly.</p>
<p>That being said, we now have a very powerful tool, <code>fmap</code>, that allows us to perform computations in context. What other operations might we need to make the railway pattern more ergonomic?</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>We do not cover category theory in too much detail since it is not <em>required</em> for functional programming, although an appreciation of it can help with understanding. For a more detailed walkthrough of the connections between functional programming and category theory, see my <a href="https://yongqi.foo/blog/posts/monads/">article on category theory</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Not really... due to the laziness of Haskell and functions like <code>seq</code>, the types and functions in Haskell do not actually assemble in to a category. However, just to put some ideas across, we shall assume that they do.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>We abuse the notation of set membership here. It is not necessary for the collections of objects and morphisms of a category to be sets, as is the case for the category of sets.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../railway_pattern/context.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../railway_pattern/applicative.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../railway_pattern/context.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../railway_pattern/applicative.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
