<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Typed Functional Programming</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About IT5100A</a></li><li class="chapter-item expanded affix "><li class="part-title">Typed Functional Programming</li><li class="chapter-item expanded "><a href="course_introduction/index.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course_introduction/sections/course_admin.html"><strong aria-hidden="true">1.1.</strong> Course Administration</a></li><li class="chapter-item expanded "><a href="course_introduction/sections/functional_programming.html"><strong aria-hidden="true">1.2.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="course_introduction/sections/haskell.html"><strong aria-hidden="true">1.3.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="course_introduction/sections/exercises.html"><strong aria-hidden="true">1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/sections/type_systems.html"><strong aria-hidden="true">2.1.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="types/sections/polymorphism.html"><strong aria-hidden="true">2.2.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="types/sections/algebraic_data_types.html"><strong aria-hidden="true">2.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="types/sections/pattern_matching.html"><strong aria-hidden="true">2.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="types/sections/exercises.html"><strong aria-hidden="true">2.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="typeclasses/index.html"><strong aria-hidden="true">3.</strong> Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="typeclasses/sections/ad-hoc-polymorphism.html"><strong aria-hidden="true">3.1.</strong> Ad-Hoc Polymorphism</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/typeclasses.html"><strong aria-hidden="true">3.2.</strong> Typeclasses</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/commonly-used-typeclasses.html"><strong aria-hidden="true">3.3.</strong> Commonly Used Typeclasses</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/functional-dependencies.html"><strong aria-hidden="true">3.4.</strong> Functional Dependencies</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/existential.html"><strong aria-hidden="true">3.5.</strong> Existential Typeclass Antipattern</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/exercises.html"><strong aria-hidden="true">3.6.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="railway_pattern/index.html"><strong aria-hidden="true">4.</strong> Railway Pattern</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="railway_pattern/context.html"><strong aria-hidden="true">4.1.</strong> Context/Notions of Computation</a></li><li class="chapter-item expanded "><a href="railway_pattern/functors.html"><strong aria-hidden="true">4.2.</strong> Functors</a></li><li class="chapter-item expanded "><a href="railway_pattern/applicative.html"><strong aria-hidden="true">4.3.</strong> Applicative Functors</a></li><li class="chapter-item expanded "><a href="railway_pattern/validation.html"><strong aria-hidden="true">4.4.</strong> Validation</a></li><li class="chapter-item expanded "><a href="railway_pattern/monad.html"><strong aria-hidden="true">4.5.</strong> Monads</a></li><li class="chapter-item expanded "><a href="railway_pattern/railway_python.html"><strong aria-hidden="true">4.6.</strong> Railway Pattern in Python</a></li><li class="chapter-item expanded "><a href="railway_pattern/exercises.html"><strong aria-hidden="true">4.7.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="monads/index.html"><strong aria-hidden="true">5.</strong> Monads</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="monads/more_monads.html"><strong aria-hidden="true">5.1.</strong> More on Monads</a></li><li class="chapter-item expanded "><a href="monads/common_monads.html"><strong aria-hidden="true">5.2.</strong> Commonly Used Monads</a></li><li class="chapter-item expanded "><a href="monads/monadtrans.html"><strong aria-hidden="true">5.3.</strong> Monad Transformers</a></li><li class="chapter-item expanded "><a href="monads/monads_wild.html"><strong aria-hidden="true">5.4.</strong> Monads in the Wild</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Exercises</div></li></ol></li><li class="chapter-item expanded "><a href="concurrent/index.html"><strong aria-hidden="true">6.</strong> Concurrent and Parallel Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concurrent/concurrency.html"><strong aria-hidden="true">6.1.</strong> Concurrent Programming</a></li><li class="chapter-item expanded "><a href="concurrent/parallel.html"><strong aria-hidden="true">6.2.</strong> Parallel Programming</a></li><li class="chapter-item expanded "><a href="concurrent/stm.html"><strong aria-hidden="true">6.3.</strong> Software Transactional Memory</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="solutions/index.html"><strong aria-hidden="true">7.</strong> Solutions to Exercises</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="solutions/course_introduction.html"><strong aria-hidden="true">7.1.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="solutions/types.html"><strong aria-hidden="true">7.2.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="solutions/typeclasses.html"><strong aria-hidden="true">7.3.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="solutions/railway.html"><strong aria-hidden="true">7.4.</strong> Chapter 4</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Chapter 5</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Chapter 6</div></li></ol></li><li class="chapter-item expanded "><a href="recap/index.html"><strong aria-hidden="true">8.</strong> Recap of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recap/sections/recursion.html"><strong aria-hidden="true">8.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="recap/sections/first-class-functions.html"><strong aria-hidden="true">8.2.</strong> First-Class Functions</a></li><li class="chapter-item expanded "><a href="recap/sections/lambda.html"><strong aria-hidden="true">8.3.</strong> Lambda Calculus</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typed Functional Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><a href="https://github.com/yonggqiii/it5100a-notes/graphs/contributors"><img src="https://img.shields.io/github/contributors/yonggqiii/it5100a-notes.svg?style=for-the-badge" alt="Contributors" /></a>
<img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" />
<a href="https://github.com/yonggqiii/it5100a-notes/stargazers"><img src="https://img.shields.io/github/stars/yonggqiii/it5100a-notes.svg?style=for-the-badge" alt="Stargazers" /></a>
<a href="https://github.com/yonggqiii/it5100a-notes/issues"><img src="https://img.shields.io/github/issues/yonggqiii/it5100a-notes.svg?style=for-the-badge" alt="Issues" /></a>
<img src="https://img.shields.io/badge/LICENSE-NONE-ff5040?style=for-the-badge" alt="License" />
<a href="https://linkedin.com/in/fooyongqi"><img src="https://img.shields.io/badge/-LinkedIn-black.svg?style=for-the-badge&amp;logo=linkedin&amp;colorB=555" alt="LinkedIn" /></a></p>
<!-- PROJECT LOGO -->
<br />
<div align="center">
<h1 style="margin-top:0px;margin-bottom: 0px" align="center">IT5100A</h1>
<h3 style="margin-top:0px">Industry Readiness: Typed Functional Programming</h3>
  <p align="center">
    <em>by <strong>Foo</strong> Yong Qi</em>
    <br />
    <br />
    <a href="https://github.com/yonggqiii/it5100a-notes">GitHub</a>
    ·
    <a href="https://github.com/yonggqiii/it5100a-notes/issues/new?labels=bug&template=bug-report---.md">Report Bug</a>
    ·
    <a href="https://github.com/yonggqiii/it5100a-notes/issues/new?labels=enhancement&template=feature-request---.md">Request Feature</a>
  </p>
</div>
<p>This is a set of lecture notes for students enrolled in IT5100A—Industry Readiness: Typed Functional Programming in NUS SoC.</p>
<h2 id="about-it5100a"><a class="header" href="#about-it5100a">About IT5100A</a></h2>
<p>Typed functional programming are becoming more widely adopted in industry, as can be seen in the success of a number of advanced programming languages, such as OCaml, Haskell and Scala 3. These advanced languages offer a range of expressive features to allow robust, reusable and high-performing software codes to be safely and rapidly developed. This course will cover key programming techniques of typed functional programming that are becoming widely adopted, such as strong typing, code composition and abstraction, effect handlers, and safe techniques for asynchronous and concurrent programming.</p>
<h2 id="about-these-notes"><a class="header" href="#about-these-notes">About These Notes</a></h2>
<p>I hope that these notes can be used as good supplementary material for those looking to learn the concepts of Typed Functional Programming in more detail. Each of these chapters comes with exercises in Python and Haskell so that you're able to replicate some of the ideas from purely-functional languages in general-purpose multi-paradigm languages.</p>
<p>Therefore, to avoid confusion, code blocks are annotated with the logo of the target programming language on the left. Examples below. (Readers on mobile might have to rotate their phones to landscape to view the logos.)</p>
<h4 id="python"><a class="header" href="#python">Python</a></h4>
<pre><code class="language-python">this = 'is some Python code'
</code></pre>
<h4 id="haskell"><a class="header" href="#haskell">Haskell</a></h4>
<pre><code class="language-haskell">this :: String
this = "is some Haskell code"
</code></pre>
<h4 id="java"><a class="header" href="#java">Java</a></h4>
<pre><code class="language-java">class This {
    public static void main(String[] args) {
        System.out.println("is some Java code");
    }
}
</code></pre>
<h4 id="lean-4"><a class="header" href="#lean-4">Lean 4</a></h4>
<pre><code class="language-lean">def this: String := "is some Lean 4 code"
</code></pre>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>This work is incomplete, and therefore will be regularly updated. As such, please run a hard refresh (<code>Ctrl</code> + <code>F5</code>) every time you visit the page.</p>
<p>A badge is shown at the beginning of every page describing when it was last updated. The badge looks like this:</p>
<p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>Ensure that the badge displays the expected date of the last update.</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>This project is a single-author text, and is incomplete. Thus, this project is not open to pull requests without prior agreement. However, please feel free to improve the quality of this content by submitting bug reports and feature requests. All your contributions other than by the author will be considered a donation of your work to this project, and you are not considered an author or owner of the content once they have been incorporated.</p>
<p>Please submit all requests for content and bugs either as a GitHub issue or contact the author directly.</p>
<h2 id="contributors"><a class="header" href="#contributors">Contributors</a></h2>
<a href="https://github.com/yonggqiii/it5100a-notes/graphs/contributors">
  <img src="https://contrib.rocks/image?repo=yonggqiii/it5100a-notes" alt="contrib.rocks image" />
</a>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>All rights to this project are reserved by the author. Unauthorized reproduction, distribution, or modification of this project, in whole or in part, is strictly prohibited without prior written permission. The author reserves the right to modify or change the licensing terms at any time and without prior notice. For inquiries regarding licensing or usage, please contact the author.</p>
<p>Logos and other external assets used in this project do not belong to the author.</p>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p>Author: Foo Yong Qi - yongqi@nus.edu.sg</p>
<p>© 2024 Foo Yong Qi. All Rights Reserved.</p>
<hr />
<h2 id="release-history"><a class="header" href="#release-history">Release History</a></h2>
<h3 id="2024"><a class="header" href="#2024">2024</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Date</th><th>Description</th></tr></thead><tbody>
<tr><td>26 Oct</td><td>Writeup on Concurrent and Parallel Programming, excluding exercises</td></tr>
<tr><td>13 Oct</td><td>Writeup on Monads, excluding exercises</td></tr>
<tr><td>10 Oct</td><td>Writeup on the existential typeclass pattern</td></tr>
<tr><td>28 Sep</td><td><ul><li>Additional writeups and bug fixes in the existing chapters</li><li>Bug fixes in operator highlighting in code blocks in light modes.</li><li>Recap on first-class functions and lambda calculus.</li><li>Solutions to exercises for the first four chapters.</li></ul></td></tr>
<tr><td>26 Sep</td><td>The first draft of these notes have been released with the first four chapters completed.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>In this chapter, we go through some of the usual administrivia of this course, and proceed to discuss some core ideas of Functional Programming (FP) in different settings, some which should be unfamiliar to you.</p>
<p>Readers who find some of the concepts in <a href="course_introduction/sections/functional_programming.html">Chapter 1.2 (Functional Programming)</a> challenging or unfamiliar can revisit these ideas in <a href="course_introduction/../recap/README.html">Chapter 8 (Recap of Concepts)</a> before proceeding.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="course-administration"><a class="header" href="#course-administration">Course Administration</a></h1>
<h2 id="course-coordinator"><a class="header" href="#course-coordinator">Course Coordinator</a></h2>
<p>Foo Yong Qi</p>
<p>Instructor &amp; Ph.D. Student</p>
<p>Email: yongqi@nus.edu.sg</p>
<h2 id="course-outline"><a class="header" href="#course-outline">Course Outline</a></h2>
<ul>
<li>Course Introduction
<ul>
<li>Course Administration</li>
<li>Functional Programming</li>
<li>Introduction to Haskell</li>
</ul>
</li>
<li>Types
<ul>
<li>Types and Type Systems</li>
<li>Polymorphism</li>
<li>Algebraic Data Types</li>
<li>Pattern Matching</li>
</ul>
</li>
<li>Typeclasses
<ul>
<li>What Are Typeclasses?</li>
<li>Important Typeclasses</li>
<li>Typeclasses and Typeclass Instances</li>
</ul>
</li>
<li>Railway Pattern
<ul>
<li>Functors</li>
<li>Applicative Functors</li>
<li>Validation</li>
<li>Monads</li>
</ul>
</li>
<li>Monads
<ul>
<li>Commonly-Used Monads</li>
<li>Monad Transformers</li>
</ul>
</li>
<li>Concurrent Programming
<ul>
<li>Concurrent Programming with Threads</li>
<li>Parallel Programming</li>
<li>Software Transactional Memory</li>
</ul>
</li>
<li>Course Conclusion</li>
</ul>
<h2 id="graded-items"><a class="header" href="#graded-items">Graded Items</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Item</th><th>Weightage</th></tr></thead><tbody>
<tr><td>Assignment 1</td><td>20%</td></tr>
<tr><td>Assignment 2</td><td>20%</td></tr>
<tr><td>Assignment 3</td><td>20%</td></tr>
<tr><td>Practical Exam</td><td>40%</td></tr>
</tbody></table>
</div>
<p>The Practical Exam is planned to be during the last lecture.</p>
<h2 id="plagiarism-notice"><a class="header" href="#plagiarism-notice">Plagiarism Notice</a></h2>
<p>Assignments are on programming... standard plagiarism rules apply.</p>
<p><mark>No code sharing!</mark></p>
<ul>
<li>ChatGPT (and similar tools) is allowed for <strong>learning only</strong></li>
<li>Using LLMs to generate code is <strong>not allowed</strong></li>
<li>NUS takes a strict view of plagiarism and cheating</li>
<li>Disciplinary action will be taken against students who violate NUS Student Code of Conduct</li>
<li>No part of your assignment can come from any other source</li>
<li>No discussion and sharing of solutions during exams</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h1>
<p><em>Functional Programming</em> (FP) is a <em>declarative</em> <em>programming paradigm</em> where <em>functions</em> take centre stage. As a recap from IT5001, you might have learnt that programming paradigms are schools of thought for writing programs. IT5001 has very likely exposed you to <em>imperative</em> paradigms like <em>procedural</em> and <em>Object-Oriented Programming</em>. The following table shows other popular programming paradigms:</p>
<div class="table-wrapper"><table><thead><tr><th>Imperative</th><th>Declarative</th></tr></thead><tbody>
<tr><td>Procedural</td><td>Logic</td></tr>
<tr><td>Object-Oriented</td><td>Functional</td></tr>
</tbody></table>
</div>
<p>Object-Oriented Programming (OOP) has four principles as you might recall: <em>Abstraction</em>, <em>Inheritance</em>, <em>Encapsulation</em> and
<em>Polymorphism</em>.<sup class="footnote-reference"><a href="#1">1</a></sup> Functional Programming, on the other hand, is centered around the following principles, which really are just principles of mathematical functions and the \(\lambda\) <em>calculus</em>:<sup class="footnote-reference"><a href="#4">2</a></sup></p>
<ul>
<li>Immutability</li>
<li>Pure Functions</li>
<li>Recursion</li>
<li>Types</li>
<li>First-Class Functions</li>
</ul>
<p>Let's briefly describe what these principles entail.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>The idea of <em>immutability</em> is simple—only use <strong>immutable</strong> data. For example, the following program fragment does not perform any mutation, not even on the variables:</p>
<pre><code class="language-python">def add_one(fraction):
    """fraction is a tuple of (numerator, denominator)"""
    old_num, den = fraction
    num = old_num + den
    return (num, den)
 
my_fraction = (3, 2)
new_fraction = add_one(my_fraction)
 
print(new_fraction) # (5, 2)
print(my_fraction) # (3, 2)
</code></pre>
<p>The fact that the program does not perform any mutation makes this very
similar to mathematical functions where mathematical objects are seen as
values instead of references to cells that can be changed. This makes
reasoning about any of the variables, objects and functions incredibly
simple.</p>
<p>Overall, immutability forces us to be disciplined with <strong>state</strong>.
Contrast this with using <strong>mutable</strong> data structures and variables, such as in the following program fragment:</p>
<pre><code class="language-python">def f(ls):
  ls[0] = 4
  return ls
 
my_ls = [1, 2, 3]
print(f(my_ls)) # [4, 2, 3]
print(my_ls) # [4, 2, 3]
</code></pre>
<p>This is one of the classic examples of the problems with mutability—it is
not at all clear whether passing a list into a function will preserve
the state of the list. Because lists are mutable, we have no guarantee
that functions or any operation will not cause the <em>side-effect</em> of
mutation (accidental or intentional).</p>
<h2 id="pure-functions"><a class="header" href="#pure-functions">Pure Functions</a></h2>
<p>Just like mathematical functions, functions (in programming) should be
<em>pure</em>. Pure functions really look like mathematical functions, for
example, \(f\) below:</p>
<p>\[f: \mathbb{N} \to \mathbb{N}\]
\[f(x) = x^2 + 2x + 3\]</p>
<p>An equivalent implementation in Python would
look like:</p>
<pre><code class="language-python">def f(x):
  return x ** 2 + 2 * x + 3
</code></pre>
<p>Pure functions <strong>only receive input and return
output</strong>. They do not produce side effects, and do not depend
on external state. An example of this is as follows:</p>
<pre><code class="language-python"># Python
def double(ls):
  return [i * 2 for i in ls]
 
x = [1, 2, 3]
 
print(double(x)) # [2, 4, 6]
print(double(x)) # [2, 4, 6]
print(double(x)) # ...
# ...
</code></pre>
<p>Notice that the <code>double</code> function is pure! In this example,
<code>double(x)</code> evaluates to <code>[2, 4, 6]</code>; thus,
<code>double(x)</code> and <code>[2, 4, 6]</code> are the <strong>same</strong>! This
property of pure functions is known as <em>referential transparency</em>, and
makes reasoning about and optimizing programs much more straightforward.</p>
<p>Contrast the behaviour of pure functions with that of impure functions:</p>
<pre><code class="language-python">def f():
  global ls
  x = ls # use of global variable
  addend = x[-1] + 1
  x.append(addend) # is there a side-effect?
  ls = x + [addend + 1] # mutate global variable
  return ls
 
ls = [1, 2, 3]
x = ls
 
print(f()) # [1, 2, 3, 4, 5]
print(ls) # [1, 2, 3, 4, 5]
print(x) # [1, 2, 3, 4]
</code></pre>
<p>So many side effects have been caused! Functions like these make
reasoning about program behaviour incredibly difficult. Converting this
function into a pure one (removing all side-effects) makes its behaviour
clearer and more transparent.</p>
<pre><code class="language-python">def f(ls):
  x = ls
  addend = x[-1] + 1
  x = x + [addend]
  ls = x + [addend + 1]
  return ls
 
ls = [1, 2, 3]
x = ls
 
print(f(ls)) # [1, 2, 3, 4, 5]
print(ls) # [1, 2, 3]
print(x) # [1, 2, 3]
</code></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>You have seen this before—use <em>recursive</em> functions to simulate loops.<sup class="footnote-reference"><a href="#2">3</a></sup> Let's look at an example of a perfectly reasonable way to sum
the numbers of a 2-dimensional list, using the <code>sum2D</code> function:</p>
<pre><code class="language-python">def sum2D(ls):
  total = 0
  for row in ls:
    for num in row:
      total += num
  return total
</code></pre>
<p>Loops are typically useful for its side-effects, primarily mutation.
Looking at the (nested) loop above, a bunch of mutation occurs: the
reassignments to <code>row</code> and <code>num</code> (the loop variables),
and the mutation of the <code>total</code> variable in the loop body. In
an environment where mutation is impossible, can we write the same
program? Yes! Like we have said, rely on <strong>recursion</strong>! An example
recursive formulation of the <code>sum2D</code> function from above would
be like so:</p>
<pre><code class="language-python">def row_sum(row):
    return 0 if not row else \
           row[0] + row_sum(row[1:])
 
def sum2D(ls):
    return 0 if not ls else \
           row_sum(ls[0]) + sum2D(ls[1:])
</code></pre>
<p>Again, the behaviour of the program has not changed: the
<code>sum2D</code> function still produces the correct output given any
2-dimensional list of integers. However, our function is still pure and
does not mutate <strong>any</strong> data structure or variable.</p>
<p>Recursive solutions can also be more elegant,
especially when the problem or data structures used are (inherently)
recursive. Take the example of obtaining the preorder of a binary tree.
Binary trees are recursive data structures, if formulated the following
way:</p>
<blockquote>
<p>A (nonempty) binary tree is either:</p>
<ul>
<li>A node with a value, a left tree and a right tree; OR</li>
<li>A leaf with just a value</li>
</ul>
</blockquote>
<p>As you can see, the definition of a node contains (sub)trees, making the binary tree
a recursive data structure<sup class="footnote-reference"><a href="#3">4</a></sup>. Therefore, operations on trees can often be
expressed elegantly using recursion. For example, the specification of
obtaining the <em>preorder</em> of a tree can be like so:</p>
<ol>
<li>
<p>The preorder of a leaf is a list containing the leaf's value</p>
</li>
<li>
<p>The preorder of a node is the node's value, together with the
preorder of the left (sub)tree, then the preorder of the right
(sub)tree.</p>
</li>
</ol>
<p>This specification written in code is concise and elegant:</p>
<pre><code class="language-python">from dataclasses import dataclass
 
@dataclass
class Tree: pass
 
@dataclass
class Node(Tree):
    val: object
    left: Tree
    right: Tree
 
@dataclass
class Leaf(Tree):
    val: object
 
def preorder(tree):
    match tree:
        case Node(val=v, left=l, right=r):
            return [v] + preorder(l) + preorder(r)
        case Leaf(val=v):
            return [v]
</code></pre>
<p>Recursive functions are also amenable to <strong>formal</strong> reasoning. Some
languages (usually <em>Interactive Theorem Provers</em>) support proofs and can
even automatically synthesize proofs of correctness for you. In the
following example written in Lean 4, the following program defines a
binary tree and a program for obtaining the preorder of the tree just as
before; the key difference being, that Lean automatically helps us prove
that the function <strong>terminates</strong>. In such an environment, we rarely have
to worry whether our program gets stuck or crashes.</p>
<pre><code class="language-lean">inductive Tree (α : Type) : Type where
  | node : α -&gt; Tree α -&gt; Tree α -&gt; Tree α
  | leaf : α -&gt; Tree α 
 
-- compiler automatically synthesizes proof of termination
def Tree.preorder { β : Type } : Tree β -&gt; List β
  | .node v l r =&gt; v :: (preorder l) ++ (preorder r)
  | .leaf v =&gt; [v]
 
def myTree : Tree Nat := .node 1 (.leaf 2) (.leaf 3)
#eval myTree.preorder -- [1, 2, 3]
</code></pre>
<p>The primary reason for this is that recursive functions can often be
reasoned about via <em>induction</em>:</p>
<p>\[\frac{P(0)~~~~~~~~\forall k \in \mathbb{N}. P(k)\to P(k + 1)}{\forall n \in \mathbb{N}. P(n)} \text{Induction}\]</p>
<p>We have seen that factorial can be written recursively, and in fact we
can prove its correctness (in a quite straightforward manner) via
induction. This makes the following factorial function implementation
obviously correct.</p>
<pre><code class="language-lean">-- Lean 4
def fac : Nat -&gt; Nat 
  | 0     =&gt; 1
  | n + 1 =&gt; (n + 1) * fac n
</code></pre>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Adhering strictly to type information <strong>eliminates type-related bugs</strong>
and makes functions <strong>transparent</strong>. Perhaps most importantly, adherence
to type information can be verified by a program.</p>
<p>Observe the following program fragment.</p>
<pre><code class="language-python">x: int = 123
# ...
print(x + 5)
</code></pre>
<p>If we fix the type of <code>x</code> to <code>int</code> and strictly adhere
to it, then the last line containing <code>x + 5</code> will definitely
not cause a <code>TypeError</code>, because we know that adding any number
to an integer will always work.</p>
<p>Contrast the above with the following example.</p>
<pre><code class="language-python"># Python
def safe_div(num: int, den: int) -&gt; int:
    return None if den == 0 else \
           num // den
 
x = int(input())
y = int(input())
z = safe_div(x, y) + 1 # hmmm...
print(z)
</code></pre>
<p>If we do not adhere to typing information strictly, no one knows that
the <code>safe_div</code> function could return <code>None</code>! In such a
scenario, if the user enters <code>0</code> for <code>y</code>, the
expression <code>safe_div(x, y) + 1</code> would give a
<code>TypeError</code>!</p>
<p>Function purity and adhering to types forces functions to be
<strong>transparent in effects</strong>. That is because if we want our pure function
to perform some effectful computation (such as potentially returning
<code>None</code>), we must return an object that encapsulates this
behaviour; coupled with adhering to types, we must assign the correct
type for the output of the function—the type of the object which
encapsulates this behaviour—making the function's effects obvious.</p>
<p>To improve the program written earlier, let us try to create a data structure
<code>Maybe</code> that is one of two things: <code>Just</code> a value, or
<code>Nothing</code>. We can express this as dataclasses in Python (you
may ignore the stuff involving <code>typing</code> and all the square brackets
for now, they will make sense later).</p>
<pre><code class="language-python">from typing import Any
from dataclasses import dataclass

@dataclass(frozen=True)
class Maybe[T]:
    """Represents computation that may result in nothing"""
    pass
 
@dataclass(frozen=True)
class Just[T](Maybe[T]):
    j: T
 
@dataclass(frozen=True)
class Nothing(Maybe[Any]):
    pass
</code></pre>
<p>Now we can amend our <code>safe_div</code> function appropriately to
return a <code>Maybe</code> value:</p>
<pre><code class="language-python">def safe_div(num: int, den: int) -&gt; Maybe[int]:
    return Nothing() if den == 0 else \
           Just(num // den)
</code></pre>
<p>Notice two things: 1) the function is pure, and does nothing other than
receive inputs and returns output 2) the function's type signature makes
it incredibly obvious that the function will <em>maybe</em> produce an
<code>int</code>. Therefore, users of this function are <em>forced</em> to handle
the case where the function produces <code>Nothing</code>.</p>
<p>From this, we may proceed to use the <code>safe_div</code> function as
before, except that instead of directly assigning
<code>z = safe_div(x, y) + 1</code>, we must first call
<code>safe_div</code> and handle the two cases: one where some integer was
returned, the other where nothing was.</p>
<pre><code class="language-python">x: int = int(input())
y: int = int(input())
z: Maybe[int]
match safe_div(x, y):
    case Just(j):
        z = Just(j + 1)
    case Nothing():
        z = Nothing()
</code></pre>
<p>Types and type systems are highly useful, not just for verification of
type safety, but also more generally, program verification and theorem
proving etc. Types are backed by a rich theory (type theory) and is
widely studied. As an example, interactive theorem provers may rely
on systems with advanced type systems (such as the calculus of constructions, which has
<em>dependent types</em>) to form the computational basis for proof assistance
and proof checking. When these systems are baked into the language, we
can write proof-carrying code and theorems (mathematical theorems or
theorems about properties of code itself). An example is as follows,
where theorems about the additive identity and the commutativity of
addition of numbers can be used to show that concatenating a vector
(like an immutable list) of length \(n\) to one of length \(k\) gives a
vector of length \(n + k\).</p>
<pre><code class="language-lean">-- Lean 4
theorem izero : ∀ (k : Nat) , k = 0 + k
  | 0 =&gt; by rfl
  | n + 1 =&gt; congrArg (. + 1) (izero n)
 
theorem isucc (n k : Nat) : n + k + 1 = n + 1 + k :=
  match k with 
  | 0 =&gt; by rfl
  | x + 1 =&gt; congrArg (. + 1) (isucc n x)
 
def Vect.concat {α : Type} {n k : Nat} : Vect α n -&gt; Vect α k -&gt; Vect α (n + k)
  | .nil, ys =&gt; izero k ▸ ys
  | .cons x xs, ys =&gt; isucc _ _ ▸ .cons x (xs.concat ys)
</code></pre>
<h3 id="first-class-functions"><a class="header" href="#first-class-functions">First-Class Functions</a></h3>
<p>You might have seen in IT5001 that in some languages, functions are
<em>first-class</em> objects.<sup class="footnote-reference"><a href="#7">5</a></sup> This gives rise to higher-order functions which
support <strong>code re-use</strong>. <em>Higher-order functions</em> can receive functions
as arguments and/or return functions as output.</p>
<p>In the following program fragment, the <code>map</code> method of
<code>Tree</code>s receive a function and returns a new tree with the
function applied to all of its values. We then also <em>curry</em> the
<code>add</code> function so that it receives the first addend, then
returns a function that receives the second addend and returns the sum.
This way, adding 2 to the values of a tree is as simple as several
function calls:</p>
<pre><code class="language-python">@dataclass(frozen=True)
class Tree:
    def map(self, f):
        match self:
            case Leaf(v):
                return Leaf(f(v))
            case Node(v, l, r):
                newval = f(v)
                newl = l.map(f)
                newr = r.map(f)
                return Node(newval, newl, newr)
 
@dataclass(frozen=True)
class Node(Tree):
    val: object
    left: Tree
    right: Tree
 
@dataclass(frozen=True)
class Leaf(Tree):
    val: object
 
def add(x):
    return lambda y: x + y
 
x = Node(1, Leaf(2), Leaf(3))
print(x.map(add(2))) # Node(3, Leaf(4), Leaf(5))
</code></pre>
<p>Functional programming languages emphasize this fact and make it easy
and ergonomic to define higher-order functions. For example, in Haskell,
functions are automatically curried, and has higher-order functions like
<code>map</code> built into the standard library. This makes, for
example, adding two to elements of a list, straightforward:</p>
<pre><code class="language-haskell">main :: IO ()
main = do
  let x = [1, 2, 3]
  print (map (+2) x) -- [3, 4, 5]
</code></pre>
<h3 id="so-what"><a class="header" href="#so-what">So what?</a></h3>
<p>Ideas from functional programming languages are increasingly being
adopted in commonly-used imperative programming languages:</p>
<ul>
<li>
<p>Closures in C++/Rust/Java 8</p>
</li>
<li>
<p>Structural pattern matching in Python 3.11/Java 21</p>
</li>
<li>
<p>Algebraic Data Types in Rust</p>
</li>
<li>
<p>Records in Java 14 etc.</p>
</li>
</ul>
<p>Learning functional programming has a direct impact on your future work as a developer; functional programming is more than just a collection of language features and principles—it fundamentally encourages a new way of solving problem. As we’ve discussed, some of these principles impose meaningful constraints on programmers, which can make problem-solving more challenging and require innovative strategies. Nevertheless, mastering functional programming is invaluable, as it offers a fresh perspective on problem-solving. The skills you acquire will not only enhance your discipline as a developer but also empower you to explore diverse approaches to the challenges you encounter in your daily work.</p>
<p>Our goal for this course is to therefore first learn how to write
programs in a purely functional programming language (thus forcing you
to write programs fully with FP), and then transfer concepts into
commonly used programming languages. For this, we will be writing code
in two languages: <em>Haskell</em> (a purely functional programming language)
and Python (which you should all be relatively familiar with).</p>
<h3 id="things-you-need"><a class="header" href="#things-you-need">Things You Need</a></h3>
<p>For this course, you will need the following software:</p>
<ul>
<li>
<p>The Glasgow Haskell Compiler (GHC) (recommended: GHC 9.4.8 or newer)</p>
</li>
<li>
<p>Python 3.12 (note the version; we shall be using new features)</p>
</li>
<li>
<p>Any text editor you like (Visual Studio Code, Neovim etc.)</p>
</li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Polymorphism in OOP refers to <em>subtype polymorphism</em>, which is
different to the polymorphism in FP known as <em>parametric
polymorphism</em>.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">2</sup>
<p>If you have not, you may want to read <a href="course_introduction/sections/../../recap/sections/lambda.html">a recap on the \(\lambda\) calculus</a> before continuing.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>If you have not, you may want to read
<a href="course_introduction/sections/../../recap/sections/recursion.html">a recap on recursion</a> before continuing.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">4</sup>
<p>(Singly-linked) lists are also recursive data structures. To see
this, look at our definition of binary trees, and remove one subtree
in the definition of a node (therefore, a node has a value and one
subtree). This is now a singly-linked list.</p>
</div>
<div class="footnote-definition" id="7"><sup class="footnote-definition-label">5</sup>
<p>If you have not, you may want to read a
<a href="course_introduction/sections/../../recap/sections/first-class-functions.html">a recap on first-class functions</a> before continuing.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="haskell-1"><a class="header" href="#haskell-1">Haskell</a></h1>
<p>Haskell is a <em>statically-typed</em>, <em>purely functional</em>
<em>nonstrict-evaluation</em> programming language. Informally, static typing
means that we can look at a program (without executing it) and tell what
the type of any term is. A purely-functional language is a
language that supports only functional programming concepts (unlike
multi-paradigm languages like Python). Nonstrict-evaluation means that
there is no strict sequence of evaluating statements or expressions, and compilers are free
to decide which expressions should be evaluated first—<em>lazy
evaluation</em> is where expressions are evaluated only when they are needed.
We will look at non-strict evaluation eventually; for now, understanding static typing and purely
functional programming is more important.</p>
<p>In a purely functional language like Haskell, you will miss the
following programming language features that are present in virtually
every general-purpose programming language:</p>
<ul>
<li>
<p>Mutation (even variables are immutable);</p>
</li>
<li>
<p>Loops;</p>
</li>
<li>
<p>Objects (classes etc.);</p>
</li>
<li>
<p>Dynamic typing (e.g. <code>x</code> can be an <code>int</code> now, and
a <code>str</code> later);</p>
</li>
</ul>
<p>You might find it difficult to adjust to such a programming environment.
However, you will find these restrictions meaningful as we have alluded
to in the previous section.</p>
<h2 id="basic-expressions"><a class="header" href="#basic-expressions">Basic Expressions</a></h2>
<p>By this point you should have already installed GHC, which comes with
two main parts: <code>ghc</code> itself (the compiler), and <code>ghci</code> the
REPL/interpreter. For now, run <code>ghci</code> in the terminal to start an interactive Haskell
shell, and enter some basic mathematical expressions!</p>
<pre><code class="language-haskell">ghci&gt; 1 + 2 - 3
0
ghci&gt; 1 * 2 / 4
0.5
ghci&gt; 5 ^ 2 `mod` 5
0
ghci&gt; 5 `div` 2
2
</code></pre>
<p>Note some differences: <code>^</code> is exponentiation (just as you would normally
type in a calculator), and there is no modulo operator. There is a
modulo function called <code>mod</code>, and you can apply any binary
function in an <em>infix</em> manner by surrounding the function in backticks. Integer
division is a function <code>div</code>. The operator precedence rules apply.</p>
<p>In a functional programming language like Haskell, it should come as no
surprise that virtually everything is a function. Mathematical operators
are actually just functions! In GHCI, we can observe the type of any
term (terms are sort of like objects in Python; functions are terms!) using <code>:t</code>, and we can show the type of
the function of the <code>+</code> operator by issuing <code>:t (+)</code> (when writing
operators as a term in the usual prefix notation, surround it in parentheses).
We can in fact re-write an infix operator function call as a normal prefix
function call. Note that in Haskell, <code>f x y z</code> is essentially
the same as <code>f(x, y, z)</code> in languages like Python.</p>
<pre><code class="language-haskell">ghci&gt; :t (+)
Num a =&gt; a -&gt; a -&gt; a
ghci&gt; 2 + 3
5
ghci&gt; (+) 2 3
5
</code></pre>
<p>As we know, currying is the act of translating an \(n\)-ary function to a
unary function that receives one parameter and returns a function that
receives the remaining parameters (in curried form). In Haskell, all
functions are curried, so even a function like <code>(+)</code> really
looks something like this in Python:</p>
<pre><code class="language-python">def add(x):
    return lambda y: x + y
</code></pre>
<p>This is automatically done in Haskell. Thus we might be able to write
our Python equivalent of <code>add(2)</code> directly in Haskell as
<code>(+2)</code>:</p>
<pre><code class="language-haskell">ghci&gt; y = (+2)              
ghci&gt; y 3
5
</code></pre>
<p>which in Python, looks like:</p>
<pre><code class="language-python">&gt;&gt;&gt; def add(x): return lambda y: x + y
&gt;&gt;&gt; y = add(2)
&gt;&gt;&gt; y(3)
5
</code></pre>
<p>Therefore, to be more specific, <code>f x y z</code> in Haskell is more
like <code>f(x)(y)(z)</code> in Python.</p>
<p>We can also load Haskell source files into GHCI. Python source files
have the <code>.py</code> extension; Haskell source files instead have the <code>.hs</code>
extension. Let us try writing a simple Haskell program. Create a new
file like <code>MyCode.hs</code> and write in the following:</p>
<pre><code class="language-haskell">-- MyCode.hs
main :: IO () -- entry point to the program
main = putStrLn "Hello World!"
</code></pre>
<p>We will look at what the first line means in the future. For now, try
compiling and running your code by issuing the following commands in
your terminal (windows users might have to run <code>./MyCode.exe</code>):</p>
<pre><code>ghc MyCode.hs
./MyCode
</code></pre>
<p>The first command invokes GHC to <em>compile</em> your source file.
<em>Compilation</em> translates your source file into an <em>executable</em> file that
your computer that understand. The compilation process will also perform
a bunch of compile-time checks, such as type-checking etc. It may also
perform some optimizations. The outcome of invoking that command is an
executable (probably called <code>MyCode</code>) along with other files (which we
shall not talk about for now). The second command then executes that
executable, and you should see <code>Hello World!</code> shown in the terminal.</p>
<pre><code class="language-output info">Hello World!
</code></pre>
<p>We shall ignore compiling source files for now and temporarily focus on
working with GHCI. In GHCI, we can load files by issuing <code>:l MyFile.hs</code>,
which loads the source into the shell. For now, write the following code
in <code>MyCode.hs</code>:</p>
<pre><code class="language-haskell">-- MyCode.hs
z = 1 -- ok
y = 2 -- ok
y = 3 -- not ok!
</code></pre>
<p>As we have described earlier, everything in Haskell is immutable.
Therefore, re-defining what <code>y</code> is should be disallowed! Let's try
loading <code>MyCode.hs</code> into GHCI:</p>
<pre><code class="language-output error">ghci&gt; :l MyCode.hs
[1 of 2] Compiling Main ( MyCode.hs, interpreted )

MyCode.hs:4:1: error:
    Multiple declarations of 'y'
    Declared at: MyCode.hs:3:1
                 MyCode.hs:4:1
  |
4 | y = 3 -- not ok!
  | ^
</code></pre>
<p>As you can see, you cannot redefine functions or variables. Everything
is immutable in Haskell! Therefore, the statement <code>x = e</code> is <strong>not</strong>
an assignment statement. Rather, it is a <em>bind</em> or a <em>definition</em>.</p>
<h2 id="control-structures"><a class="header" href="#control-structures">Control Structures</a></h2>
<p>In Haskell, you mainly write <em>expressions</em>, and not statements.
Consequently, there are only <code>if</code>-<code>else</code> expressions, and no <code>if</code>-<code>else</code>
statements. That means that you cannot omit an <code>else</code> branch of an
<code>if</code>-<code>else</code> expression, just like in Python:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 2 * -1
&gt;&gt;&gt; y = 'positive' if x == 2 else 'negative'
&gt;&gt;&gt; y
'negative'
</code></pre>
<p>In Haskell, this would be (negative numbers must be surrounded by parentheses, otherwise Haskell thinks it is a partial function application of subtraction <code>(-)</code>):</p>
<pre><code class="language-haskell">ghci&gt; x = 2 * (-1)
ghci&gt; y = if x == 2 then "positive" else "negative"
ghci&gt; y
"negative"
</code></pre>
<p>Just like in Python, <code>if</code>-<code>then</code>-<code>else</code> expressions in Haskell are <em>expressions</em> and therefore
evaluate to a term:</p>
<pre><code class="language-haskell">ghci&gt; (if 1 /= 2 then 3 else 4) + 5
8
</code></pre>
<p>Note that <em>not equals</em> looks like <code>/=</code> in Haskell but <code>!=</code> in Python.
The equivalent expression in Python might be:</p>
<pre><code class="language-python">&gt;&gt;&gt; (3 if 1 != 2 else 4) + 5
8
</code></pre>
<p>Importantly, the type of any expression is fixed, or at least, we should
be able to determine what the type of every expression is unambiguously
just by looking at it. Therefore, writing the following expression in
Haskell will throw an error:</p>
<pre><code class="language-haskell">ghci&gt; x = 2 * (-1)
ghci&gt; y = if x == 2 then 2 else "negative"
&lt;interactive&gt;:2:20: error:
  - No instance for (Num String) arising from the literal '2'
  - In the expression: 2
    In the expression: if x == 2 then 2 else "negative"
    In an equation for 'y': y = if x == 2 then 2 else "negative"
</code></pre>
<p>The reason is that we should not need to evaluate the truth of
<code>x == 2</code> to determine what the type of the entire <code>if</code>-<code>else</code>
expression is. Thus, Haskell requires that the type of the expression in
the <code>if</code> branch be the same as the type of the expression in the <code>else</code>
branch. This departs from Python which is <em>dynamically typed</em>, where
types are determined at runtime, so expressions can freely be of
different types based on the values they inherit at the time of program
execution.</p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Defining functions in Haskell looks like defining a variable. This
should be expected since Haskell is centred around functions, so it
should come as no surprise that functions do not need to be defined with
any special syntax.</p>
<pre><code class="language-haskell">ghci&gt; oddOrEven x = if even x then "even" else "odd"
ghci&gt; oddOrEven 1
"odd"
ghci&gt; oddOrEven 2
"even"

ghci&gt; quadratic c2 c1 c0 x = c2 * x ^ 2 + c1 * x + c0
ghci&gt; f = quadratic 1 2 3 -- x^2 + 2x + 3
ghci&gt; f 4
27
ghci&gt; f 5
38
</code></pre>
<p>We might then ask: how do we write a loop in Haskell? Like we said
earlier, Haskell is a purely functional programming language, so there
are no loops (we may later see loops being simulated with functions).
Thus, for now we shall use recursion as it is often the most elegant way
to solve problems.</p>
<p>Recall that the familiar <code>factorial</code> function may be written imperatively
in Python as:</p>
<pre><code class="language-python">def fac(n):
    res = 1
    for i in range(2, n + 1):
        res *= i
    return res
</code></pre>
<p>As we know, the factorial function can be defined recursively as such:
$$n! = \begin{cases}
1 &amp; \text{if }n=0\\
n \times (n - 1)!&amp; \text{otherwise}
\end{cases}$$ And in Python:</p>
<pre><code class="language-python">def fac(n):
    return 1 if n == 0 else \
           n * fac(n - 1)
</code></pre>
<p>In Haskell, we are free to do the same:</p>
<pre><code class="language-haskell">ghci&gt; fac n = if n == 0 then 1 else n * fac (n - 1)
ghci&gt; fac 4
24
</code></pre>
<p>In fact, we can also express functions like this elegantly in Haskell
with <em>guards</em>. Guards allow us to define expressions differently based
on a condition.</p>
<p>For example, we know that the Fibonacci function may be written like so:
$$\textit{fib}(n) = \begin{cases}
1 &amp; \text{if } n = 0\\
1 &amp; \text{if }n = 1\\
\textit{fib}(n - 1) + \textit{fib}(n - 2) &amp; \text{otherwise}
\end{cases}$$</p>
<p>And writing this function with regular <code>if</code>-<code>else</code>
expressions might look like: <sup class="footnote-reference"><a href="#5">1</a></sup></p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| fib n = if n == 0 || n == 1 
ghci|         then 1 
ghci|         else fib (n - 1) + fib (n - 2)
ghci| :}
</code></pre>
<p>However, it might look clearer to define it this way with guards (<code>otherwise</code> is just defined as <code>True</code>):</p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| fib n
ghci|   | n == 0    = 1
ghci|   | n == 1    = 1
ghci|   | otherwise = fib (n - 1) + fib (n - 2)
ghci| :}
ghci&gt; fib 5
8
</code></pre>
<p>Even better, we can use <em>pattern matching</em> to define such functions much
more easily. We will look at pattern matching in more detail in the
future:</p>
<pre><code class="language-haskell">ghci&gt; fib 0 = 1
ghci&gt; fib 1 = 1
ghci&gt; fib n = fib (n - 1) + fib (n - 2)
ghci&gt; fib 5
8
</code></pre>
<h2 id="auxiliary-bindings"><a class="header" href="#auxiliary-bindings">Auxiliary Bindings</a></h2>
<p>Thus far we have defined functions as a single expression; this is akin
to writing a <em>lambda expression</em> in Python. As we know, that may not
always be the most ergonomic considering that many functions can be
better defined with several 'statements' that lead into a final
expression. One example would be the following in Python:</p>
<pre><code class="language-python">def weight_sum(n1, w1, n2, w2):
    x = n1 * w1
    y = n2 * w2
    return x + y
</code></pre>
<p>While it is completely acceptable to define this function in one line,
it is not as readable. In Haskell, functions indeed have to be written
as a single expression, but we can define local bindings for the
expression using <code>let</code>:</p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| weightSum n1 w1 n2 w2 =
ghci|   let x = n1 * w1
ghci|       y = n2 * w2
ghci|   in  x + y
ghci| :}
ghci&gt; weightSum 2 3 4 5
26
</code></pre>
<p>The <code>let</code> binding allows us to introduce the definitions of
<code>x</code> and <code>y</code> which are used in the expression after
the <code>in</code> clause. These make writing larger expressions more readable.</p>
<p><code>let</code> bindings are (more-or-less) <em>syntax sugar</em> for function calls:</p>
<pre><code class="language-haskell">weightSum n1 w1 n2 w2 = 
    let x = n1 * w1
        y = n2 * w2
    in  x + y
 
-- same as
 
weightSum n1 w1 n2 w2 =
    f (n1 * w1) (n2 * w2)

f x y = x + y
</code></pre>
<p>Importantly, <code>let</code> bindings are expressions; they therefore evaluate to
a value, as seen in this example:</p>
<pre><code class="language-haskell">ghci&gt; (let x = 1 + 2 in x * 3) + 4
13
</code></pre>
<p>This is different to <code>where</code> bindings, which also allow us to write
auxiliary definitions that support the main definition:</p>
<pre><code class="language-haskell">weightSum n1 w1 n2 w2 = 
    let x = n1 * w1
        y = n2 * w2
    in  x + y
 
-- same as

weightSum n1 w1 n2 w2 = x + y
    where x = n1 * w1
          y = n2 * w2
</code></pre>
<p>Other differences between <code>let</code> and <code>where</code> are not so apparent at this
stage. You are free to use either appropriately (use <code>let</code> where an
expression is desired, using either <code>let</code> or <code>where</code> are both okay in
other scenarios).</p>
<h2 id="data-types"><a class="header" href="#data-types">Data Types</a></h2>
<p>We have looked at some simple data types so far: numbers like
<code>1.2</code>, and strings like <code>"abc"</code>. Strings are
actually <strong>lists</strong> of characters! Strings are surrounded by double
quotes, and characters are surrounded by single quotes, like
<code>'a'</code>.</p>
<p>Lists in Haskell are <em>singly-linked list</em> with homogenous data. That
means that the types of the elements in the list must be the same. We
can write lists using very familiar syntax, e.g. <code>[1, 2, 3]</code>
being a list containing the numbers 1, 2 and 3. Indexing a list can be
done with the <code>!!</code> function.</p>
<pre><code class="language-haskell">ghci&gt; x = [1, 2, 3]
ghci&gt; x !! 1 -- indexing, like x[1]
2
</code></pre>
<p>We can also construct ranges of numbers, or any enumerable type (such as
characters). The syntax for creating such lists is straightforward as
shown in the examples below.</p>
<pre><code class="language-haskell">ghci&gt; y = [1,3..7] -- list(range(1, 8, 2))
ghci&gt; y
[1,3,5,7]
ghci&gt; z = [1..10]  -- list(range(1, 11))
ghci&gt; z
[1,2,3,4,5,6,7,8,9,10]
ghci&gt; inflist = [1..] -- 1,2,3,...
ghci&gt; inflist !! 10
11
</code></pre>
<p>As we stated earlier, strings are lists of characters, we can even build
ranges of characters which result in strings.</p>
<pre><code class="language-haskell">ghci&gt; ['h', 'e', 'l', 'l', 'o']
"hello"
ghci&gt; ['a'..'e']
"abcde"
ghci&gt; ['a'..'e'] ++ ['A'..'D'] -- ++ is concatentation
"abcdeABCD"
</code></pre>
<p>As you know, a singly-linked list is one of two things: an empty list,
or a node with a value (<code>head</code>) and a reference to the remaining part of
the list (<code>tail</code>). Thus, one of the most frequently used operations is the
<em>cons</em> operation (<code>:</code>) which builds (or de-structures) a list
given its head and tail values. The <code>:</code> operator is
right-associative.</p>
<pre><code class="language-haskell">ghci&gt; x = [1, 2, 3]
ghci&gt; 0 : x
[0,1,2,3]
ghci&gt; 0 : 1 : 2 : 3 : []
[0,1,2,3]
ghci&gt; 'a' : "bcde"
"abcde"
</code></pre>
<p>One of the most interesting parts of Haskell is that it has
non-strict evaluation. That means that the compiler is free to evaluate
any expression only when it is needed. This allows us to quite nicely
define recursive data without running into infinite loops:</p>
<pre><code class="language-haskell">ghci&gt; y = 1 : y
ghci&gt; take 5 y
[1,1,1,1,1]
</code></pre>
<p>As we know, performing recursion over a list frequently requires us to
get a head element and then recursively calling the function over the
remaining list. This is nicely supported without any performance costs
unlike in Python, where <code>ls[1:]</code> runs in \(O(n)\). For example,
writing a function that sums a list of numbers might look like the
following in Python:</p>
<pre><code class="language-python">def sum(ls):
    if len(ls) == 0:
        return 0
    return ls[0] + sum(ls[1:])
</code></pre>
<p>Haskell is very similar (<code>head</code> is a function that returns the
first element of a list, and <code>tail</code> is a function that returns
the remainder of a list):</p>
<pre><code class="language-haskell">sum' ls = if length ls == 0
          then 0
          else head ls + sum' (tail ls)
</code></pre>
<p>As a quick aside, the <code>:</code> operator is really a <em>constructor</em> for
lists, so in fact we can use pattern matching (again, we will discuss
this in the future) to define the <code>sum'</code> function very
elegantly.</p>
<pre><code class="language-haskell">sum' [] = 0
sum' (x : xs) = x + sum' xs
</code></pre>
<p>Python also supports <em>list comprehension</em> as you may recall:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = 'abc'
&gt;&gt;&gt; [(i, j) for i in x for j in y if i % 2 == 1]
[(1, 'a'), (1, 'b'), (1, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
</code></pre>
<p>Haskell also provides the same facility, with different syntax:</p>
<pre><code class="language-haskell">ghci&gt; x = [1, 2, 3]
ghci&gt; y = "abc"
ghci&gt; [(i, j) | i &lt;- x, j &lt;- y, odd i]
[(1,'a'),(1,'b'),(1,'c'),(3,'a'),(3,'b'),(3,'c')]
</code></pre>
<p>At this junction it would be most appropriate to discuss tuples. Like
Python, the fields of a tuple can be of different types. However, tuples
in Haskell are <strong>not</strong> sequences. Tuples behave more like the product of
several types, as is usually the case in many domains.</p>
<p>As such, there are not many operations we can do on tuples. One of the
only special cases is pairs, which have functions to project each value:</p>
<pre><code class="language-haskell">ghci&gt; fst (1,"abc")
1
ghci&gt; snd (1,(2,[3,4,5]))
(2,[3,4,5])
ghci&gt; snd (snd (1,(2,[3,4,5])))
[3,4,5]
</code></pre>
<p>This should suffice for now. Now is your turn to try the exercises to
get you started on your functional programming journey! Note that many
of the functions we have used are built-in to Haskell, as defined in
<a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Prelude.html">Haskell's Prelude library</a>. You may want to refer to this library when doing the exercises. A large
portion of the Prelude documentation may be unreadable at this point, however, rest
assured that many of the concepts presented in the documentation will
be covered in this course.</p>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">1</sup>
<p>Note that <code>:{</code> and <code>:}</code> are used only in GHCI to define blocks of
code, and are not part of Haskell.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<h4 id="question-1"><a class="header" href="#question-1">Question 1</a></h4>
<p>Without using GHCI, evaluate the results of
the following expressions:</p>
<ol>
<li><code>3 * 4 + 5</code></li>
<li><code>3 + 4 * 5</code></li>
<li><code>5 ^ 3 `mod` 4</code></li>
<li><code>97 / 4</code></li>
<li><code>97 `div` 4</code></li>
<li><code>if (let x = 3 in x + 3) /= 5 &amp;&amp; 3 &lt; 4 then 1 else 2</code></li>
<li><code>not otherwise</code></li>
<li><code>fst (0, 1, 2)</code></li>
<li><code>succ (1 / 2)</code></li>
<li><code>sqrt 2</code></li>
<li><code>1 `elem` [1, 2, 3]</code></li>
<li><code>let f x = x + 1; g x = x * 2 in (g . f) 1</code></li>
<li><code>[1, 2, 3] ++ [4, 5, 6]</code></li>
<li><code>head [1, 2, 3]</code></li>
<li><code>tail [1, 2, 3]</code></li>
<li><code>init [1, 2, 3]</code></li>
<li><code>[1, 2, 3] !! 0</code></li>
<li><code>null []</code></li>
<li><code>length [1, 2, 3]</code></li>
<li><code>drop 2 [1, 2, 3]</code></li>
<li><code>take 5 [-1..]</code></li>
<li><code>dropWhile even [2, 6, 4, 5, 1, 2, 3]</code></li>
<li><code>sum [fst x | x &lt;- [(i, j) | i &lt;- [1..4], j &lt;- [-1..1]]]</code></li>
</ol>
<h4 id="question-2"><a class="header" href="#question-2">Question 2</a></h4>
<p>Write a function <code>eqLast</code> that
receives two nonempty lists and checks whether the last element of both
are the same. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; eqLast [1,2,3] [4,5]
False
ghci&gt; eqLast "ac" "dc"
True
</code></pre>
<h4 id="question-3"><a class="header" href="#question-3">Question 3</a></h4>
<p>A palindrome is a word that reads the same forward or backward. Write a function <code>isPalindrome</code> that checks if a string is a palindrome. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; isPalindrome "a"
True
ghci&gt; isPalindrome "bcde"
False
ghci&gt; isPalindrome "racecar"
True
</code></pre>
<h4 id="question-4"><a class="header" href="#question-4">Question 4</a></h4>
<p>You are writing a function to
determine the cost of a ride. The cost of a ride is determined by
\(f + rd\) where \(f\) is the flag down fare, \(r\) is the per km rate of the
ride and \(d\) is the distance of the ride in km. Write a function
<code>taxiFare</code> that receives \(f\), \(r\) and \(d\) and computes the
total cost. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; grab = taxiFare 3 0.5
ghci&gt; gojek = taxiFare 2.5 0.6
ghci&gt; grab 3
4.5
ghci&gt; gojek 3
4.3
ghci&gt; grab 10
8.0
ghci&gt; gojek 10
8.5
</code></pre>
<h4 id="question-5"><a class="header" href="#question-5">Question 5</a></h4>
<p>Nowadays, we can customize the
food that we order. For example, you can order your burger with extra or
no cheese. In this exercise, we will write a function that takes a string as the
customization and compute the price for burgers with the code names for
the customization. You are given the price list for ingredients:</p>
<div class="table-wrapper"><table><thead><tr><th>Ingredient</th><th>Price</th></tr></thead><tbody>
<tr><td><code>B</code> for bun</td><td>$0.50</td></tr>
<tr><td><code>C</code> for cheese</td><td>$0.80</td></tr>
<tr><td><code>P</code> for patty</td><td>$1.50</td></tr>
<tr><td><code>V</code> for veggies</td><td>$0.70</td></tr>
<tr><td><code>O</code> for onions</td><td>$0.40</td></tr>
<tr><td><code>M</code> for mushrooms</td><td>$0.90</td></tr>
</tbody></table>
</div>
<p>Write a function <code>burgerPrice</code> that takes in a burger as
a string of characters (each character represents an
ingredient in the burger) and
returns the price of the burger. While doing so, define an auxilliary
function <code>ingredientPrice</code> that receives a single ingredient
(as a character) and returns its price. Define
<code>ingredientPrice</code> as part of <code>burgerPrice</code> using a
<code>where</code> binding. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; burgerPrice "BVPB"
3.2
ghci&gt; burgerPrice "BVPCOMB"
5.3
</code></pre>
<h4 id="question-6"><a class="header" href="#question-6">Question 6</a></h4>
<p>Write a function
<code>sumDigits</code> that receives a nonnegative integer and gives the
sum of its digits. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; sumDigits 123
6
ghci&gt; sumDigits 12356
17
</code></pre>
<h4 id="question-7"><a class="header" href="#question-7">Question 7</a></h4>
<p>Write a function <code>@:</code> that
receives a list and a tuple of two values <code>(start, stop)</code>, and
performs list slicing with indices starting from <code>start</code> and ending at
(and excluding) <code>stop</code>. The step size is 1. Assume that both the start
and stop values are nonnegative integers. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; [1, 2, 3] @: (1, 4)
[2,3]
ghci&gt; [1, 2, 3] @: (4, 1)
[]
ghci&gt; [1, 2, 3] @: (0,1)
[1]
ghci&gt; [1, 2, 3] @: (1,67)
[2,3]
</code></pre>
<p>Syntactically, the way to define this function might be the following:</p>
<pre><code class="language-haskell">ls @: (start, stop) = your implementation here
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>As per the course title, one of the most important aspects of functional programming that we shall cover is <em>types</em>. In this chapter, we shall describe what types are, how they are useful and how we can use type information to write code, and some aspects of types that allow us to reduce boilerplate code while still retaining type-safety. In addition, we describe how we can define our own data types in Haskell, and a neat feature known as <em>pattern matching</em> that is extremely useful in the presence of <em>algebraic data types</em>. We also offer some examples of how we can incorporate these concepts in Python.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="type-systems"><a class="header" href="#type-systems">Type Systems</a></h1>
<p>As the course title suggests, Haskell is a typed functional programming
language—in particular, it uses a statically-typed <em>type system</em>. This
begs the question, "what is a type system?"</p>
<p>An online search for definitions might give you the following:</p>
<blockquote>
<p><strong>Definition (Type System)</strong>. A type system is a
<strong>tractable syntactic method</strong> for <strong>proving the absence of certain
program behaviours</strong> by classifying phrases according to the <strong>kinds of
values they compute</strong>.</p>
</blockquote>
<p>Let us unpack the highlighted phrases in the definition above.</p>
<h4 id="tractable-syntactic-method"><a class="header" href="#tractable-syntactic-method">Tractable syntactic method</a></h4>
<p><em>Tractable</em> more or less means <em>easy</em>, or <em>polynomial time</em>. <em>Method</em>
refers to a <em>formal method</em>, which means it is a kind of mathematically
formal process. The fact that it is a <em>syntactic method</em> means that this
formal analysis can be done syntactically, without the need to appeal to
a <em>semantic</em> analysis (although, static type checking is done against
the static semantics of the type system). More or less, it can be
performed without executing any of the code it is analyzing.</p>
<h4 id="proving-the-absence-of-certain-program-behaviours"><a class="header" href="#proving-the-absence-of-certain-program-behaviours">Proving the absence of certain program behaviours</a></h4>
<p>In the case of type systems, this usually means that the type system is
used to prove the absence of type errors. The realm of program analysis
is broken down into roughly two kinds: over-approximation analyses, and
under-approximation analyses. Notice that both perform <em>approximations</em>
of program behaviour—this is because obtaining a precise specification of
any program is <em>undecidable</em>. Generally, static analyses, like type
checking, perform an over-approximation of program behaviour. An analogy
of how this works is as follows: assume true program behaviour is \(x\)
and buggy behaviour is at \(y\) (these are all positive numbers, let's
say). We then over-approximate the true program behaviour, giving us
\(x + \epsilon\). If we can show that \(x + \epsilon &lt; y\), then we can
guarantee that \(x &lt; y\), so the program is not buggy.</p>
<p>A more concrete example is as follows. Let's suppose we have the following code snippet in Python:</p>
<pre><code class="language-python">y: int = 0 if f() else 'abc'
print(y + 1)
</code></pre>
<p>Notice that if we can determine that <code>f</code> always returns
<code>True</code>, then we know for sure that there will be no type
errors. However, it is not possible to make this determination in
general. Thus, we over-approximate program behaviour by assuming that it
is possible that <code>f</code> may return either <code>True</code> or
<code>False</code>leading us to show that we cannot prove the absence of
type errors in this program. Instead, if we had written the following:</p>
<pre><code class="language-python">y: int = 0 if f() else 1
print(y + 1)
</code></pre>
<p>Then even by assuming that both branches of the conditional expression
may be the result, we can conclusively show that <code>y</code> will
always be an <code>int</code>. Our over-approximation of program behaviour
doesn't have type errors, meaning, that our actual program really does
not have type errors.</p>
<h4 id="kinds-of-values-they-compute"><a class="header" href="#kinds-of-values-they-compute">Kinds of values they compute</a></h4>
<p>This is a simple description of what <em>types</em> are. Types, as we will
informally define later, are classifications of data/things in the
program that all behave similarly or have similar characteristics. In
some other sense, types can be seen as abstractions over terms.</p>
<p>Simply put, a type system is a formal system that lets us show that
there won't be type errors. As we have seen, the nature of
[statically-typed] type systems forces us to program in a different
way (at least compared to dynamically typed languages like Python), and
this is what we will explore in this chapter.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>Type systems are systems of types; but <em>what is a type</em>? In essence, a
type is like a <em>kind</em> of thing, or a high-level description of what
something is. Types (1) give meaning to some data, and (2) describe what
its members are like.</p>
<p>Since you have already programmed in Python, you should have some
inkling of what types are. In Python, everything is an object. Thus, in
Python, the type of an object is the <em>class</em> from which it was
instantiated.</p>
<p>The following is some sample output showing the types of various objects. The output of
all these function calls are classes.</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 1
&gt;&gt;&gt; type(x)
&lt;class 'int'&gt;
&gt;&gt;&gt; type('abc')
&lt;class 'str'&gt;
&gt;&gt;&gt; class A: pass
&gt;&gt;&gt; type(A())
&lt;class '__main__.A'&gt;
</code></pre>
<p>This is very apt—classes are blueprints for creating objects, and (for
the most part), all <em>instances</em> of a class will abide by the
specification as laid out in the class. Therefore, Python's type system
based on classes is very appropriate for our purposes. In fact, this is
not unique to Python. Many other languages with OO features also have
classes as types.</p>
<p>In Python, we mainly think of types as being bound to <em>objects</em>, that
is, objects have <em>reified</em> types that can be accessed at runtime. We
have never thought of assigning types to variables or function
parameters, since when we are investigating the type of a variable, what
we are really doing is investigating the type of the object that is
referred to by the variable. However, Python actually does allow us to
annotate variables, function parameters etc with types to document
"suggestions" as to what the types of the objects assigned to them
should be.</p>
<p>Observe the following program fragment.</p>
<pre><code class="language-python">def f(x: int) -&gt; str:
    y: int = x * 2
    return f'{x} * 2 = {y}'
z: int
z = 3
s: str = f(z)
print(s) # 3 * 2 = 6
</code></pre>
<p>This program fragment contains several <em>type annotations</em>. In the
function header, we have a specification for <code>f</code> to receive an
<code>int</code> and return a <code>str</code>. That is, if the type
annotations make sense, then passing an <code>int</code> into <code>f</code>
will always result in a <code>str</code>. In the function body, we also
have an annotation for the variable <code>y</code> stating that it is also
an <code>int</code>. This makes sense—if <code>x</code> is an <code>int</code>,
then so will <code>x * 2</code>. Actually, the type of <code>y</code> can be
<em>inferred</em> (a type checker can determine the type of <code>y</code>
automatically), so our type annotation for it is not necessary. Outside
the function body we have other type annotations, documenting what the
types of the other variables are. On visual inspection, we can see that
all the type annotations make sense and we have adhered to them fully;
we are thus guaranteed that we have no type errors.</p>
<p>While Haskell also provides the capability for type annotations, a
notable distinction lies in Haskell's <em>enforcement</em> of adherence to
these annotations. Consequently, it might be more fitting to refer to
them as <em>type declarations</em>. Nevertheless, the core concept remains
unchanged: specifying the types of variables, functions, or terms
ensures that, when adhered to correctly, our program will be well-typed.</p>
<p>The following code snippet shows some Haskell code with type
declarations.</p>
<pre><code class="language-haskell">f :: Int -&gt; String
f x = show x ++ " * 2 = " ++ show y
    where y = x * 2
z :: Int
z = 3
s :: String
s = f(z) -- 3 * 2 = 6
</code></pre>
<p>A natural question would be to ask, what types can we declare variables
to be of? We have looked at some basic types earlier, <code>Int</code>,
<code>String</code> (which is an alias for <code>[Char]</code>),
<code>Char</code>, <code>[Int]</code>, <code>Bool</code>,
<code>Double</code> etc. There are many other types in Haskell's Prelude,
and later on we will see how we can create our own types.</p>
<p>Declaring types for functions is slightly different. In Python, when
writing type annotations for functions, we are really annotating the
types of its parameters, and its return type. In Haskell, we are
declaring the type of the function itself. The difference is actually
not as large as one might imagine. If the function receives a type \(S\)
and returns a type \(T\), then the function has the type \(S\to T\). We
similarly use arrows to declare the type of functions in Haskell. Thus,
as above, since <code>f</code> receives an <code>Int</code> and returns a
<code>String</code>, then <code>f</code> itself is of the type
<code>Int -&gt; String</code>.</p>
<p>Haskell has roots in formal systems, in particular, System \(F_C\), which
is a dialect of System \(F\omega\) (without type lambdas). Thus, the types
of terms can be described formally. Knowing the formal typing rules of
Haskell is not required, but may give you some insight as to how it
works. Below we show the typing rules for function declarations, more
accurately, lambda abstractions.</p>
<p>\[\frac{\Gamma,x:S\vdash e: T}{\Gamma\vdash\lambda x.e : S \to T}\text{T-Abs}\]</p>
<p>The T-Abs rule is an <em>inference rule</em> stating that if the
premise above the line is true, then the conclusion below the line will
also be true. Let's first parse the premise. The part to the left of
\(\vdash\) is the <em>typing environment</em>, more or less describing the type
declarations we have at the point of analysis of the program.
Specifically, \(\Gamma\) is the actual type environment, while \(x: S\) is
an additional assumption that a variable \(x\) has type \(S\). The part to
the right of \(\vdash\) describes the judgement of the type of \(e\) being
\(T\). Overall, the premise states "given what we have so far, if in
assuming \(x\) is of type \(S\) we get that \(e\) is of type \(T\), ...". The
conclusion can be understood similarly: it states that the typing
environment \(\Gamma\) will show that the function \(\lambda x.e\) has type
\(S \to T\). Putting these together, the rule states that "given typing
environment \(\Gamma\), if by assuming that variable \(x\) has type \(S\) we
get that the expression \(e\) is of type \(T\), then \(\Gamma\) will also show
that the type of the function \(\lambda x.e\) is of type \(S \to T\)".</p>
<p>A simple demonstration in Python is as follows: suppose we have \(x\) as
<code>x</code> and \(e\) as <code>x * 2</code>. If we assume that <code>x</code>
is of type <code>int</code>, then we know that <code>x * 2</code> will also
be an <code>int</code>. Therefore, the type of \(\lambda x.e\) which is
<code>lambda x: x * 2</code> is <code>int -&gt; int</code><sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>What about multi-parameter functions? Remember that in Haskell, all
functions are curried, thus, all functions in Haskell are single
parameter functions. Curried functions receive one parameter, and return
a function <em>closure</em> that receives the remaining variables and
eventually will return the final result. Therefore the <code>(+)</code>
function actually looks more like:</p>
<pre><code class="language-python"># Python
def add(x):
    return lambda y: x + y
</code></pre>
<p>The type of <code>add</code> is more like <code>int -&gt; (int -&gt; int)</code>.
This is (more or less) the type of <code>(+)</code> in Haskell, which
(more or less) has type <code>Int -&gt; Int -&gt; Int</code>. Note that
<code>-&gt;</code> is right-associative, so <code>Int -&gt; Int -&gt; Int</code> is
the same as <code>Int -&gt; (Int -&gt; Int)</code>.</p>
<p>In Haskell, the types of everything are <strong>fixed</strong>. This should be
unsurprising since everything in Haskell is immutable, but it is a
restriction that can also be found in other less restrictive languages
like Java and C++. In this environment, we have to, perhaps ahead of
time, decide what the type of a variable, function, function parameter
is, then write the implementation of your function around those
restrictions.</p>
<p>The following code
snippet first <em>declares</em> the type of <code>f</code> before showing its
implementation. It is not only good practice to declare types above
their implementation, but it can be a nice way to frame your mind around
the implementation of your function—start by providing a high-level
specification of your function, then work on the implementation to
describe what the function is actually trying to achieve.</p>
<pre><code class="language-haskell">f :: Int -&gt; String -- explicit type declaration
f x = show x ++ "!"
g x = x + 1 -- type of g is inferred
</code></pre>
<p>However, observe that the type of <code>g</code> is not defined. This
does not mean that the type of <code>g</code> is dynamic or is not being
checked; rather, Haskell can infer the <em>principal</em> (most liberal) type
of <code>g</code> via a process known as <em>type inference</em>. That still
means that the implementation of <code>g</code> itself must be well-typed
(its implementation does not break any of the typing rules), and that
any users of <code>g</code> must abide by its static type signature.</p>
<p>Generally speaking, it is good practice to declare the types of
top-level bindings—that is, nested bindings of functions, variables (for
example, in <code>let</code> expressions) do not need type declarations
and can often be inferred. The example above of the declaration of
<code>f</code> is a perfectly idiomatic way of defining and declaring a
function, unlike <code>g</code> which lacks a type declaration.</p>
<h3 id="programming-with-types"><a class="header" href="#programming-with-types">Programming with Types</a></h3>
<p>When learning Python, you might not have had to think very much about
types; this is because Python does not care about type annotations. For
example, you can happily annotate a variable to be an <code>int</code> but
then assign a string into it. This is very much unlike Haskell, where
adherence to type declarations and well-typedness is <em>enforced</em> by the
compiler—the compiler will reject any program that is not well-typed.</p>
<p>Observe the following program fragment:</p>
<pre><code class="language-haskell">f :: Int -&gt; String -- explicit type declaration
f x = show x ++ "!"
 
g = f "1" -- compiler throws type error as f receives Int, not String
</code></pre>
<p>The definition of <code>f</code> is well-typed since it abides by all the
typing rules, and all the types make sense. However, since <code>f</code>
only receives <code>Int</code>, passing a <code>String</code> into it is a
clear violation of the rules. Thus, the entire program is ill-typed and
will not be compiled. Try this for yourself!</p>
<p>Programming in such a strict and formal language can feel restrictive,
but these restrictions actually feel more like "guard rails" or
"seatbelts"; if your program passes the checks done by the compiler, you
can be quite assured that it works. As the saying goes, in Haskell, "if
it compiles, it works". Although this is not necessarily true,
Haskell's robust and expressive type system allows you to rule out a
large class of bugs, and often, results in correct programs. However,
one question to ask is: how do we go about programming with static
types?</p>
<p>The first step of being able to program with types is understanding the
typing rules. We shall elide explanation on how typing works with
inference, typeclasses, polymorphism etc. and focus solely on the
simplest typing rules:</p>
<ol>
<li>
<p>In a binding <code>x = e</code>, the type of <code>x</code> must be
the same as the type of <code>e</code></p>
</li>
<li>
<p>In a conditional expression <code>if x then y else z</code>, the type
of <code>x</code> must be <code>Bool</code> and the types of
<code>y</code> and <code>z</code> must both be equal to some type
<code>a</code>; the type of the entire expression is <code>a</code></p>
</li>
<li>
<p>In a function application expression <code>f x</code> the type of
<code>f</code> must be <code>a -&gt; b</code> for some <code>a</code> and
<code>b</code>, <code>x</code> must be of type <code>a</code>, and the
type of the expression is <code>b</code></p>
</li>
<li>
<p>(Without loss of generality of number of parameters) For a function
binding <code>f x = e</code> the type of <code>f</code> must be
<code>a -&gt; b</code> for some <code>a</code> and <code>b</code> and in
assuming <code>x</code> to be of type <code>a</code>, <code>e</code>
must be of type <code>b</code>.</p>
</li>
</ol>
<p>Try calculating the types of every expression in the following code
snippet. Can you get it all right?</p>
<pre><code class="language-haskell">f :: Int -&gt; Int -&gt; [Int]
f x n =
  if n == 0 then
    []
  else
    let r = f x (n - 1)
    in  x : r
</code></pre>
<p>Let's work through this example.</p>
<ul>
<li>We are declaring <code>f</code> to be of type <code>Int -&gt; Int -&gt; [Int]</code>, so it stands to reason that in the definition of <code>f</code> we are assuming that <code>x</code> and <code>n</code> are both of type <code>Int</code>.</li>
<li>For this to be well-typed, we must ensure that the conditional expression evaluates to <code>[Int]</code>, that means both branches must themselves evaluate to <code>[Int]</code>.</li>
<li>First we observe the condition <code>n == 0</code>; the <code>(==)</code> function receives two numbers and returns a <code>Bool</code>, so this is well-typed.</li>
<li>Looking at the <code>True</code> branch, we see that we are returning the empty list, which matches the type of <code>[Int]</code>.</li>
<li>In the <code>False</code> branch, we have a <code>let</code> expression, so we must ensure that <code>x : r</code> evaluates to <code>[Int]</code> too.</li>
<li>The <code>let</code> binding contains a binding <code>r = f x (n - 1)</code>; knowing that (by our own declaration) <code>f</code> has type <code>Int -&gt; Int -&gt; [Int]</code>, knowing that <code>x</code> and <code>n - 1</code> are of type <code>Int</code> means we can safely conclude that <code>r</code> has type <code>[Int]</code> (of course, the <code>(-)</code> function receives two
integers and returns an integer).</li>
<li>The <code>(:)</code> function receives an <code>Int</code> and a <code>[Int]</code> and returns a
<code>[Int]</code>, so all the types match.</li>
</ul>
<p>Overall, we have seen that we
successfully determined the types of every expression in the program
fragment, and concluded that it is well-typed.</p>
<p>Now that you are familiar with the basic typing rules and (roughly) how
types are inferred, the next step is to get comfortable writing programs
with static types. Generally this comes with practice, but one great way
to get you started with typeful programming is to try letting the <em>types guide your programming</em>.</p>
<p>Suppose we are trying to define a function <code>f</code> that receives
an integer <code>x</code> and returns a string showing the result of
multiplying <code>x</code> by 2:</p>
<pre><code class="language-haskell">ghci&gt; f 3
"3 * 2 = 6"
ghci&gt; f 5
"5 * 2 = 10"
</code></pre>
<p>Let us try implementing this function. The first thing we have to
consider is the type of <code>f</code> itself, which by definition,
should receive an <code>Int</code> and return a <code>String</code>. As
such, we may start with the type declaration
<code>f :: Int -&gt; String</code>.</p>
<p>Next, we know we are eventually going to have to convert <code>x</code>
into a <code>String</code>. We know that there is a <code>show</code>
function that does that. Its type signature (modified) is
<code>Int -&gt; String</code>, so we know that <code>show x</code> is a
<code>String</code>.</p>
<p>We also know that we need to multiply <code>x</code> by 2. For this, we
can use the <code>(*)</code> function, which has a (modified) type
signature of <code>Int -&gt; Int -&gt; Int</code>. Thus, we can write
<code>x * 2</code> and that gives us an <code>Int</code>. Knowing that we
eventually need to display it as a <code>String</code>, once again, we
can rely on the <code>show</code> function.</p>
<p>Now we have all the numbers we need in <code>String</code> form, we need
to concatenate them together. For this, we can rely on our trusty
<code>(++)</code> function that receives two <code>String</code>s and
returns a <code>String</code>. Using this allows us to concatenate all
our desired strings together. Since our original function <code>f</code>
was meant to return a <code>String</code>, we can return it as our final
result.</p>
<pre><code class="language-haskell">f :: Int -&gt; String
f x = 
  let sx :: String = show x
      y  :: Int    = x * 2
      sy :: String = show y
  in  sx ++ " * 2 = " ++ sy
</code></pre>
<p>This is a simple example of using
types to guide your programming. While seemingly trivial, this skill can
be incredibly useful for defining <strong>recursive</strong> functions!</p>
<p>Suppose we are trying to define a function that sums the integers in a
list. As always, we must decide what the type of this function is. As per our
definition, it receives a list of integers and returns the final sum,
which should be an integer as well. This gives us the type declaration
<code>sum' :: [Int] -&gt; Int</code>.</p>
<p>First, let us define the base case. We should be quite clear on what the
condition for the base case is: it should be when the input list is empty.
What should we return in the base case? By our type declaration, we must
return an <code>Int</code>, so we must express our base result in that
type. The result is <code>0</code>, which matches our type declaration.</p>
<p>Next we must define the recursive case. This one might be tricky
initially. We know that we can make our recursive call, passing in the
tail of the input list. This might look something like
<code>sum' (tail ls)</code>. We must be very clear about the type of this
expression; as per the type declaration, the result is an
<code>Int</code>, and not anything else.</p>
<p>We also know that we want to add the head of the input list to the
result of the recursive call. In doing so we get an <code>Int</code>.</p>
<p>Finally, we can add the results together, giving us an <code>Int</code>,
which matches our return type.</p>
<pre><code class="language-haskell">sum' :: [Int] -&gt; Int
sum' ls = 
    if null ls
    then 0
    else let r  :: Int = sum' (tail ls)
             hd :: Int = head ls
         in  hd + r
</code></pre>
<p>By getting used to types, having a statically-typed system no longer
feels like a chore or a hurdle to cross, and instead feels like a
support system that makes everything you are doing clear! Many
developers (including myself) love statically-typed programming
languages for this very reason, so much so that people have gone to
great lengths to add static typing to otherwise dynamically typed
languages like JavaScript (the typed variant of JavaScript is TypeScript).</p>
<p>Python is no different. Several static type checkers are out there to
help us analyze the well-typedness of our program. One of the most
popular analyzers is <code>mypy</code>, which was heavily developed by Dropbox.
However, I recommend <code>pyright</code> because at the time of writing, it has
implemented bleeding edge features that we need for further discussion
of types which we shall see very shortly.</p>
<p>Let's see <code>pyright</code> in action. We shall write an ill-typed
program and see if it catches the potential bug:</p>
<pre><code class="language-python"># main.py
def f(x: int, y: int) -&gt; int:
    z = x / y
    return z
</code></pre>
<p>Running <code>pyright</code> on this program will reveal an error message:</p>
<pre><code>pyright main.py
</code></pre>
<pre><code class="language-output error">pyright main.py
/home/main.py
  /home/main.py:4:12 - error:
    Expression of type "float" is incompatible with return
    type "int"
    "float" is incompatible with "int" (reportReturnType)
1 error, 0 warnings, 0 informations 
</code></pre>
<p>Great! This makes sense because assuming <code>x</code> and <code>y</code>
are of type <code>int</code>, the type of <code>z</code> should actually be
<code>float</code>! Let's correct the program and try running <code>pyright</code>
against the new program:</p>
<pre><code class="language-python"># main.py
def f(x: int, y: int) -&gt; int:
    z = x // y
    return z
</code></pre>
<pre><code class="language-output info">pyright main.py
0 errors, 0 warnings, 0 informations
</code></pre>
<p>Very well! We have now learnt how to program with types in Haskell and
in Python, and since Python does not come with a type-checker, we are
able to use tools like <code>pyright</code> to do the type checking for us!</p>
<p>One additional great feature about <code>pyright</code> is that it is actually also a
language server. As such, you can include <code>pyright</code> in your favourite text
editors so that it can catch bugs while writing programs!</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Python doesn't have arrow types. The actual type of the function
is <code>Callable[[int], int]</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="sec:polymorphism"><a class="header" href="#sec:polymorphism">Polymorphism</a></h1>
<p>In FP, functions describe computation and applying functions perform
said computation. For example, given a function \(f\):
$$f(x) = x \times 2$$
\(f\) describes what computation is to be done
(multiplying the parameter by 2), and applying \(f\) onto a value (such as
\(f(2)\)) performs the computation that gives the result, which is \(4\).
Importantly, you might also find that applying it onto a different input
may give you a different outcome. In this case, \(f(2)=4\neq f(3)=6\). The
output depends on the input, i.e. we have <em>terms that depend on terms</em>.
This may at first glance seem like a trivial observation because that is
what functions are designed to do: if functions are always constant like
\(g(x) = 1\) then we can always replace all applications of the function
with the result and no computation needs to be done.</p>
<p>However, now that we have learnt about types, we get a much more
interesting avenue for extending this idea of dependence. In fact, we
now have three orthogonal directions to explore<sup class="footnote-reference"><a href="#2">1</a></sup>:</p>
<ol>
<li>
<p>Can terms depend on types?</p>
</li>
<li>
<p>Can types depend on types?</p>
</li>
<li>
<p>Can types depend on terms?</p>
</li>
</ol>
<p>The answer to the first two questions is yes! This phenomenon is known
as [parametric] <em>polymorphism</em>, i.e. where types and terms can depend
on types<sup class="footnote-reference"><a href="#3">2</a></sup>.</p>
<h2 id="polymorphic-types"><a class="header" href="#polymorphic-types">Polymorphic Types</a></h2>
<p>Let us motivate this need with an example. Suppose we are trying to
create a wrapper class called <code>Box</code>, that contains a single
value. As per usual, we have to think about the type of the value it
contains. At this point we cannot simply allow the value to be
<em>anything</em>, so we shall fix the type of the value to something, say,
<code>int</code>.</p>
<pre><code class="language-python"># Python
@dataclass
class IntBox:
    value: int
</code></pre>
<p>However, we may later want a <code>Box</code> that stores strings. In this
case, we will have to define a new class that does so.</p>
<pre><code class="language-python"># Python
@dataclass
class StrBox:
    value: str
</code></pre>
<p>Recall one of the core principles in programming: whenever you see a
pattern in your code, <em>retain similarities</em> and <em>parameterize</em>
differences. Looking at the two <code>Box</code> implementations, you should be
able to see that the implementation is virtually identical, and the only
difference is the <em>type</em> of <code>value</code>. We have previously been able to
parameterize values (regular function parameters), parameterize
behaviour (higher-order functions), however, can we parameterize
<em>types</em>?</p>
<p>Yes! We can define <code>Box</code> to receive a <em>type parameter</em> <code>a</code>, and allow
the value in the box to be of that type <code>a</code>.</p>
<pre><code class="language-python">@dataclass
class Box[a]:
    value: a
</code></pre>
<p>This class is a generalized <code>Box</code> class that can be <em>specialized</em> into a
specific <code>Box</code>. For example, by replacing <code>a</code> with <code>int</code> then
we recover our <code>IntBox</code> class with an <code>int</code> value;
replacing <code>a</code> with <code>str</code> recovers our <code>StrBox</code> class
with a <code>str</code> value.</p>
<pre><code class="language-python">x: Box[int] = Box[int](1)
y: Box[str] = Box[str]('a')
z: Box[Box[int]] = Box(Box(1))
bad: Box[int] = Box[int]('a')
</code></pre>
<p>In Python and many Object-Oriented languages, <code>Box</code> is called a
<em>generic</em> or <em>parametrically polymorphic</em> class/type. This is one
example of a <em>type depending on a type</em>.</p>
<h2 id="polymorphic-functions"><a class="header" href="#polymorphic-functions">Polymorphic Functions</a></h2>
<p>The same principle can be applied to <em>terms depending on types</em>. Suppose
we have a function <code>singleton</code> that is to receive an object and puts
that object in a list. In the same vein, we have to decide what the type
of the parameter is, which dictates the corresponding return type. For
example, may define this function that works on <code>int</code>s, and
separately, another function that works on <code>str</code>s:</p>
<pre><code class="language-python">def singleton_int(x: int) -&gt; list[int]:
    return [x]
def singleton_str(x: str) -&gt; list[str]:
    return [x]
</code></pre>
<p>Once again, we can observe that the implementations of these functions
are identical, and only the types are different. Let us combine these
implementations into a single function where the types are
parameterized!</p>
<pre><code class="language-python"># Python 3.12
def singleton[a](x: a) -&gt; list[a]:
    return [x]
x: list[int] = singleton(1)
y: list[str] = singleton('a')
bad: list[bool] = singleton(2)
</code></pre>
<p><code>singleton</code> is what is known as a <em>polymorphic function</em>: a
function that depends on the type!</p>
<h2 id="polymorphic-functions-in-haskell"><a class="header" href="#polymorphic-functions-in-haskell">Polymorphic Functions in Haskell</a></h2>
<p>How would we define the type of polymorphic functions in Haskell? That
is pretty straightforward: type parameters are lowercase. For example,
the <code>singleton</code> function can be defined like so:</p>
<pre><code class="language-haskell">singleton :: a -&gt; [a]
singleton x = [x]
</code></pre>
<p>In fact we can see the type signatures of some built-in polymorphic
functions:</p>
<pre><code class="language-haskell">ghci&gt; :t head
head :: [a] -&gt; a
ghci&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</code></pre>
<p>Not sure what the type parameters are? Or, want to make your type
parameters explicit? We can use <code>forall</code> to introduce a
polymorphic function type, with the variables succeeding
<code>forall</code> being the type parameters to the function.</p>
<pre><code class="language-haskell">ghci&gt; :set -fprint-explicit-foralls
ghci&gt; :t head
head :: forall a. [a] -&gt; a
ghci&gt; :t (.)
(.) :: forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
ghci&gt; :{
ghci| singleton :: forall a. a -&gt; [a]
ghci| singleton x = [x]
ghci| :}
ghci&gt; singleton 2
[2]
ghci&gt; singleton 'a'
"a"
</code></pre>
<p>Let's inspect the type signature of <code>(.)</code>. Recall that this
function performs function composition; the implementation of
<code>(.)</code> might look something like this:</p>
<pre><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) g f x = g (f x)
</code></pre>
<p>We have three terms, <code>g</code>, <code>f</code> and <code>x</code>. We know that <code>g</code> and <code>f</code> must be
functions since we are calling them, thus we are going to let the types
of <code>g</code> and <code>f</code> to be <code>d -&gt; c</code> and <code>a -&gt; b</code>
respectively. Additionally, <code>x</code> is just some other term, and we will let
its type be <code>e</code>. Thus for now, we shall let the type signature of
<code>(.)</code> be the following, assuming the function ultimately returns
<code>r</code>:</p>
<pre><code class="language-haskell">(.) :: (d -&gt; c) -&gt; (a -&gt; b) -&gt; e -&gt; r
</code></pre>
<p>Now notice the following: for <code>f x</code> to be well-typed, the type
of <code>x</code> must be the same as the type of the parameter to <code>f</code>, which is
<code>a</code>. Thus, more accurately, <code>x</code> must be of type <code>a</code>:</p>
<pre><code class="language-haskell">(.) :: (d -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; r
</code></pre>
<p>We can now see that <code>f x</code> is well-typed, and this expression is of type
<code>b</code>. We then pass this result into <code>g</code>. For this to be well-typed,
again, the parameter type of <code>g</code> must match the type of <code>f x</code>. Thus, <code>g</code>
must actually be of type <code>b -&gt; c</code> for some <code>c</code>:</p>
<pre><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; r
</code></pre>
<p>Finally, <code>g (f x)</code> has type <code>c</code>, which is what is returned from the
function. As such, the return type of <code>(.) g f x</code> should also
be <code>c</code>. This recovers the type signature shown by GHCI.</p>
<blockquote>
<p>You might be surprised to know that the process of recovering or
reconstructing the types is known as type inference, which as stated in
earlier chapters, is also done by GHC! When you omit the type signature
of any binding, GHC goes through this same process and helps us
determine what the type of that binding is.</p>
</blockquote>
<h2 id="programming-with-polymorphic-typesfunctions"><a class="header" href="#programming-with-polymorphic-typesfunctions">Programming with Polymorphic Types/Functions</a></h2>
<p>When should we define polymorphic types or functions? As we have shown,
when the implementations of classes, data types, functions etc. are the
same except for the types, then we are able to parameterize the
differing types which makes the class/data type/function polymorphic!
Knowing immediately when to create polymorphic types/functions takes
some practice, so to start, just create specialized versions of those
types/functions, and as the need arises, make them polymorphic by
parameterizing the appropriate types.</p>
<p>For example, suppose we
are trying to create a <code>Tree</code> class that represents binary trees. Should
this class be polymorphic? For now, let's ignore this fact and proceed
to create a naive implementation of this class. Further suppose we are
expecting to create a tree of integers, so we shall let that be the type
of the values of our tree.</p>
<pre><code class="language-python">@dataclass
class IntTree:
    pass
@dataclass
class IntNode(IntTree):
    left: IntTree
    value: int
    right: IntTree
@dataclass
class IntLeaf(IntTree):
    value: int
</code></pre>
<p>Looks great! From this class we are able to create binary trees of
integers, for example, <code>IntNode(IntLeaf(1), 2, IntLeaf(3))</code>
gives a binary tree with preorder 2, 1 and 3.</p>
<p>Further suppose later on we need to store strings in a binary tree.
Again, let's naively implement a separate class that does so:</p>
<pre><code class="language-python">@dataclass
class StrTree:
    pass
@dataclass
class StrNode(StrTree):
    left: StrTree
    value: str
    right: StrTree
@dataclass
class StrLeaf(StrTree):
    value: str
</code></pre>
<p>Once again, notice that the implementations of the classes are
identical, and the only difference is in the types! This is one clear
example where we should make our class polymorphic!</p>
<pre><code class="language-python">@dataclass
class Tree[a]:
    pass
@dataclass
class Node[a](Tree[a]):
    left: Tree[a]
    value: a
    right: Tree[a]
@dataclass
class Leaf[a](Tree[a]):
    value: a
</code></pre>
<p>Now from this one class, we are able to create all kinds of trees!</p>
<p>As another example, suppose we are trying to define a function that reverses a list. Once
again, we have to be specific with the type of this function.
Temporarily, we shall create a function that works on lists of integers:</p>
<pre><code class="language-python">def reverse_int(ls: list[int]) -&gt; list[int]:
    return [] if not ls else \
           reverse_int(ls[1:]) + [ls[0]]
</code></pre>
<p>Then, later on we might have to define a similar function that reverses
lists of strings:</p>
<pre><code class="language-python">def reverse_str(ls: list[str]) -&gt; list[str]:
    return [] if not ls else \
           reverse_str(ls[1:]) + [ls[0]]
</code></pre>
<p>Once again, we can see that the implementations of the two functions are
identical, and only the types are different. Make this function
polymorphic!</p>
<pre><code class="language-python">def reverse[a](ls: list[a]) -&gt; list[a]:
    return [] if not ls else \
           reverse(ls[1:]) + [ls[0]]
</code></pre>
<p>The two examples above give us some scenarios where
we discover that we have to make a class or function polymorphic. More
importantly, we see that the implementations across the specialized
versions of the class/function are equal, and only the types differ. One
key insight we can draw from this is: a class/function should be made
polymorphic if its implementation is <em>independent</em> of the type(s) it is
representing/acting on.</p>
<hr />
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">1</sup>
<p>These are the three axes that form the <em>lambda cube</em>, with the
simply typed lambda calculus only having terms that depend on terms,
and the Calculus of Constructions having types and terms depending
on types and terms.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p>The word <em>polymorphism</em> can be broken down into <em>poly</em> (many) and
<em>morphism</em> (shape). The word is not just used in Computer Science,
but in other areas like biology and pharmacology. Within Computer
Science itself there are several kinds of polymorphism, and we shall
investigate the most common ones in this lecture and in later
lectures too. Finally, polymorphism in Computer Science is really
about things taking on different forms, but I suspect that our
description of parametric polymorphism gives a pretty good picture
of what it entails.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<p>We have just seen different data types in Haskell, and introduced the
concept of polymorphic types as demonstrated by examples in Python. Yet,
we have not discussed how we can create our own (polymorphic) data types
in Haskell!</p>
<p>Haskell is a purely functional language, so do not expect classes here.
In OOP, objects have both data (attributes) and behaviour (methods),
whereas this is not necessarily a principle in FP (although, you can have data
types with functions as fields since functions are first-class). We already know how to create functions, so now we must investigate how we can create data types in a
purely functional language.</p>
<p>If we think about it carefully, we might realize that data types are a
mix of the following:</p>
<ul>
<li>
<p>A type <strong>and</strong> another type <strong>and</strong>...<strong>and</strong> yet another type</p>
</li>
<li>
<p>A type <strong>or</strong> another type <strong>or</strong>...<strong>or</strong> yet another type</p>
</li>
</ul>
<p>We can express the following types using <strong>and</strong> and <strong>or</strong> over other
types:</p>
<ul>
<li>
<p>A <code>Fraction</code> consists of a numerator (<code>Int</code>) <strong>and</strong> a denominator
(<code>Int</code>)</p>
</li>
<li>
<p>A <code>Student</code> consists of a name (<code>String</code>) <strong>and</strong> an ID (<code>Int</code>)</p>
</li>
<li>
<p>A <code>Bool</code> is either <code>True</code> <strong>or</strong> <code>False</code></p>
</li>
<li>
<p>A <code>String</code> is either an empty string <strong>or</strong> (a head character
(<code>Char</code>) <strong>and</strong> a tail list (<code>String</code>))</p>
</li>
<li>
<p>A polymorphic <code>Tree</code> is either (a leaf with a value of type <code>a</code>)
<strong>or</strong> (a node with a value (<code>a</code>) <strong>and</strong> a left subtree (<code>Tree a</code>)
<strong>and</strong> a right subtree (<code>Tree a</code>))</p>
</li>
</ul>
<p>This formulation of data types as products (<strong>and</strong>) and/or sums
(<strong>sum</strong>) is what is known as Algebraic Data Types (ADTs) (not to be confused
with Abstract Data Types). In Haskell, types are <strong>sums</strong> of zero or more
<strong>constructors</strong>; constructors are <strong>products</strong> of zero or more types.</p>
<p>To create a new data type in Haskell, we can use the <code>data</code>
keyword. Let us create a fraction type based on our algebraic
specification above:</p>
<pre><code class="language-haskell">data Fraction = Fraction Int Int

half :: Fraction
half = Fraction 1 2
</code></pre>
<p>On the left hand side we have the declaration of the type, and on the
right hand side, a list of constructors separated by <code>|</code> that help us create the type.
Note that the <code>Fraction</code> on the right hand side is the name of
the constructor of the type; it in fact can be distinct from the name of
the type itself (which is very helpful when you have more than one
constructor). As you can see, to construct a <code>Fraction</code> (the type), the
<code>Fraction</code> <em>constructor</em> receives two <code>Int</code>s, one
numerator, and one denominator.</p>
<p>Then, defining the student type from our algebraic formulation above
should also be straightforward:</p>
<pre><code class="language-haskell">data Student = S String Int

bob :: Student
bob = S "Bob" 123
</code></pre>
<p>Let us define the <code>Bool</code> type, which should have two constructors, each
constructor not having any fields:</p>
<pre><code class="language-haskell">data Bool = True | False

true, false :: Bool
true = True
false = False
</code></pre>
<p>To construct a <code>Bool</code> we can use either the <code>True</code>
constructor or the <code>False</code> constructor. Neither of these
constructors receive any other fields.</p>
<p>We can also have multiple constructors that are products of more than
zero types, as we shall see in the algebraic formulation of a
<code>String</code>:</p>
<pre><code class="language-haskell">data String = EmptyString | Node Char String

hello, empty :: String
hello = Node 'h' (Node 'e' (Node 'l' (Node 'l' (Node 'o' EmptyString))))
empty = EmptyString
</code></pre>
<h2 id="polymorphic-algebraic-data-types"><a class="header" href="#polymorphic-algebraic-data-types">Polymorphic Algebraic Data Types</a></h2>
<p>Now we show examples of creating our own polymorphic data types. The way
we would do so is similar to how we defined generic/polymorphic classes
in Python.</p>
<p>Let us start from the bottom again by creating specialized versions of a
box type, this time in Haskell. We start by assuming that a box contains
an <code>Int</code>:</p>
<pre><code class="language-haskell">data IntBox = IB Int
b :: IntBox
b = IB 1
</code></pre>
<p>Then define a box that contains a <code>String</code>:</p>
<pre><code class="language-haskell">data StrBox = SB String
b :: StrBox
b = SB "123"
</code></pre>
<p>Again, they look more or less the same, except for the type of the
field. As such, we should allow <code>Box</code> to be polymorphic by
introducing a type parameter:</p>
<pre><code class="language-haskell">data Box a = B a
x :: Box Int
x = B 1
y :: Box String
y = B "123"
</code></pre>
<p>Perfect! Let us try more complex polymorphic algebraic data types like
linked lists and trees:</p>
<pre><code class="language-haskell">data LinkedList a = EmptyList | Node a (LinkedList a)
cat :: LinkedList Char
cat = Node 'c' (Node 'a' (Node 't' EmptyList))

data Tree a = Leaf a | TreeNode (Tree a) a (Tree a)
tree :: Tree Int
tree = TreeNode (Leaf 1) 2 (Leaf 3)
</code></pre>
<p>Constructors are actually functions!</p>
<pre><code class="language-haskell">ghci&gt; data Fraction = F Int Int
ghci&gt; :t F
F :: Int -&gt; Int -&gt; Fraction
ghci&gt; :t F 1
F 1 :: Int -&gt; Fraction
ghci&gt; :t F 1 2
F 1 2 :: Fraction
</code></pre>
<p>We now have the facilities to define and construct data types and their
terms, but so far we are not able to <em>access</em> the fields of a data type
in Haskell. Unlike Python, we are not able to do something like
<code>x.numerator</code> to obtain the numerator of a fraction <code>x</code>, for example.
There are ways to define functions that do so and we will show them to
you in later sections, but for now, Haskell has <em>record syntax</em> that
automatically defines these accessor functions for us.</p>
<p>Let us re-create the <code>Student</code> type, this time using record
syntax to automatically derive functions that obtain their names and
IDs:</p>
<pre><code class="language-haskell">data Student = S { name :: String, id :: Int }
</code></pre>
<p>With this, we no longer need to define our own functions that access
these fields for us. Record syntax is great for giving names to fields!
Importantly, record syntax is nothing special, and we can continue to
create terms of those types by way of usual constructor application.</p>
<pre><code class="language-haskell">x, y :: Student
x = S { name = "Alice", id = 123 }
y = S "Bob" 456
</code></pre>
<p>Let's try loading this into GHCI and see the accessor functions in
action:</p>
<pre><code class="language-haskell">ghci&gt; name x
"Alice"
ghci&gt; id y
456
</code></pre>
<p>You can also make use of record syntax to express record updates. For example,
we can update Alice to have the ID of 456 like so:</p>
<pre><code class="language-haskell">ghci&gt; id x
123
ghci&gt; z = x { id = 456 }
ghci&gt; name z
"Alice"
ghci&gt; id z
456
</code></pre>
<p>Of course, the original term was not actually <em>updated</em> since everything is immutable in Haskell—<code>x { id = 456 }</code> simply constructs a new term that contains the same values for all its fields, except where the <code>id</code> field now takes the value <code>456</code>.</p>
<p>We can even mix and match these different forms of constructor
definitions, or create large data structures!</p>
<pre><code class="language-haskell">data Department = D {name' :: String, courses :: [Course]}
data Course = C { code :: String, 
                  credits :: Int,
                  students :: [Student] }
data Student = UG { homeFac :: String,
                    name :: String,
                    id :: Int }
             | PG [String] String Int

alice   = UG "SoC" "Alice" 123
bob     = PG ["SoC", "YLLSoM"] "Bob" 456
it5100a = C "IT5100A" 2 [alice]
it5100b = C "IT5100B" 2 [alice, bob]
cs      = D "Computer Science" [it5100a, it5100b]
</code></pre>
<h2 id="more-on-polymorphism"><a class="header" href="#more-on-polymorphism">More on Polymorphism</a></h2>
<p>Now that we have shown how to create our own algebraic data types in
Haskell (and polymorphic ones), we step aside and give a mental model
for understanding polymorphism. Recall that we have described
polymorphic functions and types as functions/types that
quantifies/parameterizes types; in other words, they receive a type as a
parameter.</p>
<p>Recall in the lambda calculus that \(\lambda\) creates a function over a
parameter. Assuming the parameter has type \(S\) and the returned value
has type \(T\), we get:</p>
<p>$$\lambda x.e: S \to T$$</p>
<p>and when we call or apply
this function, we are substituting the parameter for the argument of the
function application:
$$(\lambda x.e_1)e_2 \equiv_\beta e_1[x:=e_2]$$</p>
<p>$$\begin{aligned}
(\lambda x: \mathtt{Int}.x + 4)3 &amp;\equiv_\beta (x + 4)[x := 3]\\
&amp;\equiv_\beta (3 + 4)\\
&amp; \equiv_\beta 7
\end{aligned}$$ In Haskell (the expression in parentheses is a lambda
expression):</p>
<pre><code class="language-haskell">ghci&gt; (\x -&gt; x + 4) 3
7
</code></pre>
<p>A typed variant of the lambda calculus known as System \(F\) has
polymorphic functions, which are functions that also receive a type
parameter. We can then apply this function onto a type <em>argument</em> to get
a specialized version of that function. Such type parameters are bound
by \(\Lambda\). As an example, if we have a term \(e\) of type \(T\), we get:</p>
<p>$$\Lambda \alpha.e: \forall\alpha.T$$
Calling or applying this function with a type argument, once again, substitutes the type parameter with the type argument:</p>
<p>$$(\Lambda\alpha.e)\ \tau\equiv_\beta e[\alpha := \tau]$$
$$(\Lambda\alpha.e)\ \tau : T[\alpha := \tau]$$</p>
<p>$$\begin{aligned}
(\Lambda \alpha.\lambda x:\alpha.[x]) \mathtt{Int} &amp;\equiv_\beta (\lambda x:\alpha.[x])[\alpha := \mathtt{Int}]\\
&amp; \equiv_\beta \lambda x:\mathtt{Int}.[x]
\end{aligned}$$</p>
<p>We can show this with an example in Haskell. Explicit type arguments
must be enabled with a language extension and the type arguments must be
prefixed by <code>@</code>:</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications -fprint-explicit-foralls
ghci&gt; :{
ghci| f :: forall a. a -&gt; [a]
ghci| f x = [x]
ghci| :}

ghci&gt; :t f
f :: forall a. a -&gt; [a]

ghci&gt; :t f @Int
f @Int :: Int -&gt; [Int]

ghci&gt; f @Int 1
[1]
</code></pre>
<p>On the other hand, polymorphic types can be seen as <em>functions at the
type-level</em>. These are "functions" that receive types and return types!
For example, we can define a <code>Pair</code> type that is polymorphic
in its component types. Thus, the <code>Pair</code> type itself (not its
constructor!) receives two types, and returns the resulting
<code>Pair</code> type specialized to those component types. This makes
<code>Pair</code> what is known as a <em>type constructor</em>.</p>
<p>To observe this fact, know that types are to terms as <em>kinds</em> are to
types: they describe what <em>kind</em> of type a type is. The usual types that
we encounter <code>Int</code>, <code>[[Char]]</code> etc. have kind
<code>*</code>, and type constructors or "type-level functions" have
kind <code>* -&gt; *</code> for example. Below, we show that
<code>Pair</code> is a type constructor of kind <code>* -&gt; * -&gt; *</code>,
which makes sense since it receives two types and returns the
specialized type of the <code>Pair</code>:</p>
<pre><code class="language-haskell">ghci&gt; data Pair a b = P a b
ghci&gt; :k Pair
Pair :: * -&gt; * -&gt; *
ghci&gt; :k Pair Int
Pair Int :: * -&gt; *
ghci&gt; :k Pair Int String
Pair Int String :: *
</code></pre>
<p>We know that we can have higher-order functions, for example, the type
of <code>map</code> might be something like
<code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>. Can we have higher-order type
constructors? Yes! These are known as <em>higher kinds</em> or <em>higher-kinded
types</em>. These types receive <em>type constructors</em> as type arguments. Let
us construct a higher-kinded type that receives a type constructor and
applies it onto a type:</p>
<pre><code class="language-haskell">ghci&gt; data Crazy f a = C (f a)
</code></pre>
<p>Upon visual inspection we can see that <code>f</code> must be a type constructor,
because the constructor <code>C</code> receives a term of type <code>f a</code>!
What's crazier is, when inspecting the kind of <code>Crazy</code>, we see
that it exhibits <em>kind polymorphism</em>:</p>
<pre><code class="language-haskell">ghci&gt; :set -fprint-explicit-foralls
ghci&gt; :k Crazy
Crazy :: forall {k}. (k -&gt; *) -&gt; k -&gt; *
</code></pre>
<p>To give you an example of how this might work, because we know we can
construct lists of any type, <code>[]</code> (the type, not the empty
list) must be a type constructor. We can thus pass the <code>[]</code>
type constructor into <code>Crazy</code>:</p>
<pre><code class="language-haskell">ghci&gt; :k Crazy []
Crazy [] :: * -&gt; *
ghci&gt; :k Crazy [] Int
Crazy [] Int :: *
</code></pre>
<p>How might this work? We see that <code>Crazy [] Int</code> has kind <code>*</code>,
so we should be able to construct a term of this type. We can do so by
using the <code>C</code> constructor defined above! To be clear, let's
see the specialized version of the constructor with the type arguments
entered:</p>
<pre><code class="language-haskell">ghci&gt; :t C @[] @Int
C @[] @Int :: [Int] -&gt; Crazy [] Int
</code></pre>
<p>As we can see, to construct a term of this type, we just need to pass in
a list of integers to <code>C</code>:</p>
<pre><code class="language-haskell">ghci&gt; x :: Crazy [] Int = C [1]
</code></pre>
<p>We can in fact instantiate other crazy types with different type
constructors:</p>
<pre><code class="language-haskell">ghci&gt; data Box a = B a
ghci&gt; y :: Crazy Box Int = C (B 2)
</code></pre>
<p>The utility of higher-kinded types may not be apparent to you now; later
on we might see some of them in action!</p>
<p>Although this might confuse you so far, what we have demonstrated merely
serves to demonstrate the idea that parametric polymorphism can be
thought of the phenomenon where something (type or term) can receive a
type and give you a type or term, just as we have stated at the
beginning of <a href="types/sections/./polymorphism.html">Chapter 2.2 (Polymorphism)</a>.</p>
<h2 id="other-polymorphisms"><a class="header" href="#other-polymorphisms">Other Polymorphisms</a></h2>
<p>At the start of <a href="types/sections/./polymorphism.html">Chapter 2.2 (Polymorphism)</a> we introduced three questions, two of
which have been answered. Let us restate the final question and pose one
more:</p>
<ol>
<li>
<p>Can types depend on terms?</p>
</li>
<li>
<p>Are there other kinds of polymorphism?</p>
</li>
</ol>
<p>The answers to both questions is yes. Types that depend on terms are
known as <em>dependent types</em>, which we shall not cover in this course.
There are also other kinds of polymorphisms, some of which you have
already dealt with. Subtype polymorphism is used frequently in OOP,
since subclasses are types that are <em>subtypes</em> of their superclasses. An
umbrella term <em>ad-hoc polymorphism</em> generally refers to <em>overloading</em>,
which we shall discuss in the future. There are also more kinds of
polymorphisms, but we shall not discuss them in this course.</p>
<p>Python (and several other mainstream languages) is quite special, being
a multi-paradigm language means that several forms of polymorphism are
applicable to it. In particular, we have seen that Python supports
parametric polymorphism, and since Python supports OOP, it also has
subtype polymorphism. Despite Python not having algebraic data types
(yet), we may also formulate our types to behave similarly to Algebraic
Data Types. Two formulations we may attempt are: 1) with types as unions
and constructors as classes, 2) with types as classes and constructors
as their subclasses. Below we present both formulations for the linked
list type:</p>
<pre><code class="language-python"># (1)
type List[a] = Node[a] | Empty

@dataclass
class Empty:
    pass

@dataclass
class Node[a]:
    head: a
    tail: List[a]

x: List[int] = Node(1, Node(2, Empty()))
</code></pre>
<pre><code class="language-python"># (2)
from typing import Any
@dataclass
class List[a]:
    pass

@dataclass
class Empty(List[Any]):
    pass

@dataclass
class Node[a](List[a]):
    head: a
    tail: List[a]

x: List[int] = Node(1, Node(2, Empty()))
</code></pre>
<p>There are some differences between the two formulations, and between
these with Haskell's Algebraic Data Types. Most importantly, in Haskell,
data types are types, but constructors are not. This is unlike Python,
where all classes are types. That means a variable of type
<code>Node[int]</code> is valid in Python, but a variable of type
<code>Node Int</code> is not in Haskell.</p>
<h2 id="generalized-algebraic-data-types"><a class="header" href="#generalized-algebraic-data-types">Generalized Algebraic Data Types</a></h2>
<p>However, something interesting is going on here. In the second
formulation, a <code>Node[a]</code> is a <code>List[a]</code>, which makes sense. On
the other hand, an <code>Empty</code> can be typed as <code>List[Any]</code>, because an empty
list fits all kinds of lists. An interesting observation you might see
is that the supertype of our "constructors" need not strictly be
<code>List[a]</code>, it could be any kind of list!</p>
<p>Consider the following example of defining simple expressions in a programming
language, which is defined polymorphically using OOP:</p>
<pre><code class="language-python">class Expr[a]:
    def eval(self) -&gt; a:
        raise Exception
</code></pre>
<p>The <code>Expr</code> class is parameterized by the type of its evaluation. From
this class we may now create subclasses of <code>Expr</code>. For example, some
simple numeric expressions.</p>
<pre><code class="language-python">@dataclass
class LitNumExpr(Expr[int]):
    n: int
    def eval(self) -&gt; int:
        return self.n

@dataclass
class AddExpr(Expr[int]):
    lhs: Expr[int]
    rhs: Expr[int]
    def eval(self) -&gt; int:
        return self.lhs.eval() + self.rhs.eval()
</code></pre>
<p>We can then create other kinds of expressions. For example, an equality
expression that returns booleans:</p>
<pre><code class="language-python">@dataclass
class EqExpr[a](Expr[bool]):
    lhs: Expr[a]
    rhs: Expr[a]
    def eval(self) -&gt; bool:
        return self.lhs.eval() == self.rhs.eval()
</code></pre>
<p>Or even a conditional expression whose evaluated type is parameterized:</p>
<pre><code class="language-python">@dataclass
class CondExpr[a](Expr[a]):
    cond: Expr[bool]
    true: Expr[a]
    false: Expr[a]
    def eval(self) -&gt; a:
        return self.true.eval() if self.cond.eval() else self.false.eval()
</code></pre>
<p>Let's try this out! Suppose we would like to evaluate the following
expression:</p>
<pre><code>if 1 == 2 then 1 + 1 else 0
</code></pre>
<p>Let's write this in the program using our classes and evaluate it!</p>
<pre><code class="language-python">zero: Expr[int] = LitNumExpr(0)
one: Expr[int] = LitNumExpr(1)
two: Expr[int] = LitNumExpr(2)
one_plus_one: Expr[int] = AddExpr(one, one)
one_eq_two: Expr[bool] = EqExpr(one, two)
cond: Expr[int] = CondExpr(one_eq_two, one_plus_one, zero)
print(cond.eval()) # 0
</code></pre>
<p>How do we create such an algebraic data type in Haskell? For this, we
have to use <em>Generalized Algebraic Data Types</em> (GADTs). Loosely, these
are algebraic data types like before, except that each constructor can
decide what type it returns!</p>
<p>First, let us formulate our original algebraic data types using GADT
syntax.</p>
<pre><code class="language-haskell">data LinkedList a where
    EmptyList :: LinkedList a -- this is a different a!
    Node :: b -&gt; LinkedList b -&gt; LinkedList b
</code></pre>
<p>Now let us take it a step further, and truly customize the constructors
of an <code>Expr</code> GADT:</p>
<pre><code class="language-haskell">data Expr a where
    LitNumExpr :: Int -&gt; Expr Int
    AddExpr    :: Expr Int -&gt; Expr Int -&gt; Expr Int
    EqExpr     :: Expr a -&gt; Expr a -&gt; Expr Bool
    CondExpr   :: Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Pretty neat huh! There are many uses of GADTs, and we might see them in
the future. In the next section, we will show you how we can write
functions against algebraic data types and GADTs, including how we can
implement the <code>eval</code> function.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>We have seen how we can write constructors for algebraic data types, and
even use record syntax to create functions for accessing fields.
However, one natural question would then be to ask, how do we write
functions that access these fields, if we do not use record syntax? For
example, if we defined a fraction type normally, how do we obtain a
fraction's numerator and denominator?</p>
<p>The answer to this question is to use <em>pattern matching</em>. It is a
control structure just like <code>if</code>-<code>then</code>-<code>else</code> expressions, except that we would
execute different branches based on the <em>value/structure</em> of the data,
instead of a general condition.</p>
<p>Let us define the <code>factorial</code> function using pattern matching instead of
conditional expressions or guards. We use <code>case</code> expressions
to do so:</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac n = case n of -- match n against these patterns:
    0 -&gt; 1
    x -&gt; x * fac (x - 1) -- any other Int
</code></pre>
<p>The nice thing about pattern matching is that we can also match against
the <em>structure</em> of data, i.e. to match against constructors.
Let us redefine the <code>fst</code> and <code>snd</code> functions which project
a pair into its components:</p>
<pre><code class="language-haskell">fst' :: (a, b) -&gt; a
fst' p = case p of 
    (x, _) -&gt; x

snd' :: (a, b) -&gt; b
snd' p = case p of
    (_, y) -&gt; y
</code></pre>
<p>Let us also write accessor functions to access the numerator and denominator of a
fraction.</p>
<pre><code class="language-haskell">data Fraction = F Int Int
numerator, denominator :: Fraction -&gt; Int
numerator f = case f of
    F x _ -&gt; x
denominator f = case f of 
    F _ x -&gt; x
</code></pre>
<p>One nice thing about Haskell is that because we perform pattern matching
over the arguments of functions so frequently, we can actually bring the
patterns up to the definitions of the functions themselves. Let us define all the functions we've just written using
<code>case</code> expressions into more idiomatic uses of pattern matching.</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac 0 = 1
fac n = n * fac (n - 1)
 
fst' :: (a, b) -&gt; a
fst' (x, _) = x

snd' :: (a, b) -&gt; b
snd' (_, y) = y
 
data Fraction = F Int Int
numerator, denominator :: Fraction -&gt; Int

numerator (F x _) = x
denominator (F _ y) = y
</code></pre>
<p>We also know that the list type is a singly linked list, which is
roughly defined as such:</p>
<pre><code class="language-haskell">data [a] = [] | a : [a]
</code></pre>
<p>We can use this fact to pattern match against lists! For instance, the sum of a list of integers is 0 if the list is empty, otherwise its
the head of the list plus the sum of the tail of the list.</p>
<pre><code class="language-haskell">sum' :: [Int] -&gt; Int
sum' [] = 0
sum' (x : xs) = x + sum' xs
</code></pre>
<p>Similarly, the length of a list is 0 if the list is empty, otherwise it is 1 more
than the length of its tail.</p>
<pre><code class="language-haskell">len :: [a] -&gt; Int
len [] = 0
len (_ : xs) = 1 + len xs
</code></pre>
<p>Really neat! Defining functions operating on algebraic data types
(including recursive data types) are very convenient thanks to pattern
matching! What's more, patterns can actually be used virtually anywhere
on the left side of any binding:</p>
<p>Let us use pattern matching in a <code>let</code> binding:</p>
<pre><code class="language-haskell">len :: [a] -&gt; Int
len [] = 0
len ls = 
    let (_ : xs) = ls
    in  1 + len xs
</code></pre>
<p>Perhaps the most powerful feature of pattern matching is that the
compiler will warn you if your pattern matches are non-exhaustive, i.e.
if you do not match against all possible constructors of the type! Let
us define a function that only matches against the empty list
constructor.</p>
<pre><code class="language-haskell">-- Main.hs
emp :: [a] -&gt; [a]
emp [] = []
</code></pre>
<p>Compile it to see the warning!</p>
<pre><code>ghc Main.hs
</code></pre>
<pre><code class="language-output warn">Main.hs:3:1: warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for 'emp': Patterns of type '[a]' not matched: (_:_)
  |
3 | emp [] = []
  | ^^^^^^^^^^^
</code></pre>
<p>This is one reason why pattern matching is so powerful: compilers can
check if you have covered all possible patterns of a given type. This is
unlike the usual <code>if</code>-<code>else</code> statements in other languages where it is much less straightforward to
check if you have covered all possible branches, especially if you omit
<code>else</code> statements.</p>
<p>One important point to highlight here is that pattern matching is done
top-down. Pattern-matching is kind of similar to <code>if</code>-<code>else</code>
statements in that regard: your most specific condition should be
defined first, then followed by more general or catch-all patterns.</p>
<p>The following factorial function is poorly defined, because the first
pattern match will match all possible integers, thereby causing the
function to never terminate:</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac n = n * fac (n - 1)
fac 0 = 1 -- redundant as pattern above matches all possible integers
</code></pre>
<p>With pattern matching, let us know fulfil our earlier promise of
defining the <code>eval</code> function for the <code>Expr</code> GADT in
<a href="types/sections/./algebraic_data_types.html">Chapter 2.3 (Algebraic Data Types)</a>. In our Python formulation, we know that <code>eval</code> should have the
type signature <code>Expr a -&gt; a</code>. Let us then define how each
expression should be evaluated with pattern matching.</p>
<pre><code class="language-haskell">-- Main.hs
eval :: Expr a -&gt; a
eval (LitNumExpr n)   = n
eval (AddExpr a b)    = eval a + eval b
eval (EqExpr a b)     = eval a == eval b
eval (CondExpr a b c) = if eval a then eval b else eval c
</code></pre>
<p>This seems straightforward. However, you might find that when this
program is compiled, the compiler throws an error on the use of the
<code>(==)</code> function:</p>
<pre><code>ghc Main.hs
</code></pre>
<pre><code class="language-output error">Main.hs:13:28: error:
    • Could not deduce (Eq a1) arising from a use of ‘==’
      from the context: a ~ Bool
        bound by a pattern with constructor:
                   EqExpr :: forall a. Expr a -&gt; Expr a -&gt; Expr Bool,
                 in an equation for ‘eval’
        at app/Main.hs:13:7-16
      Possible fix:
        add (Eq a1) to the context of the data constructor ‘EqExpr’
    • In the expression: eval a == eval b
      In an equation for ‘eval’: eval (EqExpr a b) = eval a == eval b
   |
13 | eval (EqExpr a b) = eval a == eval b
   |       
</code></pre>
<p>The reason for this is Haskell is unable to determine that the type
parameter <code>a</code> is amenable to equality comparisons. Solving this requires
an understanding of <em>typeclasses</em>, which we will explore in the next
chapter. For now, just include an <code>Eq a =&gt;</code> constraint in our
GADT declaration.</p>
<p>You might also get a warning about pattern matching on GADTs being
fragile; that is because GADTs are actually a Haskell language
extension. As such, enable this extension when compiling this program,
or add a <code>LANGUAGE</code> <em>pragma</em> at the top of the file.</p>
<pre><code class="language-haskell">{-# LANGUAGE GADTs #-}
data Expr a where
  LitNumExpr ::         Int -&gt; Expr Int
  AddExpr    ::         Expr Int -&gt; Expr Int -&gt; Expr Int
  EqExpr     :: Eq a =&gt; Expr a -&gt; Expr a -&gt; Expr Bool
  CondExpr   ::         Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Our program should compile now!</p>
<h3 id="pattern-matching-in-python"><a class="header" href="#pattern-matching-in-python">Pattern Matching in Python</a></h3>
<p>Python also has pattern matching with <code>match</code> statements with
<code>case</code> clauses! It looks very similar to how we would write
<code>case</code> expressions in Haskell.</p>
<pre><code class="language-python">def factorial(n: int) -&gt; int:
  match n:
    case 0: return 1
    case n: return n * factorial(n - 1)
</code></pre>
<p>We can also match on the structure of types by unpacking. For example,
defining a function that sums over a list of integers:</p>
<pre><code class="language-python">def sum(ls: list[int]) -&gt; int:
  match ls:
    case []: return 0
    case (x, *xs): return x + sum(xs)
    case _: raise TypeError()
</code></pre>
<p>Alternatively, performing structural pattern matching over a so called
algebraic data type:</p>
<pre><code class="language-python">@dataclass
class Tree[a]: pass
 
@dataclass
class Node[a](Tree[a]):
    val: a
    left: Tree[a]
    right: Tree[a]
 
@dataclass
class Leaf[a](Tree[a]):
    val: a

def preorder[a](tree: Tree[a]) -&gt; list[a]:
    match tree:
        case Node(v, l, r): return [v] + preorder(l) + preorder(r)
        case Leaf(v): return [v]
        case _: raise TypeError
</code></pre>
<p>However, notice that in the <code>sum</code> and <code>preorder</code> function definitions,
the last clause catches all patterns and raises an error. This is needed
to side-step the exhaustiveness checker. This is because we are using
classes to model algebraic data types, and Python does not always know
all the possible structures of a given class. In the case of <code>sum</code>,
Python's type system does not contain information about the length of a
list, so it has no way of determining exhaustiveness. In the case of
<code>preorder</code>, the reason omitting the last case gives a non-exhaustiveness
error is because we did not match against other possible subclasses of
<code>Tree</code>.</p>
<p>If we had formulated our <code>Tree</code> type using unions, <code>pyright</code> can determine
the exhaustiveness of our patterns:</p>
<pre><code class="language-python">type Tree[a] = Node[a] | Leaf[a]

@dataclass
class Node[a]:
    val: a
    left: Tree[a]
    right: Tree[a]

@dataclass
class Leaf[a]:
    val: a

def preorder[a](tree: Tree[a]) -&gt; list[a]:
    match tree:
        case Node(v, l, r): return [v] + preorder(l) + preorder(r)
        case Leaf(v): return [v]
        # no need for further cases
</code></pre>
<p>However, this may not always be ideal, especially if we are to define
GADTs in Python. Until Algebraic Data Types or ways to annotate the
exhaustivity of subclasses (such as defining a <em>sealed</em> class) are
formally introduced, exhaustive pattern matching checks are going to be
difficult to do. When doing pattern matching in Python, ensure that all
possible cases are handled before doing a catch-all clause in your
<code>match</code> statement.</p>
<p>All-in-all, we have just introduced a new control structure known as
pattern matching. When should we use this control structure? The general
rule of thumb is as follows:</p>
<ul>
<li>
<p>If you are doing different things based on the value and/or
structure of data, use pattern matching. You can tell this is the
case if you are doing equality and <code>isinstance</code> checks in
your conditional statements in Python.</p>
</li>
<li>
<p>Otherwise, you are likely going with the more general case of doing
different things based on the satisfiability of a condition, in
which case, rely on <code>if</code>-<code>else</code> statements, or in Haskell, conditional
expressions and/or guards.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h1>
<h2 id="question-1-1"><a class="header" href="#question-1-1">Question 1</a></h2>
<p>Without using GHCI, determine the types of the following expressions:</p>
<ol>
<li><code>(1 :: Int) + 2 * 3</code></li>
<li><code>let x = 2 + 3 in show x</code></li>
<li><code>if "ab" == "abc" then "a" else []</code></li>
<li><code>(++ [])</code></li>
<li><code>map (\(x :: Int) -&gt; x * 2)</code></li>
<li><code>((\(x :: [Int]) -&gt; show x) . )</code></li>
<li><code>( . (\(x :: [Int]) -&gt; show x))</code></li>
<li><code>(,) . fst</code></li>
<li><code>filter</code></li>
</ol>
<h2 id="question-2-1"><a class="header" href="#question-2-1">Question 2</a></h2>
<p>Without the help of GHCI, describe the types of <code>eqLast</code>, <code>isPalindrome</code>, <code>burgerPrice</code> and <code>(@:)</code> which we defined in <a href="types/sections/../../course_introduction/sections/exercises.html">Chapter 1.4 (Course Introduction#Exercises)</a></p>
<h2 id="question-3-1"><a class="header" href="#question-3-1">Question 3</a></h2>
<p>Recall the following definition of <code>burgerPrice</code>:</p>
<pre><code class="language-haskell">burgerPrice burger 
  | null burger = 0
  | otherwise   =
      let first = ingredientPrice (head burger)
          rest  = burgerPrice (tail burger)
      in  first + rest
  where ingredientPrice i
          | i == 'B' = 0.5
          | i == 'C' = 0.8
          | i == 'P' = 1.5
          | i == 'V' = 0.7
          | i == 'O' = 0.4
          | i == 'M' = 0.9
</code></pre>
<p>There are several problems with this. First of all, writing
<code>burgerPrice</code> with guards does not allow us to rely on
compiler exhaustiveness checks, and may give us some additional warnings
about <code>head</code> and <code>tail</code> being <em>partial</em>, despite their use being
perfectly fine. The second problem is that we have allowed our burger to
be any string, even though we should only allow strings that are
composed of valid ingredients—the compiler will not reject invocations of
<code>burgerPrice</code> with bogus arguments like <code>"AbcDEF"</code>.</p>
<p>Define a new type that represents valid burgers, and re-define
<code>burgerPrice</code> against that type using pattern matching.
Additionally, provide a type declaration for this function. Note that
you may use the <code>Rational</code> type to describe rational numbers
like <code>0.8</code> etc, instead of <code>Double</code> which may have
precision issues. You might see that the output of your
<code>burgerPrice</code> function is of the form <code>x % y</code> which means
\(x/y\).</p>
<h2 id="question-4-1"><a class="header" href="#question-4-1">Question 4</a></h2>
<p>Define a function <code>dropConsecutiveDuplicates</code> that receives a
list of any type that is amenable to equality comparisons and removes
all the consecutive duplicates of the list. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; dropConsecutiveDuplicates []
[]
ghci&gt; dropConsecutiveDuplicates [1, 2, 2, 3, 3, 3, 3, 4, 4]
[1, 2, 3, 4]
ghci&gt; dropConsecutiveDuplicates "aabcccddeee"
"abcde"
</code></pre>
<p>For this function to be polymorphic, you will need to add a constraint
<code>Eq a =&gt;</code> at the beginning of the function's type signature
just like we did for the <code>EqExpr</code> constructor of our
<code>Expr a</code> GADT.</p>
<h2 id="question-5-1"><a class="header" href="#question-5-1">Question 5</a></h2>
<p>Suppose we have a list <code>[1,2,3,4,5]</code>. Since lists in Haskell are singly-linked lists,
and not to mention that Haskell lists are immutable, changing the values
at the tail end of the list (e.g. <code>4</code> or <code>5</code>) can be inefficient! Not
only that, if we want to then change something near the element we've
just changed, we have to traverse all the way down to that element from
the head all over again!</p>
<p>Instead, what we can use is a <em>zipper</em>, which allows us to focus on a
part of a data structure so that accessing those elements and walking
around it is efficient. The idea is to write functions that let us walk
down the list, do our changes, and walk back up to recover the full
list. For this, we shall define some functions:</p>
<ol>
<li><code>mkZipper</code> which receives a list and makes a zipper</li>
<li><code>r</code> which walks to the right of the list zipper</li>
<li><code>l</code> which walks to the left of the list zipper</li>
<li><code>setElement x</code> which changes the element at the current position of
the zipper to <code>x</code>.</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; x = mkZipper [1,2,3,4,5]
ghci&gt; x
([], [1,2,3,4,5])
ghci&gt; y = r $ r $ r $ r x
ghci&gt; y = ([4,3,2,1], [5])
ghci&gt; z = setElement (-1) y
ghci&gt; z
([4,3,2,1], [-1])
ghci&gt; w = setElement (-2) $ l z
ghci&gt; w 
([3,2,1], [-2,-1])
ghci&gt; l $ l $ l w
([], [1,2,3,-2,-1])
</code></pre>
<h2 id="question-6-1"><a class="header" href="#question-6-1">Question 6</a></h2>
<p>Let us create a data structure that represents
sorted sets. These are collections that contain unique elements and are
sorted in ascending order. A natural data structure that can represent
such sets is the Binary Search Tree (BST) abstract data type (ADT).</p>
<p>Create a new type <code>SortedSet</code>. Then define the following
functions:</p>
<ol>
<li>The function <code>@+</code> that receives a sorted set and an element, and
returns the sorted set with the element added (unless it is already
in the sorted set).</li>
<li>The function <code>setToList</code> that receives a sorted set and returns it
as a list (in sorted order)</li>
<li>The function <code>sortedSet</code> that receives a list of elements and puts
them all in a sorted set.</li>
<li>The function <code>in'</code> which determines if an element is in the sorted
set.</li>
</ol>
<p>Note that if any of your functions perform any comparison operations
(<code>&gt;</code> etc.), you will need to include the <code>Ord a =&gt;</code> constraint
over the elements of the sorted set or list at the beginning of the type
signature of those functions. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; setToList $ (sortedSet []) @+ 1
[1]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2
[1,2]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2 @+ 0
[0,1,2]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2 @+ 0 @+ 2
[0,1,2]
ghci&gt; setToList $ sortedSet [7,3,2,5,5,2,1,7,6,3,4,2,4,4,7,1,2,3]
[1,2,3,4,5,6,7]
ghci&gt; setToList $ sortedSet "aaabccccbbbbbaaaaab"
"abc"
ghci&gt; 1 `in'` (sortedSet [1, 2, 3])
True
ghci&gt; 1 `in'` (sortedSet [4])
False
</code></pre>
<h2 id="question-7-1"><a class="header" href="#question-7-1">Question 7</a></h2>
<p>In this question, we are going to demonstrate an example of the <em>expression
problem</em> by writing FP-style data structures and functions, and OO-style
classes, to represent the same problem. We shall use Haskell for the FP
formulation, and Python for the OOP formulation. Ensure that your Python
code is well-typed by checking it with <code>pyright</code>.</p>
<p>The problem is as such. We want to represent various shapes, and the
facility to calculate the area of a shape. To start, we shall define two
shapes: circles and rectangles. Circles have a radius and rectangles
have a width and height. Assume these fields are all <code>Double</code>s
in Haskell, and <code>float</code>s in Python.</p>
<ul>
<li>
<p>Haskell: define a type <code>Shape</code> that represents these two
shapes, and a function <code>area</code> that computes the area of any
shape.</p>
</li>
<li>
<p>Python: define a (abstract) class <code>Shape</code> that comes with a (abstract)
method <code>area</code> which gives its area. Then, define two subclasses of
<code>Shape</code> that represents circles and rectangles, and define their
constructors and methods appropriately.</p>
</li>
</ul>
<p>The <em>expression problem</em> essentially describes the phenomenon that it
can either be easy to add new representations of a type or easy to add new
functions over types, but not both. To observe this, we are going to
extend the code we've written in the following ways:</p>
<ol>
<li>
<p>Create a new shape called <code>Triangle</code> that has a width and height.</p>
</li>
<li>
<p>Create a new function/method <code>scale</code> that scales the shape (by
length) by some factor \(n\).</p>
</li>
</ol>
<p>Proceed to do so in both formulations. As you are doing so, think about
whether each extension is easy to do if the code we've previously
written cannot be amended, e.g. if it is in a pre-compiled library which
you do not have the source code of.</p>
<h2 id="question-8"><a class="header" href="#question-8">Question 8</a></h2>
<p>Let us extend our Expressions GADT.
Define the following expressions:</p>
<ol>
<li><code>LitBoolExpr</code> holds a boolean value (<code>True</code> or
<code>False</code>)</li>
<li><code>AndExpr</code> has two boolean expressions and evaluates to
their conjunction</li>
<li><code>OrExpr</code> has two boolean expressions and evaluates to
their disjunction</li>
<li><code>FuncExpr</code> holds a function</li>
<li><code>FuncCall</code> receives a function and an argument, and
evaluates to the function application to that argument</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; n = LitNumExpr
ghci&gt; b = LitBoolExpr
ghci&gt; a = AndExpr
ghci&gt; o = OrExpr
ghci&gt; f = FuncExpr
ghci&gt; c = FuncCall
ghci&gt; eval (b True `a` b False)
False
ghci&gt; eval (b True `a` b True)
True
ghci&gt; eval (b True `o` b False)
True
ghci&gt; eval (b False `o` b False)
False
ghci&gt; eval $ f (\x -&gt; x + 1) `c` n 1
2
ghci&gt; eval $ c (c (f (\x y -&gt; x + y)) (n 1)) (n 2)
3
</code></pre>
<h2 id="question-9"><a class="header" href="#question-9">Question 9</a></h2>
<p>In this question we shall
simulate a simple banking system consisting of bank accounts. We shall
write all this code in <strong>Python</strong>, but in a typed functional programming
style. That means:</p>
<ol>
<li>No loops</li>
<li>No mutable data structures or variables</li>
<li>Pure functions only</li>
<li>Annotate all variables, functions etc. with types</li>
<li>Program must be type-safe</li>
</ol>
<p>There are several kinds of bank accounts that behave differently on
certain operations. We aim to build a banking system that receives such
operations that act on these accounts. We shall build this system
incrementally (as we should!), so you may want to follow the parts in
order, and check your solutions after completing each part.</p>
<h3 id="bank-accounts"><a class="header" href="#bank-accounts">Bank Accounts</a></h3>
<h4 id="bank-account-adt"><a class="header" href="#bank-account-adt">Bank Account ADT</a></h4>
<p>First, create an Algebraic Data Type (ADT) called <code>BankAccount</code>
that represents two kinds of bank accounts:</p>
<ol>
<li>Normal bank accounts</li>
<li>Minimal bank accounts</li>
</ol>
<p>Both kinds of accounts have an ID, account balance and an interest
rate.</p>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; NormalAccount("a", 1000, 0.01)
NormalAccount(account_id='a', balance=1000, interest_rate=0.01)
&gt;&gt;&gt; MinimalAccount("a", 1000, 0.01)
MinimalAccount(account_id='a', balance=1000, interest_rate=0.01)
</code></pre>
<h4 id="basic-features"><a class="header" href="#basic-features">Basic Features</a></h4>
<p>Now let us write some simple features of these bank accounts. There are
two features we shall explore:</p>
<ol>
<li>Depositing money into a bank account. Since we are writing code in a
purely functional style, our function does not mutate the state of
the bank account. Instead, it returns a new state of the account
with the money deposited. Assume that the deposit amount is
non-negative.</li>
<li>Deducting money from a bank account. Just like before, we are not
mutating the state of the bank account, and instead will be
returning the new state of the bank account. However, the deduction
might not happen since the account might have insufficient funds. As
such, this function returns a tuple containing a boolean flag
describing whether the deduction succeeded, and the new state of the
bank account after the deduction (if the deduction does not occur,
the state of the bank account remains unchanged).</li>
</ol>
<p><em>Note</em>: The type of a tuple with two elements of types <code>A</code> and
<code>B</code> is <code>tuple[A, B]</code>. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = NormalAccount('abc', 1000, 0.01)
&gt;&gt;&gt; y = MinimalAccount('bcd', 2000, 0.02)
&gt;&gt;&gt; deposit(1000, x)
NormalAccount(account_id='abc', balance=2000, interest_rate=0.01)
&gt;&gt;&gt; deduct(1000, x)
(True, NormalAccount(account_id='abc', balance=0, interest_rate=0.01))
&gt;&gt;&gt; deduct(2001, y)
(False, MinimalAccount(account_id='bcd', balance=2000, 
    interest_rate=0.02))
</code></pre>
<h4 id="advanced-features"><a class="header" href="#advanced-features">Advanced Features</a></h4>
<p>Now we shall implement some more advanced features:</p>
<ol>
<li>
<p>Compounding interest. Given a bank account with balance \(b\) and
interest rate \(i\), the new balance after compounding will be
\(b(1+i)\). For minimal accounts, an administrative fee of $20 will
be deducted if its balance is strictly below $1000. This fee
deduction happens <strong>before</strong> compounding. Importantly, bank balances
never go below $0, so e.g. if a minimal account has $10, after
compounding, its balance will be $0.</p>
</li>
<li>
<p>Bank transfers. This function receives a transaction amount and two
bank accounts: (1) the credit account (the bank account where funds
will come from) and (2) the debit account (bank account where funds
will be transferred to). The result of the transfer is a triplet
(tuple of three elements) containing a boolean describing the
success of the transaction, and the new states of the credit and
debit accounts. The transaction does not happen if the credit
account has insufficient funds.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = NormalAccount('abc', 1000, 0.01)
&gt;&gt;&gt; y = MinimalAccount('bcd', 2000, 0.02)
&gt;&gt;&gt; z = MinimalAccount('def', 999, 0.01)
&gt;&gt;&gt; w = MinimalAccount('xyz', 19, 0.01)
&gt;&gt;&gt; compound(x)
NormalAccount(account_id='abc', balance=1010, interest_rate=0.01)
&gt;&gt;&gt; compound(compound(x))
NormalAccount(account_id='abc', balance=1020.1, interest_rate=0.01)
&gt;&gt;&gt; compound(y)
MinimalAccount(account_id='bcd', balance=2040, interest_rate=0.02)
&gt;&gt;&gt; compound(z)
MinimalAccount(account_id='def', balance=988.79, interest_rate=0.01)
&gt;&gt;&gt; compound(w)
MinimalAccount(account_id='xyz', balance=0, interest_rate=0.01)
&gt;&gt;&gt; transfer(2000, x, y)
(False, NormalAccount(account_id='abc', balance=1000,
    interest_rate=0.01), MinimalAccount(account_id='bcd', 
    balance=2000, interest_rate=0.02))
&gt;&gt;&gt; transfer(2000, y, x)
(True, MinimalAccount(account_id='bcd', balance=0,
    interest_rate=0.02), NormalAccount(account_id='abc', 
    balance=3000, interest_rate=0.01))
</code></pre>
<h4 id="operating-on-bank-accounts"><a class="header" href="#operating-on-bank-accounts">Operating on Bank Accounts</a></h4>
<p>Let us suppose that we have a dictionary whose keys are bank account IDs
and values are their corresponding bank accounts. This dictionary
simulates a 'database' of bank accounts which we can easily lookup by
bank account ID:</p>
<pre><code class="language-python">&gt;&gt;&gt; d: dict[str, BankAccount] = {
  'abc': NormalAccount('abc', 1000, 0.01)
  'bcd': MinimalAccount('bcd', 2000, 0.02)
}
</code></pre>
<p>Now we are going to process a whole bunch of operations on this
'database'.</p>
<h4 id="operations-adt"><a class="header" href="#operations-adt">Operations ADT</a></h4>
<p>The first step in processing a bunch of operations on the accounts in
our database is to create a data structure that represents the desired
operation in the first place. For this, create an algebraic data type
<code>Op</code> comprised of two classes:</p>
<ol>
<li><code>Transfer</code>: has a transfer amount, and credit bank account
ID, and a debit bank account ID. This represents the operation where
we are transferring the transfer amount from the credit account to
the debit account.</li>
<li><code>Compound</code>. This just tells the processor to compound all
the bank accounts in the map. There should be no attributes in this
class.</li>
</ol>
<h4 id="processing-one-operation"><a class="header" href="#processing-one-operation">Processing One Operation</a></h4>
<p>Write a function <code>process_one</code> that receives an operation and a
dictionary of bank accounts (keys are bank account IDs, and values are
the corresponding bank accounts), and performs the operation on the bank
accounts in the dictionary. As a result, the function returns a pair
containing:</p>
<ol>
<li>A boolean value to describe whether the operation has succeeded</li>
<li>The resulting dictionary containing the updated bank accounts after
the operation has been processed.</li>
</ol>
<p>Take note that there are several ways in which a <code>Transfer</code>
operation may fail:</p>
<ol>
<li>If any of the account IDs do not exist in the dictionary, the transfer
will fail</li>
<li>If the credit account does not have sufficient funds, the transfer
will fail</li>
<li>Otherwise, the transfer should proceed as per normal</li>
</ol>
<p>Keep in mind that you should not mutate any data structure used. Example
runs follow:</p>
<pre><code class="language-python"># data
&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}

# ops
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')

# processing compound operation
&gt;&gt;&gt; process_one(c, mp)
(True, {'alice': NormalAccount('alice', 1100.0, 0.1), 
        'bob': MinimalAccount('bob', 1076.9, 0.1)})

# processing transfers
&gt;&gt;&gt; process_one(t1, mp)
(True, {'alice': NormalAccount('alice', 0, 0.1), 
        'bob': MinimalAccount('bob', 1999, 0.1)})
&gt;&gt;&gt; process_one(t2, mp)
(False, {'alice': NormalAccount('alice', 1000, 0.1), 
         'bob': MinimalAccount('bob', 999, 0.1)})
</code></pre>
<h4 id="processing-all-operations"><a class="header" href="#processing-all-operations">Processing All Operations</a></h4>
<p>Now let us finally define a function <code>process_all</code> that
receives a list of operations and a dictionary of bank accounts (the
keys are bank account IDs, and the values are bank accounts). As a
result, the function returns a pair containing:</p>
<ol>
<li>A list of booleans where the \(i^\text{th}\) boolean value describes
whether the \(i^\text{th}\) operation has succeeded</li>
<li>The resulting dictionary containing the updated bank accounts after
all the operations have been processed.</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-python"># data
&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}

# op
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')

# process
&gt;&gt;&gt; process_all([t2, c, t2, t1], mp)
([False, True, True, True], 
 {'alice': NormalAccount(account_id='alice', balance=1100.0, interest_rate=0.1), 
  'bob': MinimalAccount(account_id='bob', balance=1076.9, interest_rate=0.1)})
</code></pre>
<h4 id="polymorphic-processing"><a class="header" href="#polymorphic-processing">Polymorphic Processing</a></h4>
<p>Let us assume that your <code>process_all</code> function invokes the <code>process_one</code> function. If you were careful with your implementation of <code>process_all</code>, you <em>should</em> be able to lift your <code>proces_one</code> function as a parameter:</p>
<pre><code class="language-python">def process_all(ops, mp):
    # ...
    process_one(...)
    # ...

# becomes

def process_all(f, ops, mp):
    # ...
    f(...)
    # ...
</code></pre>
<p>After which, nothing about the implementation of <code>process_all</code> depends on
the types like <code>Op</code>, <code>dict[str, BankAccount]</code> or
<code>bool</code>. Thus, we should make this function polymorphic!</p>
<p>Our goal is to write a polymorphic function <code>process</code> that can
process any list over a state and produce the resulting list and an
updated state after performing stateful processing over the list. It
should be defined such that <code>process(process_one, ops, mp)</code>
should be the exact same as <code>process_all(ops, mp)</code> as you have
defined earlier:</p>
<pre><code class="language-python"># data
&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}

# ops
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')

# process
&gt;&gt;&gt; process(process_one, [t2, c, t2, t1], mp)
([False, True, True, True], 
 {'alice': NormalAccount(account_id='alice', balance=1100.0, interest_rate=0.1),
  'bob': MinimalAccount(account_id='bob', balance=1076.9, interest_rate=0.1)})
</code></pre>
<p>Furthermore, the best part of this polymorphic function is that it can
be used in any situation where we need this stateful accumulation over a
list. For example, we can define a function that tests if a number \(n\)
is co-prime to a list of other numbers, and if it is indeed co-prime to
all of the input numbers, add \(n\) to the state list:</p>
<pre><code class="language-python">&gt;&gt;&gt; def gather_primes(n: int, ls: list[int]) -&gt; tuple[bool, list[int]]:
...     if any(n % i == 0 for i in ls):
...         return (False, ls)
...     return (True, ls + [n])
</code></pre>
<p>Example uses of this follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; gather_primes(2, [])
(True, [2])
&gt;&gt;&gt; gather_primes(3, [2])
(True, [2, 3])
&gt;&gt;&gt; gather_primes(4, [2, 3])
(False, [2, 3])
</code></pre>
<p>This way, we can use <code>process</code> to generate prime numbers and do
primality testing!</p>
<pre><code class="language-python">&gt;&gt;&gt; def primes(n: int) -&gt; tuple[list[bool], list[n]]:
...     return process(gather_primes, list(range(2, n)), [])
... 
&gt;&gt;&gt; primes(10)
([True, True, False, True, False, True, False, False], [2, 3, 5, 7])
&gt;&gt;&gt; primes(30)
([True, True, False, True, False, True, False, False, False, # 2 to 10
  True, False, True, False, False, False, True, False, True, # 11 to 20
  False, False, False, True, False, False, False, False, False, True], 
  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29])
</code></pre>
<p>Proceed to define the <code>process</code> function. Example runs are as
above.</p>
<p><em>Note</em>: The type of a function that receives parameters <code>A</code>, <code>B</code> and <code>C</code>
and returns <code>D</code> is <code>Callable[[A, B, C], D]</code>. You will need to
import <code>Callable</code> from <code>typing</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>Two of the most important aspects of software engineering design are <em>decoupling</em> and <em>extensibility</em>, reducing the dependencies between two systems or programming constructs and making it easy to extend implementations. These are not simple problems for programming language designers to solve. Different languages offer different solutions to this problem, and some languages make these not-so-easy.</p>
<p>In this chapter, we discuss how Haskell allows us to decouple types and functions, and in some sense, making data types extensible, without compromising on type-safety. Haskell does so with a programming feature not common to many languages, known as typeclasses.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="ad-hoc-polymorphism"><a class="header" href="#ad-hoc-polymorphism">Ad-Hoc Polymorphism</a></h1>
<p>So far, we have learnt how to define algebraic data types, and
construct—and destructure—terms of those types. However, algebraic
data types typically only represent data, unlike objects in OOP.
Therefore, we frequently write <em>functions</em> acting on terms of those
types. As an example, drawing from <a href="typeclasses/sections/../../types/sections/exercises.html">Chapter 2.5 Question 7</a>, let us define a
<code>Shape</code> ADT that represents circles and rectangles.</p>
<pre><code class="language-haskell">data Shape = Circle Double
           | Rectangle Double Double
</code></pre>
<p>On its own, this ADT does not do very much. What we would like to do
additionally, is to define a function over <code>Shape</code>s. For
example, a function <code>area</code> that computes the area of a
<code>Shape</code>:</p>
<pre><code class="language-haskell">area :: Shape -&gt; Double
area (Circle r) = pi * r ^ 2
area (Rectangle w h) = w * h
</code></pre>
<p>However, you might notice that <code>area</code> should not be
exclusively defined on <code>Shape</code>s; it could very well be the
case that we will later define other algebraic data types from which we
can also compute its area. For example, let us define a
<code>House</code> data type that also has a way to compute its area:</p>
<pre><code class="language-haskell">data House = H [Room]
type Room = Rectangle

area' :: House -&gt; Double
area' (H ls) = foldr ((+) . area) 0 ls
</code></pre>
<p>Notice that we cannot, at this point, abstract <code>area</code> and
<code>area'</code> into a single function because these functions work on
specific types, and they have type-specific implementations. It is such
a waste for us to have to use different names to describe the same idea.</p>
<p>The question then becomes, is it possible for us to define an
<code>area</code> function that is polymorphic (not fully parametrically
polymorphic) in some ad-hoc way? That is, can <code>area</code> have one
implementation when given an argument of type <code>Shape</code>, and
another implementation when given another argument of type
<code>House</code>?</p>
<h2 id="ad-hoc-polymorphism-in-python"><a class="header" href="#ad-hoc-polymorphism-in-python">Ad-Hoc Polymorphism in Python</a></h2>
<p>Notice that this is entirely possible in Python and other OO languages,
where different classes can define methods of the same name.</p>
<pre><code class="language-python">@dataclass
class Rectangle:
  w: float
  h: float
  def area(self) -&gt; float:
    return self.w * self.h

@dataclass
class Circle:
  r: float
  def area(self) -&gt; float:
    return pi * r ** 2

@dataclass
class House:
  ls: list[Rectangle]
  def area(self) -&gt; float:
    return sum(x.area() for x in self.ls)
</code></pre>
<p>All of these disparate types can define an <code>area</code> method with
its own type-specific implementation, and this is known as method
<em>overloading</em>. In fact, Python allows us to use them in an ad-hoc manner
because Python does not enforce types. Therefore, a program like the
following will be totally fine.</p>
<pre><code class="language-python">def total_area(ls):
  return sum(x.area() for x in ls)

ls = [Rectangle(1, 2), House([Rectangle(3, 4)])]
print(total_area(ls)) # 14
</code></pre>
<p><code>total_area</code> works because Python uses <em>duck typing</em>—if it
walks like a duck, quacks like a duck, it is probably a duck. Therefore,
as long as the elements of the input list <code>ls</code> defines a method
<code>area</code> that returns something that can be summed over, no type
errors will present from program execution.</p>
<p>Python allows us to take this further by defining special methods to
overload operators. For example, we can define the <code>__add__</code>
method on any class to define how it should behave under the
<code>+</code> operator:</p>
<pre><code class="language-python">@dataclass
class Fraction:
  num: int
  den: int
  def __add__(self, f):
    num = self.num * f.den + f.num * self.den
    den = self.den * f.den
    return Fraction(num, den)

print(1 + 2) # 3
print(Fraction(1, 2) + Fraction(3, 4)) # Fraction(10, 8)
</code></pre>
<p>However, relying on duck typing alone forces us to ditch any hopes for
static type checking. From the definition of the <code>ls</code> variable
above:</p>
<pre><code class="language-python">ls = [Rectangle(1, 2), House([Rectangle(3, 4)])]
</code></pre>
<p>based on what we know, <code>ls</code> cannot be given a suitable type that is useful. Great
thing is, Python has support for <em>protocols</em> that allow us to group
classes that adhere to a common interface (without the need for class
extension):</p>
<pre><code class="language-python">class HasArea(Protocol):
  @abstractmethod
  def area(self) -&gt; float:
    pass

def total_area(ls: list[HasArea]) -&gt; float:
  return sum(x.area() for x in ls)

ls: list[HasArea] = [Rectangle(1, 2), House([Rectangle(3, 4)])]
print(total_area(ls)) # 14
</code></pre>
<p>This is great because we have the ability to perform ad-hoc polymorphism
without coupling the data with behaviour—the <code>HasArea</code>
protocol makes no mention of its inhabiting classes
<code>Rectangle</code>, <code>Circle</code> and <code>House</code>, and
vice-versa, and yet we have provided enough information for the
type-checker so that bogus code such as the following gets flagged
early.</p>
<pre><code class="language-python">ls: list[HasArea] = [1] # Type checker complains about this
print(total_area(ls)) # TypeError
</code></pre>
<h2 id="the-expression-problem-in-python"><a class="header" href="#the-expression-problem-in-python">The Expression Problem in Python</a></h2>
<p>There are several limitations of our solution using protocols. Firstly,
Python's type system is not powerful or expressive enough to describe
protocols involving higher-kinded types. Secondly, although we have
earlier achieved decoupling between classes and the protocols they abide
by, we are not able to decouple classes and their methods. If we wanted
to completely decouple them, we would define methods as plain functions,
and run into the same problems we have seen in the Haskell
implementation of <code>area</code> and <code>area'</code> above.</p>
<p>At the expense of type safety, let us attempt to decouple
<code>area</code> and their implementing classes. The idea is to define an
<code>area</code> function that receives a helper function that computes
the type specific area of an object:</p>
<pre><code class="language-python">def area(x, helper) -&gt; float:
  return helper(x)

def rectangle_area(rect: Rectangle) -&gt; float:
  return rect.w * rect.h
def house_area(house: House) -&gt; float:
  return sum(x.area() for x in house.ls)

r = Rectangle(1, 2)
h = House([Rectangle(3, 4)])
area(r, rectangle_area) # 2
area(h, house_area) # 12
</code></pre>
<p>This implementation is silly because we could easily remove one level of
indirection by invoking <code>rectangle_area</code> or
<code>house_area</code> directly. However, notice that the implementations
are specific to classes—or, types—thus, what we can do is to store
these helpers in a dictionary whose keys are the types they were meant
to be inhabiting. Then, the <code>area</code> function can look up the
right type-specific implementation based on the type of the argument.</p>
<pre><code class="language-python">HasArea = {} 

def area(x):
  helper = HasArea[type(x)]
  return helper(x)

HasArea[Rectangle] = lambda x: x.w * x.h
HasArea[House] = lambda house: sum(x.area() for x in house.ls)

r = Rectangle(1, 2)
h = House([Rectangle(3, 4)])
area(r) # 2
area(h) # 12
</code></pre>
<p>What's great about this approach is that (1) otherwise disparate classes
adhere to a common interface, and (2) the classes and methods are
completely decoupled. We can later on define additional classes and its
type-specific implementation of <code>area</code>, or define a
type-specific implementation of <code>area</code> for a class that has
already been defined!</p>
<pre><code class="language-python">@dataclass
class Triangle:
  w: float
  h: float

HasArea[Triangle] = lambda t: 0.5 * t.w * t.h

area(Triangle(5, 2)) # 5
</code></pre>
<p>Unfortunately, all of these gains came at the cost of type safety. Is
there a better way to do this? In Haskell, yes—with typeclasses!</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="typeclasses"><a class="header" href="#typeclasses">Typeclasses</a></h1>
<p>Typeclasses are a type system construct that enables ad-hoc
polymorphism. Essentially, a typeclass is a nominal classification of
types that all support some specified behaviour, by having each type
providing its type-specific implementation for those behaviours.
Alternatively, a typeclass can be seen as a constraint for a type to
support specified behaviours.</p>
<p>Just like classes in OOP are blueprints for creating instances of the
class (objects), a typeclass is a blueprint for creating typeclass
instances. This time, a typeclass provides the
interface/specification/contract for members of the typeclass to adhere
to, and typeclass instances provide the actual type-specific
implementations of functions specified in the typeclass. In essence, a
typeclass is a constraint over types, and a typeclass instance is a witness that
for types meeting those constraints.</p>
<p>To build on intuition, pretend that there is a super cool magic club,
and members of this club must have a magic assistant and a magic trick.
This club acts as a typeclass. Then suppose cats and dogs want to join
this club. To do so, they must provide proof to the club administrators
(in Haskell, the compiler) that they have a magic assistant and a magic
trick. Suppose that the cats come together with their mouse friends as
their magic assistants, and their magic trick is to cough up a furball,
and the dogs all present their chew toys as their magic assistants, and
their magic trick is to give their paw. The club administrator then puts
all these into boxes as certificates of their membership into the
club—in our analogy, these certificates are typeclass instances.</p>
<p>Let us return to the shape and house example we have seen at the start
of this chapter. We first define some types (slightly different from
before) that all have an area:</p>
<pre><code class="language-haskell">data Shape = Circle Double
           | Rectangle Double Double
           | Triangle Double Double
data House = H [Room]
data room = R { roomName :: String
              , shape    :: Shape }
</code></pre>
<p>Now, our goal is to describe the phenomenon that some types have an
area. For this, we shall describe a contract for such types to follow.
The contract is straightforward—all such types must have an
<code>area</code> function (known as a method).</p>
<pre><code class="language-haskell">class HasArea a where
  area :: a -&gt; Double
</code></pre>
<p>An important question one might ask is: why is <code>HasArea</code>
polymorphic? To give an analogy, recall in our Python implementation
with dictionaries that <code>HasArea</code> is a dictionary where we are
looking up type-specific implementations of <code>area</code> by type.
Essentially, it is a finite map or (partial) function from types to
functions. This essentially makes <code>HasArea</code> polymorphic,
because it acts as a function that produces different implementations
depending on the type!</p>
<p>Then, the <code>area</code> function should also receive a parameter of
type <code>a</code>—that is, if <code>a</code> is a member of the
<code>HasArea</code> typeclass, then there is a function
<code>area :: a -&gt; Double</code>. The example typeclass instances make
this clear:</p>
<pre><code class="language-haskell">instance HasArea Shape where
  area :: Shape -&gt; Double
  area (Circle r) = pi * r ^ 2
  area (Rectangle w h) = w * h
  area (Triangle w h) = w * h / 2

instance HasArea Room where
  area :: Room -&gt; Double
  area x = area $ shape x

instance HasArea House where
  area :: House -&gt; Double
  area (H rooms) = sum $ map area rooms
</code></pre>
<p>Each instance of <code>HasArea</code> provides a type-specific
implementation of <code>area</code>. For example, the
<code>HasArea Shape</code> instance acts as a witness that
<code>Shape</code> belongs to the <code>HasArea</code> typeclass. It does
so by providing an implementation of <code>area :: Shape -&gt; Double</code>
(in the obvious way). We do the same for rooms and houses, and now the
<code>area</code> function works for all (and only) these three types!</p>
<pre><code class="language-haskell">x :: Shape = Triangle 2 3
y :: Room = R "bedroom" (Rectangle 3 4)
z :: House = H [y]

ax = area x -- 3
ay = area y -- 12
az = area z -- 12
</code></pre>
<p>Now let us investigate the type of <code>area</code>:</p>
<pre><code class="language-haskell">ghci&gt; :t area
area :: forall a. HasArea a =&gt; a -&gt; double
</code></pre>
<p>The type of <code>area</code> is read as "a function for all
<code>a</code> where <code>a</code> is constrained by <code>HasArea</code>,
and receives an <code>a</code>, and returns a <code>Double</code>".</p>
<p>Constrains on type variables are not limited to class methods. In fact,
we can, and probably should, make functions that use <code>area</code>
polymorphically over type variables, constrained by <code>HasArea</code>. Let
us consider a function that sums the area over a list of shapes, and
another one over a list of rooms:</p>
<pre><code class="language-haskell">totalArea :: [Shape] -&gt; Double
totalArea [] = 0
totalArea (x : xs) = area x + totalArea xs

-- alternatively
totalArea' :: [Shape] -&gt; Double
totalArea' = sum . map area

totalArea'' :: [Room] -&gt; Double
totalArea'' = sum . map area
</code></pre>
<p>Both <code>totalArea'</code> and <code>totalArea''</code> have
precisely the same implementation, except that they operate over
<code>Shape</code> and <code>Room</code> respectively. We can
substitute these types for any type variable <code>a</code>, so long as
there is an instance of <code>HasArea a</code>! Therefore, the most
general type we should ascribe for this function would be</p>
<pre><code class="language-haskell">totalArea :: HasArea a =&gt; [a] -&gt; Double
totalArea = sum . map area
</code></pre>
<p>Now our <code>totalArea</code> function works on any list that contains a
type that has an instance of <code>HasArea</code>!</p>
<pre><code class="language-haskell">xs :: [Shape] = [Rectangle 1 2, Triangle 3 4]
ys :: [House] = [H [R "bedroom" (Rectangle 1 2)]]
axs = totalArea xs -- 8
ayx = totalArea ys -- 2
</code></pre>
<h3 id="how-typeclasses-work"><a class="header" href="#how-typeclasses-work">How Typeclasses Work</a></h3>
<p>By now, you should be able to observe that typeclasses allow (1)
otherwise disparate types adhering to a common interface, i.e. ad-hoc
polymorphism and (2) decoupling types and behaviour, all in a type-safe
way—this is very difficult (if not impossible) to achieve in other
languages like Python. The question then becomes: how does Haskell do
it?</p>
<p>The core idea behind typeclasses and typeclass instances is that
typeclasses are implemented as regular algebraic data types, and
typeclass instances are implemented as regular terms of typeclasses.
Using our <code>area</code> example, we can define the typeclass as</p>
<pre><code class="language-haskell">data HasArea a = HA { area :: a -&gt; Double }
</code></pre>
<p>Then, typeclass instances are merely helper-terms of the
<code>HasArea</code> type:</p>
<pre><code class="language-haskell">hasAreaShape :: HasArea Shape
hasAreaShape = HA $ \x -&gt; case x of
  Circle    r   -&gt; pi * r ^ 2
  Rectangle w h -&gt; w * h
  Triangle  w h -&gt; w * h / 2
</code></pre>
<p>Notice that <code>area</code> now has the type
<code>HasArea a -&gt; a -&gt; Double</code>. Clearly,
<code>area hasAreaShape</code> is now the <code>Shape</code>-specific
implementation for obtaining the area of a shape! We can take this
further by defining the helper-terms for other types that wish to
implement the <code>HasArea</code> typeclass:</p>
<pre><code class="language-haskell">hasAreaRoom :: HasArea Room
hasAreaRoom = HA $ \x -&gt; area hasAreaShape (shape x)

hasAreaHouse :: HasArea House
hasAreaHouse = HA $ \x -&gt; case x of
  H rooms -&gt; sum $ map (area hasAreaRoom) rooms
</code></pre>
<p>Finally, we can use the <code>area</code> function, together with the
type-specific helpers, to compute the area of shapes, rooms and houses!</p>
<pre><code class="language-haskell">x :: Shape = Triangle 2 3
y :: Room = R "bedroom" (Rectangle 3 4)
z :: House = H [y]

ax = area hasAreaShape x -- 3
ay = area hasAreaRoom y -- 12
az = area hasAreamHouse z -- 12
</code></pre>
<p>This is (more-or-less) how Haskell implements typeclasses and typeclass
instances. The only difference is that the Haskell compiler will
automatically <em>infer</em> the helper term when a typeclass method is used,
allowing us to omit them. This <em>term inference</em> that Haskell supports
allow us to define and use ad-hoc polymorphic functions in a type-safe
way.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="commonly-used-typeclasses"><a class="header" href="#commonly-used-typeclasses">Commonly Used Typeclasses</a></h1>
<p>Let us have a look at some typeclasses and their methods that you have
already used.</p>
<pre><code class="language-haskell">class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool

class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer a
</code></pre>
<h2 id="equality-comparisons"><a class="header" href="#equality-comparisons">Equality Comparisons</a></h2>
<p>The <code>Eq</code> typeclass describes types that are amenable to
equality comparisons; the <code>Num</code> typeclass describes types that
can behave as numbers, with support for typical numeric operations like
addition, subtraction and so on. Haskell's Prelude already ships with
the instances of these typeclasses for commonly-used types, such as
instances for <code>Num Int</code> and <code>Eq String</code>.</p>
<p>Let us try defining our own instance of <code>Eq</code>. Suppose we are
re-using the <code>Fraction</code> algebraic data type defined in <a href="typeclasses/sections/../../types/sections/algebraic_data_types.html">Chapter 2.3 (Types#Algebraic Data Types)</a>:</p>
<pre><code class="language-haskell">data Fraction = Fraction Int Int
</code></pre>
<p>We allow <code>Fraction</code> to be amenable to equality comparisons
by implementing a typeclass instance for <code>Eq Fraction</code>:</p>
<pre><code class="language-haskell">instance Eq Fraction where
  (==) :: Fraction -&gt; Fraction -&gt; Bool
  F a b == F c d = a == c &amp;&amp; b == d

  (/=) :: Fraction -&gt; Fraction -&gt; Bool
  F a b /= F c d = a /= c || b /= d
</code></pre>
<p>Firstly, notice that we are performing equality comparisons between the
numerators and denominators. This is okay because we know that the
numerators and denominators of fractions are integers, and there is
already an instance of <code>Eq Int</code>. Next, usually by definition,
<code>a /= b</code> is the same as <code>not (a == b)</code>. Therefore,
having to always define both <code>(==)</code> and <code>(/=)</code> for
every instance is cumbersome.</p>
<h2 id="minimal-instance-definitions"><a class="header" href="#minimal-instance-definitions">Minimal Instance Definitions</a></h2>
<p>Let us inspect the definition of the <code>Eq</code> typeclass:</p>
<pre><code class="language-haskell">ghci&gt; :i Eq
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
    -- Defined in 'GHC.Classes'
</code></pre>
<p>Notice the <code>MINIMAL</code> <em>pragma</em>—the pragma states that we only need to
define either <code>(==)</code> <em>or</em> <code>(/=)</code> for a complete
instance definition! Therefore, we can omit the definition of
<code>(/=)</code> in our <code>Eq Fraction</code> instance, and we would
still have a complete definition:</p>
<pre><code class="language-haskell">instance Eq Fraction where
  (==) :: Fraction -&gt; Fraction -&gt; Bool
  F a b == F c d = a == c &amp;&amp; b == d
</code></pre>
<pre><code class="language-haskell">ghci&gt; Fraction 1 2 == Fraction 1 2
True
ghci&gt; Fraction 1 2 /= Fraction 1 2
False
</code></pre>
<p>A natural question to ask is, why not simply define <code>Eq</code> to
only have <code>(==)</code> and give <code>(/=)</code> for free?</p>
<pre><code class="language-haskell">class Eq a where
  (==) :: a -&gt; a -&gt; Bool

(/=) :: Eq a =&gt; a -&gt; a -&gt; Bool
x /= y = not (x == y)
</code></pre>
<p>By placing both functions as methods in the typeclass, programmers have
the option to define <em>either</em> <code>(==)</code> <em>or</em> <code>(/=)</code>, or
both, if specifying each implementation individually gives better performance or
different behaviour than the default.</p>
<h2 id="typeclass-constraints-in-typeclasses-and-instances"><a class="header" href="#typeclass-constraints-in-typeclasses-and-instances">Typeclass Constraints in Typeclasses and Instances</a></h2>
<p>We can even define instances over polymorphic types. Here is an example
of how we can perform equality comparisons over trees:</p>
<pre><code class="language-haskell">data Tree a = Node (Tree a) a (Tree a)
            | Empty

instance Eq (Tree a) where
  (==) :: Tree a -&gt; Tree a -&gt; Bool
  Empty == Empty = True
  (Node l v r) == (Node l' v' r') = l == l' &amp;&amp; v == v' &amp;&amp; r == r'
  _ == _ = False
</code></pre>
<p>However, our instance will not type-check because the elements
<code>a</code> of the trees also need to be amenable to equality
comparisons for us to compare trees! Therefore, we should constrain
<code>a</code> with <code>Eq</code> in the <em>instance</em> declaration, like
so:</p>
<pre><code class="language-haskell">data Tree a = Node (Tree a) a (Tree a)
            | Empty

instance Eq a =&gt; Eq (Tree a) where
  (==) :: Tree a -&gt; Tree a -&gt; Bool
  Empty == Empty = True
  (Node l v r) == (Node l' v' r') = l == l' &amp;&amp; v == v' &amp;&amp; r == r'
  _ == _ = False
</code></pre>
<p>In fact, we can write typeclass constraints in typeclass declarations as
well. For example, the <code>Ord</code> typeclass describes (total)
orders on types, and all (totally) ordered types must also be amenable
to equality comparisons:</p>
<pre><code class="language-haskell">class Eq a =&gt; Ord a where
  (&lt;) :: a -&gt; a -&gt; Bool
  (&lt;=) :: a -&gt; a -&gt; Bool
  -- ...
</code></pre>
<h2 id="deriving-typeclasses"><a class="header" href="#deriving-typeclasses">Deriving Typeclasses</a></h2>
<p>In fact, some typeclasses are so straightforward that defining instances
of these classes are a tedium. For example, the <code>Eq</code> class is
(usually) very straightforward to define—two terms are equal if they
are built with the same constructor and their argument terms are
respectively equal. As such, the language should not require programmers
to implement straightforward instances of classes like <code>Eq</code>.</p>
<p>Haskell has a <em>deriving mechanism</em> that allows the compiler to
automatically synthesize typeclass instances for us. It is able to do so
for <code>Eq</code>, <code>Ord</code>, and others like <code>Enum</code>.
Doing so is incredibly straightforward:</p>
<pre><code class="language-haskell">data A = B | C

data Fraction = Fraction Int Int 
  deriving Eq -- deriving Eq Fraction instance

data Tree a = Empty | Node (Tree a) a (Tree a)
  deriving (Eq, Show) -- deriving Eq (Tree a) and Show (Tree a)

deriving instance Eq A -- stand-alone deriving declaration
</code></pre>
<p>These declarations tell the compiler to synthesize instance declarations
in the most obvious way. This way, we do not have to write our own
instance declarations for these typeclasses!</p>
<pre><code class="language-haskell">ghci&gt; x = Node Empty 1 Empty
ghci&gt; y = Node (Node Empty 1 Empty) 2 Empty
ghci&gt; x
Node Empty 1 Empty
ghci&gt; x == y
False
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="functional-dependencies"><a class="header" href="#functional-dependencies">Functional Dependencies</a></h1>
<p>Observe the type of <code>(+)</code>:</p>
<pre><code class="language-haskell">:t (+)
(+) :: forall a. Num a =&gt; a -&gt; a
</code></pre>
<p>This is quite different in Python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(1 + 1)
class &lt;'int'&gt;
&gt;&gt;&gt; type(1 + 1.0)
class &lt;'float'&gt;
&gt;&gt;&gt; type(1.0 + 1)
class &lt;'float'&gt;
&gt;&gt;&gt; type(1.0 + 1.0)
class &lt;'float'&gt;
</code></pre>
<p>The <code>+</code> operator in Python behaves heterogenously—when given
two <code>int</code>s we get an <code>int</code>; when given at least one
<code>float</code> we get a <code>float</code>. How would we encode this in
Haskell?</p>
<p>Simple! Create a multi-parameter typeclass that describes the argument
types and the result type!</p>
<pre><code class="language-haskell">class (Num a, Num b, Num c) =&gt; HAdd a b c where
  (+#) :: a -&gt; b -&gt; c
</code></pre>
<p>Then we can write instances for the possible permutations of the desired
types:</p>
<pre><code class="language-haskell">instance Num a =&gt; HAdd a a a where
  (+#) :: a -&gt; a -&gt; a
  (+#) = (+)

instance HAdd Int Double Double where
  (+#) :: Int -&gt; Double -&gt; Double
  x +# y = fromIntegral x + y

instance HAdd Double Int Double where
  (+#) :: Double -&gt; Int -&gt; Double
  x +# y = x + fromIntegral y
</code></pre>
<p>However, trying to use <code>(+#)</code> is very cumbersome:</p>
<pre><code class="language-haskell">ghci&gt; x :: Int = 1
ghci&gt; y :: Double = 2.0
ghci&gt; x +# y
&lt;interactive&gt;:3:1: error:
    - No instance for (HAdd Int Double ()) arising from a use of 'it'
    - In the first argument of 'print', namely 'it'
      In a stmt of an interactive GHCi command: print it
ghci&gt; x +# y :: Double
3.0
</code></pre>
<p>This occurs because without specifying the return type <code>c</code>,
Haskell has no idea what it is since it is ambiguous! As per the
definition, no one is stopping us from defining another
<code>instance HAdd Int Double String</code>! On the other hand, we know
that adding an <code>Int</code> and a <code>Double</code> <em>must</em> result in
a <code>Double</code> and nothing else; in other words, the types of the
arguments to <code>(+#)</code> <em>uniquely characterizes</em> the resulting
type.</p>
<p>The way we introduce this dependency between these type variables by
introducing <em>functional dependencies</em> on typeclass declarations, which,
adding them to our declaration of <code>HAdd</code>, looks something like
the following:</p>
<pre><code class="language-haskell">{-# LANGUAGE FunctionalDependencies #-}
class (Num a, Num b, Num c) =&gt; HAdd a b c | a b -&gt; c where
  (+#) :: a -&gt; b -&gt; c
</code></pre>
<p>The way to read the clause <code>a b -&gt; c</code> is "<code>a</code> and <code>b</code> <em>uniquely
characterizes</em>/<em>determines</em> <code>c</code>", or in other words, <code>c</code> is a <em>function</em>
of <code>a</code> and <code>b</code>, i.e. it is not possible that given a <em>fixed</em> <code>a</code> and <code>b</code>
that we have two different inhabitants of <code>c</code>. This (1) prevents the
programmer from introducing different values of <code>c</code> for the same <code>a</code> and
<code>b</code> (which we haven't) and (2) allows the compiler to infer the right
instance just with <code>a</code> and <code>b</code> alone.</p>
<pre><code class="language-haskell">ghci&gt; x :: Int = 1
ghci&gt; y :: Double = 2.0
ghci&gt; x +# y
3.0
ghci&gt; :{
ghci| instance HAdd Int Double String where
ghci|   x +# y = show x
ghci| :}
&lt;interactive&gt;:8:10: error:
    Functional dependencies conflict between instance declarations:
      instance [safe] HAdd Int Double Double
        -- Defined at &lt;interactive&gt;:17:10
      instance HAdd Int Double String -- Defined at &lt;interactive&gt;:21:10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="the-existential-typeclass-antipattern"><a class="header" href="#the-existential-typeclass-antipattern">The Existential Typeclass Antipattern</a></h1>
<p>In Python, as long as a class abides by a protocol, the Python type system presumes that this class is a <em>subclass</em> of said protocol. Therefore, any object instantiated from such a class is also considered to be of the same type as the protocol. Thus, in our earlier example, shapes, houses and rooms are all considered to be the same type has <code>HasArea</code>.</p>
<pre><code class="language-python">class HasArea(Protocol):
    def area(self) -&gt; float:
        pass

@dataclass
class Rectangle:
    # ...
    def area(self) -&gt; float:
        return # ...

@dataclass
class House:
    # ...
    def area(self) -&gt; float:
        return # ...

# the following is ok and well-typed
ls: list[HasArea] = [Rectangle(1, 2), House(...)]
</code></pre>
<p>However, this is <em>not</em> okay in Haskell because <code>HasArea</code> is not a type, but a typeclass!</p>
<pre><code class="language-haskell">x = Triangle 2 3
y = R "bedroom" (Rectangle 3 4)
z = H [y]
ls = [x, y, z] -- error!
</code></pre>
<p>One question we might ask is, how do we replicate this ability in Python? I.e., how do we create a type that represents all types that implement <code>HasArea</code> in Haskell?</p>
<h2 id="existential-types"><a class="header" href="#existential-types">Existential Types</a></h2>
<p>Recall that polymorphic types are also called for-all types. Essentially, the definition of the type is independent of the type parameter. The idea behind for-all types is that we can substitute the type parameter with any other type to give a new type. For example, we know that the <code>id</code> function has type <code>forall a. a -&gt; a</code>. Therefore, we can apply <code>id</code> onto a type, say <code>Int</code>, to give us a new function whose type is <code>Int -&gt; Int</code>.</p>
<p>The type variable <code>a</code> is opaque to whoever defines the term of the polymorphic type. For example, when we define a polymorphic function:</p>
<pre><code class="language-haskell">singleton :: forall. a -&gt; [a]
singleton x = []
</code></pre>
<p>The type of <code>x</code> is just <code>a</code> where we have no idea what <code>a</code> is. Thus, the implementation of <code>singleton</code> cannot make use of any knowledge of what <code>a</code> is because it is just an opaque type variable. In contrast, anyone who <em>uses</em> <code>singleton</code> can <em>decide</em> what type will inhabit <code>a</code>:</p>
<pre><code class="language-haskell">x :: Int
y = singleton @Int x
</code></pre>
<p>As you can see, the caller of <code>singleton</code> can decide to pass in the type <code>Int</code>, and thus will know that the function application <code>singleton @Int x</code> will evaluate to a term of type <code>[Int]</code>.</p>
<p>One question you might ask is, we know that "for all" corresponds to \(\forall\) in mathematics. Are there also \(\exists\) types? The answer is yes! These are known as <em>existential types</em>:
\[\exists\alpha.\tau\]</p>
<p>The idea behind existential types is that there is <em>some</em> type which inhabits the existential type variable to give a new type. For example the type \(\exists\alpha.[\alpha]\) means <em>"some"</em> list of elements. The term <code>[1, 2]</code> can also be treated as having the type \(\exists\alpha.[\alpha]\) because we know that we can let \(\alpha\) be <code>Int</code> and <code>[1, 2]</code> is correctly of type <code>[Int]</code>. Similarly, <code>"abc"</code> can also be treated as having the type \(\exists\alpha.[\alpha]\) because we know that we can let \(\alpha\) be <code>Char</code> and <code>"abc"</code> is correctly of type <code>[Char]</code>. However, <code>[1, 'a']</code> is <em>not</em> of type \(\exists\alpha.[\alpha]\) since we cannot assign any type to \(\alpha\) so that the type of <code>[1, 'a']</code> matches it.</p>
<p>An existential type reverses the relationship of type variable opacity. Recall that the implementer of a polymorphic function sees the type variable as opaque, while the user gets to decide what type inhabits the type variable. For an existential type, the implementer gets to decide what type inhabits the type variable, while the user of an existential type views the type variable as opaque.</p>
<blockquote>
<p><strong>Polymorphism</strong>: implementer <strong>does not know the type, must ignore it</strong>. <strong>User</strong> chooses the type.</p>
<p><strong>Existential types</strong>: implementer <strong>chooses the type</strong>. <strong>User</strong> does not know the type, must ignore it.</p>
</blockquote>
<p>Ideally, this allows us to define a type of lists \([\exists\alpha.\mathtt{HasArea}~\alpha\Rightarrow\alpha]\) (read: a list of elements, each of which are some \(\alpha\) that implements <code>HasArea</code>), however the quantification of the type variable is inside the list constructor; these are called <em>impredicative</em> types. Haskell does not support impredicative types. What can we do now?</p>
<p>What we can try to do is to define a new wrapper type that stores elements of type \(\exists\alpha.\mathtt{HasArea}~\alpha\), like so:</p>
<pre><code class="language-haskell">data HasAreaType = HAT (∃a. HasArea a =&gt; a)
instance HasArea HasAreaType where
    area :: HasAreaType -&gt; Double
    area (HAT x) = area x
</code></pre>
<p>However, perhaps surprisingly given what we've been talking about, Haskell does not even support existential types. What now?</p>
<h2 id="mental-model-for-existential-types"><a class="header" href="#mental-model-for-existential-types">Mental Model for Existential Types</a></h2>
<p>Just like how we have given a mental model for polymorphism, we give a mental model for existential types. Recall that a polymorphic function is a function that receives a type parameter and returns a function that is specialized over the type parameter. For us, let us suppose that a term of an existential type \(\exists\alpha.\tau\) is a pair \((\beta,x)\) such that \(x\) has type \(\tau[\alpha:=\beta]\).</p>
<ul>
<li><code>(Int, [1, 2])</code> is a term of type \(\exists\alpha.[\alpha]\) because <code>[1, 2] :: [Int]</code></li>
<li><code>(Char, "abc")</code> is also a term of type \(\exists\alpha.[\alpha]\) because <code>"abc" :: [Char]</code></li>
</ul>
<p>Therefore, a function on an existential type can be thought of as a function receiving a pair, whose first element is a type, and the second element is corresponding term.</p>
<p>In our example above, the <code>HAT</code> constructor would therefore have type</p>
<pre><code class="language-haskell">HAT :: (∃a. HasArea a =&gt; a) -&gt; HasAreaType
</code></pre>
<p>Using our mental model, we destructure the existential type as a pair:</p>
<pre><code class="language-haskell">HAT :: (a :: *, HasArea a =&gt; a) -&gt; HasAreaType
</code></pre>
<p>Recall <em>currying</em>, where a function over more than one argument is split into a function receiving one parameter and returning a function that receives the rest. We thus curry the <code>HAT</code> constructor like so:</p>
<pre><code class="language-haskell">HAT :: (a :: *) -&gt; HasArea a =&gt; a -&gt; HasAreaType
</code></pre>
<p>Remember what it means for a function that receives a type as a parameter—this is a <strong>polymorphic function</strong>!</p>
<pre><code class="language-haskell">HAT :: forall a. HasArea a =&gt; a -&gt; HasAreaType
</code></pre>
<p>Indeed, <em>polymorphic functions simulate functions over existential types</em>. Let us show more examples of this being the case. For example, the <code>area</code> typeclass method is a function over <em>something that implements <code>HasArea</code></em>, and returns a <code>Double</code>. Therefore, it should have the following function signature:</p>
<pre><code class="language-haskell">area :: (∃a. HasArea a =&gt; a) -&gt; Double
</code></pre>
<p>However, we know that we can curry the existential type to get a polymorphic function, allowing us to recover the original type signature!</p>
<pre><code class="language-haskell">area :: forall a. HasArea a =&gt; Double
</code></pre>
<p>In another example, we know the <code>EqExpr</code> constructor from the previous chapter is constructed by providing any two expressions that are amenable to equality comparisons:</p>
<pre><code class="language-haskell">EqExpr :: (∃a. Eq a =&gt; (Expr a, Expr a)) -&gt; Expr Bool
</code></pre>
<p>Again, with currying, we recover our original type signature for <code>EqExpr</code>:</p>
<pre><code class="language-haskell">EqExpr :: forall a. Eq a =&gt; Expr a -&gt; Expr a -&gt; Expr Bool
</code></pre>
<p>With this in mind, we can now properly create our <code>HAT</code> constructor and use the <code>HasAreaType</code> type to put shapes, rooms and houses in a single list!</p>
<pre><code class="language-haskell">data HasAreaType where
    HAT :: forall a. HasArea a =&gt; a -&gt; HasAreaType
instance HasArea HasAreaType where
    area :: HasAreaType -&gt; area
    area (HAT x) = area x

x = Triangle 2 3
y = R "bedroom" (Rectangle 3 4)
z = H [y]

ls :: [HasAreaType]
ls = [HAT x, HAT y, HAT z]

d = totalArea ls -- 27
</code></pre>
<h2 id="the-antipattern"><a class="header" href="#the-antipattern">The Antipattern</a></h2>
<p>Notice that we went through this entire journey just so that we can put these different types in a list, which is so that we can compute the total area. However, in this case, we can actually just save the trouble and do this:</p>
<pre><code class="language-haskell">x = Triangle 2 3
y = R "bedroom" (Rectangle 3 4)
z = H [y]

ls :: [Double]
ls = [area x, area y, area z]

d = sum ls -- 27
</code></pre>
<p>Of course, there are definitely use cases for existential types like <code>HasAreaType</code>. We frequently call these <em>abstract data types</em>. However, these are not commonly used. In fact, not knowing what existential types are should <strong>not</strong> affect your understanding of type classes and polymorphic types. In addition, encoding existential types as pairs is <em>very handwave-y</em> and is not even supported in Haskell. The closest analogue of real-world existential types is <em>dependent pair types</em> or \(\Sigma\)-<em>types</em>, which is different to the existential types we have seen. The demonstration that we have seen so far only serves as a mental model for why we write polymorphic functions were the return type does not depend on the type parameters.</p>
<p>The key point is that we should <em>not</em> immediately attempt to replicate OO design patterns in FP just because they are familiar. Trying to skirt around the restrictions of the type system is, generally, not a good idea (there are cases where that is useful, but such scenarios occur exceedingly infrequently).</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h1>
<h3 id="question-1-2"><a class="header" href="#question-1-2">Question 1</a></h3>
<p>Without using GHCI, determine the types of the following expressions:</p>
<ol>
<li><code>1 + 2 * 3</code></li>
<li><code>(show . )</code></li>
<li><code>( . show)</code></li>
<li><code>\ (a, b) -&gt; a == b</code></li>
</ol>
<h3 id="question-2-2"><a class="header" href="#question-2-2">Question 2</a></h3>
<p>You are given the following untyped
program:</p>
<pre><code class="language-python">type Tree[a] = Empty | TreeNode[a]
type List[a] = Empty | ListNode[a]

@dataclass
class Empty:
    def to_list(self):
        return []

@dataclass
class ListNode[a]:
    head: a
    tail: List[a]
    def to_list(self):
        return [self.head] + self.tail.to_list()

@dataclass
class TreeNode[a]:
    l: Tree[a]
    v: a
    r: Tree[a]
    def to_list(self):
      return self.l.to_list() + [self.v] + self.r.to_list()

def flatten(ls):
    if not ls: return []
    return ls[0].to_list() + flatten(ls[1:])

ls = [ListNode(1, Empty()), TreeNode(Empty(), 2, Empty())]
ls2 = flatten(ls)
</code></pre>
<p>Fill in the type signatures of all the methods and functions and the
type annotations for the <code>ls</code> and <code>ls2</code> variables so
that the type-checker can verify that the program is type-safe. The
given type annotations should be general enough such that defining a new
class and adding an instance of it to <code>ls</code> requires no change
in type annotation:</p>
<pre><code class="language-python">@dataclass
class Singleton[a]:
  x: a
  def to_list(self):
    return [self.x]
    
ls = [ListNode(1, Empty()), TreeNode(Empty(), 2, Empty()),
  Singleton(3)]
# ...
</code></pre>
<h3 id="question-3-2"><a class="header" href="#question-3-2">Question 3</a></h3>
<p>Defined below is a data type describing clothing sizes.</p>
<pre><code class="language-haskell">data Size = XS | S | M | L | XL
    deriving (Eq, Ord, Show, Bounded, Enum)
</code></pre>
<p>Proceed to define the following functions:</p>
<ul>
<li><code>smallest</code> produces the smallest size</li>
<li><code>descending</code> produces a list of all the sizes from large to small</li>
<li><code>average</code> produces the average size of two sizes; in case there isn't an exact middle between two sizes, prefer the smaller one</li>
</ul>
<p>Example runs follow.</p>
<pre><code class="language-haskell">ghci&gt; smallest :: Size
XS
ghci&gt; descending :: [Size]
[XL, L, M, S, XS]
ghci&gt; average XS L
S
</code></pre>
<p>However, take note that your functions must <em>not</em> only work on the <code>Size</code> type. Some of these functions can be implemented with the typeclass methods that <code>Size</code> derives. You should implement your solution based on these methods so that your function can be as general as possible. In particular, we should be able to define a new type which derives these typeclasses, and all your functions should still work on them as we should expect. An example is as follows:</p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| data Electromagnet = Radio | Micro | IR | Visible | UV | X | Gamma
ghci|    deriving (Eq, Ord, Show, Bounded, Enum)
ghci| :}
ghci&gt; smallest :: Electromagnet
Radio
ghci&gt; descending :: [Electromagnet]
[Gamma, X, UV, Visible, IR, Micro, Radio]
ghci&gt; average Gamma Radio
Visible
</code></pre>
<h3 id="question-4-2"><a class="header" href="#question-4-2">Question 4</a></h3>
<p>Implement the mergesort algorithm
as a function <code>mergesort</code>. Ignoring time complexity, your
algorithm should split the list in two, recursively mergesort each half,
and merge the two sorted sublists together. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; mergesort [5,2,3,1,2]
[1,2,2,3,5]
ghci&gt; mergesort "edcba"
"abcde"
</code></pre>
<h3 id="question-5-2"><a class="header" href="#question-5-2">Question 5</a></h3>
<p>Recall <a href="typeclasses/sections/../../types/sections/algebraic_data_types.html">Chapter 2.3 (Types#Algebraic Data Types)</a> where we defined an <code>Expr</code> GADT.</p>
<pre><code class="language-haskell">data Expr a where
  LitNumExpr :: Int -&gt; Expr Int
  AddExpr :: Expr Int -&gt; Expr Int -&gt; Expr Int
  -- ...

eval :: Expr a -&gt; a
eval (LitNumExpr x) = x
eval (AddExpr e1 e2) = eval e1 + eval e2
  -- ... 
</code></pre>
<p>Now that we have learnt typeclasses, let us attempt to <em>separate</em> each
constructor of <code>Expr</code> as <em>individual types</em>, while still
preserving functionality; the purpose of this being to keep the
<code>Expr</code> type modular and extensible:</p>
<pre><code class="language-haskell">data LitNumExpr = -- ...
data AddExpr = -- ...
</code></pre>
<p>while still being able to apply <code>eval</code> on any of those
expressions:</p>
<pre><code class="language-haskell">-- 2 + 3
ghci&gt; eval (AddExpr (LitNumExpr 2) (LitNumExpr 3))
5
-- if 2 == 1 + 1 then 1 + 2 else 4
ghci&gt; eval (CondExpr 
  (EqExpr (LitNumExpr 2) 
          (AddExpr (LitNumExpr 1) (LitNumExpr 1))) 
  (AddExpr (LitNumExpr 1) (LitNumExpr 2))
  (LitNumExpr 4))
3
</code></pre>
<p>Proceed to define all these different types of expressions and their
corresponding implementations for <code>eval</code>:</p>
<ul>
<li><code>LitNumExpr</code>. A literal integer, such as
<code>LitNumExpr 3</code>.</li>
<li><code>AddExpr</code>. An addition expression in the form of
\(e_1 + e_2\), such as
<code>AddExpr (LitNumExpr 1) (LitNumExpr 2)</code> representing
\(1 + 2\)</li>
<li><code>EqExpr</code>. An equality comparison expression in the form of
\(e_1 = e_2\), such as <code>Eq (LitNumExpr 1) (LitNumExpr 2)</code>
representing \(1 = 2\)</li>
<li><code>CondExpr</code>. A conditional expression in the form of
\(\text{if }e\text{ then } e_1 \text{ else }e_2\)</li>
</ul>
<h3 id="question-6-2"><a class="header" href="#question-6-2">Question 6</a></h3>
<p>In Python, a <em>sequence</em> is a data structure that has a <em>length</em> and a way to obtain elements from it by integer indexing. Strings, ranges, tuples and lists are all sequences in Python:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; len([1, 2, 3])
3
&gt;&gt;&gt; 'abcd'[3]
'c'
</code></pre>
<p>Our goal is to create something similar in Haskell. However, instead of loosely defining what a <em>sequence</em> is, like Python does, we shall create a typeclass called <code>Sequence</code> and allow all types that implements these methods to become a sequence formally (at least, to the compiler)!</p>
<p>Proceed to define a typeclass called <code>Sequence</code> with two methods:</p>
<ul>
<li><code>(@)</code> does indexing, so <code>ls @ i</code> is just like <code>ls[i]</code> in Python; if the index <code>i</code> is out of bounds, the method should panic (you can let it return <code>undefined</code> in this case)</li>
<li><code>len</code> produces the length of the sequence</li>
<li><code>prepend</code> prepends an element onto the sequence</li>
</ul>
<p>Then define instances for <code>[a]</code> to be a sequence over <code>a</code>'s! Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; x :: [Int] = [1, 2, 3, 4]
ghci&gt; x @ 2
3
ghci&gt; x @ 4
-- some error...
ghci&gt; len x
4
ghci&gt; x `prepend` 5
[5, 1, 2, 3, 4]
ghci&gt; len "abcde"
5
ghci&gt; "abcde" @ 0
'a'
</code></pre>
<p>What's really neat about using typeclasses instead of defining a separate <code>Sequence</code> data type is that <em>any</em> type that conforms to the specification in our <code>Sequence</code> typeclass can become a valid sequence. For example, one sequence we might want is a sequence of <code>()</code> (the unit type, which only has one constructor with no arguments, and terms of this type signify "<em>nothing significant</em>", similar to <code>void</code> in other languages).<sup class="footnote-reference"><a href="#1">1</a></sup> Because each element of such a sequence carries no information, instead of creating such a sequence using a list, i.e. a list of type <code>[()]</code>, we can instead use <code>Int</code> as our sequence!</p>
<pre><code class="language-haskell">ghci&gt; x :: Int = 4
ghci&gt; x @ 2
()
ghci&gt; x @ 4
-- some error...
ghci&gt; len x
4
ghci&gt; (x `prepend` 5) @ 4
()
</code></pre>
<p>Proceed to define a typeclass instance for <code>Int</code> such that <code>Int</code>s are sequences of <code>()</code>.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This is an extremely contrived example. The main point we are driving home is that we can create very concise implementations of data structures based on domain-specific knowledge.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="railways"><a class="header" href="#railways">Railways</a></h1>
<p>One of the core ideas in FP is <em>composition</em>, i.e. that to "do one computation after the other" is to <em>compose</em> these computations. In mathematics, function composition is straightforward, given by:
\[(g\circ f)(x) = g(f(x)) \]</p>
<p>That is, \(g\circ f\) is the function "\(g\) <em>after</em> \(f\)", which applies \(f\) onto \(x\), <em>and then</em> apply \(g\) on the result.</p>
<p>In an ideal world, composing functions is as straightforward as we have described.</p>
<pre><code class="language-python">def add_one(x: int) -&gt; int:
    return x + 1
def double(x: int) -&gt; int:
    return x * 2
def div_three(x: int) -&gt; float:
    return x / 3

print(div_three(double(add_one(4))))
</code></pre>
<p>However, things are rarely perfect. Let us take the following example of an application containing users, with several data structures to represent them.</p>
<p>First, we describe the <code>User</code> and <code>Email</code> classes:</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass
class Email:
    name: str
    domain: str

@dataclass
class User:
    username: str
    email: Email
    salary: int | float
</code></pre>
<p>Now, we want to be able to parse user information that is provided as a string. However, note that this parsing may <em>fail</em>, therefore we raise exceptions if the input string cannot be parsed as the desired data structure.</p>
<pre><code class="language-python">def parse_email(s: str) -&gt; Email:
    if '@' not in s:
        raise ValueError
    s = s.split('@')
    if len(s) != 2 or '.' not in s[1]:
        raise ValueError
    return Email(s[0], s[1])

def parse_salary(s: str) -&gt; int | float:
    try:
        return int(s)
    except:
        return float(s) # if this fails and raises an exception,
                        # then do not catch it
</code></pre>
<p>And to use these functions, we have to ensure that every program point that uses them must be wrapped in a <code>try</code> and <code>except</code> clause:</p>
<pre><code class="language-python">def main():
    n = input('Enter name: ')
    e = input('Enter email: ')
    s = input('Enter salary: ')
    try:
        print(User(n, parse_email(e), parse_salary(s)))
    except:
        print('Some error occurred')
</code></pre>
<p>As you can see, exceptions are being thrown everywhere. Generally, it is hard to keep track of which functions raise/handle execptions, and also hard to compose exceptional functions! Worse still, if the program is poorly documented (as is the case for our example), no one actually knows that <code>parse_salary</code> and <code>parse_email</code> will raise exceptions!</p>
<p>There is a better way to do this—by using the <em>railway pattern</em>! Let us write the equivalent of the program above with idiomatic Haskell. First, the data structures:</p>
<pre><code class="language-haskell">data Email = Email { emailUsername :: String
                   , emailDomain   :: String }
  deriving (Eq, Show)

data Salary = SInt Int 
            | SDouble Double
  deriving (Eq, Show)

data User = User { username   :: String
                 , userEmail  :: Email
                 , userSalary :: Salary }
  deriving (Eq, Show)
</code></pre>
<p>Now, some <em>magic</em>. No exceptions are raised in any of the following functions (which at this point, might look like <em>moon runes</em>):</p>
<pre><code class="language-haskell">parseEmail :: String -&gt; Maybe Email
parseEmail email = do
    guard $ '@' `elem` email &amp;&amp; length e == 2 &amp;&amp; '.' `elem` last e
    return $ Email (head e) (last e)
  where e = split '@' email

parseSalary :: String -&gt; Maybe Salary
parseSalary s = 
  let si = SInt &lt;$&gt; readMaybe s
      sf = SDouble &lt;$&gt; readMaybe s
  in  si &lt;|&gt; sf
</code></pre>
<p>And the equivalent of <code>main</code> in Haskell is shown below.<sup class="footnote-reference"><a href="#1">1</a></sup> Although not apparent at this point, we are <em>guaranteed</em> that no exceptions will be raised from using <code>parseEmail</code> and <code>parseSalary</code>.</p>
<pre><code class="language-haskell">main :: IO ()
main = do
  n &lt;- input "Enter name: "
  e &lt;- input "Enter email: "
  s &lt;- input "Enter salary: "
  let u = User n &lt;$&gt; parseEmail e &lt;*&gt; parseSalary s
  putStrLn $ maybe "Some error occurred" show u
</code></pre>
<p>How does this work? The core idea behind the railway pattern is that functions are <em>pure</em> and <em>statically-typed</em>, therefore, all functions must make <em>explicit</em> the kind of <em>effects</em> it wants to produce. For this reason, any "exceptions" that it could raise must be <em>explicitly</em> stated in its type signature by returning the appropriate term whose type represents some <em>notion of computation</em>. Then, any other function that uses these functions with notions of computation must <em>explicitly</em> handle those notions of computations appropriately.</p>
<p>In this chapter, we describe some of the core facets of the railway pattern:</p>
<ul>
<li>What is it?</li>
<li>What data structures and functions can we use to support this?</li>
<li>How do we write programs with the railway pattern?</li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Wait... is this an <em>imperative</em> program in Haskell?</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="contextnotions-of-computation"><a class="header" href="#contextnotions-of-computation">Context/Notions of Computation</a></h1>
<p>Many popular languages lie to you in many ways. An example is what we have seen earlier, where Python functions do not document exceptions in its type signature, and must be separately annotated as a docstrong to denote as such. This is not including the fact that Python type annotations are not enforced at all.</p>
<pre><code class="language-python">def happy(x: int) -&gt; int:
    raise Exception("sad!")
</code></pre>
<p>This is not unique to dynamically-typed languages like Python. This is also the case in Java. In Java, checked exceptions must be explicitly reported in a method signature. However, <em>unchecked exceptions</em>, as named, do not need to be reported and are not checked by the Java compiler. That is not to mention other possible "lies", for example, it is possible to return nothing (<code>null</code>) even if the method's type signature requires it to return "<em>something</em>":</p>
<pre><code class="language-java">class A {
    String something() {
        return null;
    }
}
</code></pre>
<p>We can't lie in Haskell. In the first place, we <em>shouldn't</em> lie in general. What now?</p>
<p>Instead, what we can do is to create the right data structures that represent what is <em>actually</em> returned by each function! In the Python example <code>happy</code>, what we really wanted to return was <em>either</em> an <code>int</code>, <em>or</em> an exception. Let us create a data structure that represents this:</p>
<pre><code class="language-haskell">data Either a b = Left a  -- sad path
                | Right b -- happy path
</code></pre>
<p>Furthermore, instead of returning <code>null</code> like in Java, we can create a data structure that represents <em>either</em> something, <em>or</em> nothing:</p>
<pre><code class="language-haskell">data Maybe a = Just a  -- happy path
             | Nothing -- sad path
</code></pre>
<p>This allows the <code>happy</code> and <code>something</code> functions to be written safely in Haskell as:</p>
<pre><code class="language-haskell">happy :: Either String Int
happy = Left "sad!"

something :: Maybe String
something = Nothing
</code></pre>
<p>The <code>Maybe</code> and <code>Either</code> types act as <em>contexts</em> or <em>notions of computation</em>:</p>
<ul>
<li><code>Maybe a</code>—an <code>a</code> or nothing</li>
<li><code>Either a b</code>—either <code>a</code> or <code>b</code></li>
<li><code>[a]</code>—a list of possible <code>a</code>s (nondeterminism)</li>
<li><code>IO a</code>—an I/O action resulting in <code>a</code></li>
</ul>
<p>These types allow us to accurately describe what our functions are actually doing! Furthermore, these types "wrap" around a type, i.e. For instance, <code>Maybe</code>, <code>Either a</code> (for a fixed <code>a</code>), <code>[]</code> and <code>IO</code> all have kind <code>* -&gt; *</code>, and essentially provide some <em>context</em> around a type.</p>
<p>Using these types makes programs clearer! For example, we can use <code>Maybe</code> to more accurately describe the <code>head</code> function, which may return nothing if the input list is empty.</p>
<pre><code class="language-haskell">head' :: [a] -&gt; Maybe a
head' [] = Nothing
head' (x : _) = x
</code></pre>
<p>Alternatively, we can express the fact that dividing by zero should yield an error:</p>
<pre><code class="language-haskell">safeDiv :: Int -&gt; Int -&gt; Either String Int
safeDiv x 0 = Left "Cannot divide by zero!"
safediv x y = Right $ x `div` y
</code></pre>
<p>These data structures allow our functions to act as branching railways!</p>
<pre><code>        head'                           safeDiv

        ┏━━━━━ Just a                   ┏━━━━━ Right Int      -- happy path
[a] ━━━━┫                  Int, Int ━━━━┫
        ┗━━━━━ Nothing                  ┗━━━━━ Left String    -- sad path
</code></pre>
<p>This is the inspiration behind the name "railway pattern", which is the pattern of using algebraic data types to describe the different possible outputs from a function! This is, in fact, a <strong>natural consequence</strong> of purely functional programming. Since functions must be pure, it is not possible to define functions that opaquely cause side-effects. Instead, function signatures must be made <em>transparent</em> by using the right data structures.</p>
<p>What, then, is the <em>right</em> data structure to use? It all depends on the notion of computation that you want to express! If you want to produce nothing in some scenarios, use <code>Maybe</code>. If you want to produce something or something else (like an error), use <code>Either</code>, so on and so forth!</p>
<p>However, notice that having <em>functions as railways</em> is not very convenient... with the non-railway (and therefore potentially exceptional) <code>head</code> function, we could compose <code>head</code> with itself, i.e. <code>head . head :: [[a]] -&gt; a</code> is perfectly valid. However, we <em>cannot</em> compose <code>head'</code> with itself, since <code>head'</code> returns a <code>Maybe a</code>, which cannot be an argument to <code>head'</code>.</p>
<pre><code>    ┏━━━━━      ?          ┏━━━━━
━━━━┫        &lt;-----&gt;   ━━━━┫
    ┗━━━━━                 ┗━━━━━
</code></pre>
<p>How can we make the railway pattern <em>ergonomic</em> enough for us to want to use them?</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="category-theory"><a class="header" href="#category-theory">Category Theory</a></h1>
<p>We can borrow some ideas from a branch of mathematics, known as <em>Category Theory</em>, to improve the ergonomics of these structures. Part of the reason why we are able to do so is that all the types that we have described have kind <code>* -&gt; *</code>, i.e. they "wrap" around another type. As such, they should be able to behave as <em>functors</em>, which we will formalize shortly.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>However, before we even talk about what a functor is and how the data structures we have described are functors, we first need to describe what category theory is. Intuitively, most theories (especially the algebraic ones) study mathematical structures that abstract over things; <em>groups</em> are abstractions of <em>symmetries</em>, and <em>geometric spaces</em> are abstractions of <em>space</em>. Category theory takes things one step further and studies <em>abstraction itself</em>.</p>
<p>Effectively the goal of category theory is to observe similar underlying structures between collections of mathematical structures. What is nice about this is that a result from category theory generalizes to all other theories that fit the structure of a category. As such it should be no surprise that computation can be, and is, studied through the lens of category theory too!</p>
<p>On the other hand, the generality of category theory also makes it incredibly abstract and difficult to understand—this is indeed the case in our very first definition. As such, I will, as much as possible, show you "concrete" examples of each definition and reason about them if I can. With this in mind, let us start with the definition of a category, as seen in many sources.</p>
<blockquote>
<p><strong>Definition (Category)</strong>. A category \(\mathcal{C}\) consists of</p>
<ul>
<li>a collection of <em>objects</em> \(X\), \(Y\), \(Z\), ... denoted \(\text{ob}(\mathcal{C})\)</li>
<li>a collection of <em>morphisms</em>, \(f, g, h, \dots\), denoted \(\text{mor}(\mathcal{C})\)</li>
</ul>
<p>so that:</p>
<ul>
<li>Each morphism has specified <em>domain</em> and <em>codomain</em> objects; when we write \(f: X \to Y\), we mean that the morphism \(f\) has domain \(X\) and codomain \(Y\).</li>
<li>Each object has an <em>identity morphism</em> \(1_X:X\rightarrow X\).</li>
<li>For any pair of morphisms \(f\), \(g\) with the codomain of \(f\) equal to the domain of \(g\) (i.e. \(f\) and \(g\) are composable), there exists a <em>composite morphism</em> \(g \circ f\) whose domain is equal to the domain of \(f\) and whose codomain is equal to the codomain of \(g\), i.e.
\[f: X\rightarrow Y, ~~~g: Y \rightarrow Z ~~~~~ \rightsquigarrow ~~~~~ g\circ f:X\rightarrow Z\]</li>
</ul>
<p>Composition of morphisms is subject to the two following axioms:</p>
<ul>
<li><em>Unity</em>. For any \(f: X \rightarrow Y\), \(f\circ1_X = 1_Y \circ f = f\).</li>
<li><em>Associativity</em>. For any composable \(f\), \(g\) and \(h\), \((h\circ g)\circ f = h \circ (g \circ f)\).</li>
</ul>
</blockquote>
<p>This, of course, is incredibly abstract and quite hard to take in. Instead, let us use a simpler definition to get some "ideas" across:</p>
<blockquote>
<p>A category \(\mathcal{C}\) consists of</p>
<ul>
<li>Dots \(X\), \(Y\), \(Z\)</li>
<li>Arrows between dots \(f, g, h, \dots\)</li>
</ul>
<p>such that:</p>
<ul>
<li>Joining two arrows together gives another arrow</li>
<li>There is a unique way to join three arrows together</li>
<li>Every dot has an arrow pointing to itself, such that joining it with any other arrow \(f\) just gives \(f\)</li>
</ul>
</blockquote>
<p>Here is an example category:</p>
<pre><code>    f
A ----&gt; B
 \      |
  \     | g
 h \    |
    \   v 
     -&gt; C
</code></pre>
<p>Here we have three objects <code>A</code> <code>B</code> and <code>C</code>, and the morphisms <code>f: A -&gt; B</code>, <code>g: B -&gt; C</code> and <code>h: A -&gt; C</code>. The identity morphisms for the objects are omitted for simplicity. Note that the composition of <code>f</code> and <code>g</code> exists in the category (assume in the example <code>g . f == h</code>).</p>
<p>Why do we care? Well, it turns out that types and functions in Haskell assemble into a category \(\mathcal{H}\)!<sup class="footnote-reference"><a href="#2">2</a></sup></p>
<ul>
<li>Objects in \(\mathcal{H}\) are types like <code>Int</code>, <code>String</code> etc.</li>
<li>Morphisms in \(\mathcal{H}\) are functions like <code>(+1)</code> and <code>head</code></li>
</ul>
<p>Furthermore,</p>
<ul>
<li>The composition of two functions with <code>(.)</code> is also a function</li>
<li>Every type has the identity function <code>id x = x</code>, where for all functions <code>f</code>, <code>id . f</code> = <code>f . id</code> = <code>f</code></li>
</ul>
<pre><code>    show
Int ---&gt; String
   \      |
    \     | head
     \    |
      \   v 
       -&gt; Char
</code></pre>
<p>The above is a fragment of \(\mathcal{H}\). We can see that <code>show</code> is a function from <code>Int</code> to <code>String</code>, and <code>head</code> is a function from <code>String</code> to <code>Char</code>. In addition, the function <code>head . show</code> is a function from <code>Int</code> to <code>Char</code>! Furthermore, all of these types have the identity function <code>id</code> which we omit in the diagram.</p>
<p><mark>Still, who cares?</mark></p>
<p>Because the types in Haskell assemble into categories, let's see if there is anything that category theory has to tell us.</p>
<h1 id="functors"><a class="header" href="#functors">Functors</a></h1>
<p>In mathematics, the relationships between objects are frequently far more interesting
than the objects themselves. Of course, we do not just focus on <em>any</em> relationship
between objects, but of keen interest, the <em>structure preserving</em> relationships between
them, such as group homomorphisms that preserve group structures, or monotonic functions
between preordered sets that preserve ordering. In category theory, <em>functors</em> are
maps between categories that preserve the structure of the domain category,
especially the compositions and identities.</p>
<blockquote>
<p>Let \(\mathcal{C}\) and \(\mathcal{D}\) be categories. A (<em>covariant</em>)
<em>functor</em> \(F: \mathcal{C} \rightarrow \mathcal{D}\) consists of:</p>
<ul>
<li>An object \(F(C) \in \text{ob}(\mathcal{D})\) for each object \(C \in \text{ob}(\mathcal{C})\)<sup class="footnote-reference"><a href="#3">3</a></sup>.</li>
<li>A morphism \(F(f): F(C) \rightarrow F(D) \in \text{mor}(\mathcal{D})\) for each morphism \(f: C\rightarrow D \in \text{mor}(\mathcal{C})\).</li>
</ul>
<p>subject to the two <em>functoriality axioms</em>:</p>
<ul>
<li>For any composable pair of morphisms \(f, g\in\text{mor}(\mathcal{C})\), \(F(g)\circ F(f) = F(g\circ f)\).</li>
<li>For each \(C \in \text{ob}(\mathcal{C})\), \(F(1_C)=1_{F(C)}\).</li>
</ul>
<p>in other words, functors map dots and arrows between two categories, preserving composition and identities.</p>
</blockquote>
<pre><code>    f                          F(f)
A ----&gt; B                F(A) ----&gt; F(B)
 \      |        F            \      |
  \     | g   ======&gt;          \     | F(g)
 h \    |                  F(h) \    |
    \   v                        \   v
     -&gt; C                         &gt; F(C)
</code></pre>
<p>What's so special about categories and functors, especially since categories are so abstract and have so little requirements for being one? This is precisely the beauty of category theory—it is abstract and simple enough for many things to assemble into one, yet the requirement of associativity and unity of the composition of morphisms and identities make things that assemble into categories behave in the <em>most obvious way</em>!</p>
<h2 id="types-as-functors"><a class="header" href="#types-as-functors">Types as Functors</a></h2>
<p>There are two parts two a functor in \(\mathcal{H}\):</p>
<ul>
<li>Maps types to types</li>
<li>Maps functions to functions</li>
</ul>
<p>We already know that the <code>[]</code> type constructor maps <code>a</code> to <code>[a]</code> for all <code>a</code> in \(\mathcal{H}\).
How do we map functions <code>f :: a -&gt; b</code> to <code>F(f) :: [a] -&gt; [b]</code> in the <em>most obvious way</em>, i.e. in a way that preserves function composition and identities?</p>
<p>It is simple! Recall the <code>map</code> function:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; def f(x: int) -&gt; str:
...     return str(x + 2)
&gt;&gt;&gt; f(3)
'5'
&gt;&gt;&gt; list(map(f, [3]))
['5']
</code></pre>
<pre><code class="language-haskell">ghci&gt; :{
ghci| f :: Int -&gt; String
ghci| f x = show (x + 2)
ghci| :}
ghci&gt; f 3
"5"
ghci&gt; :t map f
map f :: [Int] -&gt; [String]
ghci&gt; map f [3]
["5"]
</code></pre>
<p><code>map</code> preserves composition:</p>
<pre><code class="language-haskell">ghci&gt; (map (*2) . map (+3)) [1, 2, 3]
[8, 10, 12]
ghci&gt; map ((*2) . (+3)) [1, 2, 3]
[8, 10, 12]
</code></pre>
<p><code>map</code> also preserves identities:</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications
ghci&gt; map (id @Int) [1, 2, 3]
[1, 2, 3]
ghci&gt; id @[Int] [1, 2, 3]
[1, 2, 3]
</code></pre>
<p>That is great! <code>[]</code> and <code>map</code> form a functor over \(\mathcal{H}\), which means that we no longer have to worry if someone wants to work in the <code>[]</code> context. This is because if we have functions from <code>a</code> to <code>b</code>, we can <em>lift</em> it into a function from <code>[a]</code> to <code>[b]</code> using <code>map</code> and it will behave in the most obvious way!</p>
<p>Can we say the same about <code>Maybe</code> and the other type constructors we saw earlier? Fret not! Let's see how we can define a function for <code>Maybe</code> so that it can behave as a functor as well! Let's look at <code>maybeMap</code>:</p>
<pre><code class="language-haskell">maybeMap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
maybeMap _ Nothing = Nothing
maybeMap f (Just x) = Just $ f x
</code></pre>
<p><code>maybeMap</code> also preserves composition and identities!</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications
ghci&gt; (maybeMap (*2) . maybeMap (+3)) (Just 1)
Just 8
ghci&gt; maybeMap ((*2) . (+3)) (Just 1)
Just 8
ghci&gt; maybeMap (id @Int) (Just 1)
Just 1
ghci&gt; id @(Maybe Int) (Just 1)
Just 1
</code></pre>
<p>Like we have seen before, all of these types have some <code>map</code>-like method that allows us to lift functions into its context; however, they all have their type-specific implementations. This is the reason why Haskell has a <code>Functor</code> typeclass!</p>
<pre><code class="language-haskell">class Functor (f :: * -&gt; *) where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b

instance Functor [] where
    fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]
    fmap _ [] = []
    fmap f (x : xs) = f x : fmap f xs

instance Functor Maybe where
    fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
    fmap _ Nothing = Nothing
    fmap f (Just x) = Just $ f x

instance Functor (Either a) where -- `a`, a.k.a. sad path is fixed!
    fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c
    fmap _ (Left x) = Left x
    fmap f (Right x) = Right $ f x
</code></pre>
<p>The key point of <code>[]</code>, <code>Maybe</code>, <code>Either</code> etc being functors is as such:</p>
<blockquote>
<p>Given any functor <code>F</code> and a function <code>f</code> from <code>A</code> to <code>B</code>, <code>fmap f</code> is a function from <code>F A</code> to <code>F B</code> and <strong>behaves as we should expect</strong>.</p>
</blockquote>
<pre><code>       f
  A ------&gt; B
       |
       |
       v
F A ------&gt; F B
    fmap f
</code></pre>
<p>Whenever we are presented with a situation that requires us to map a function <code>f :: A -&gt; B</code> over a functor <code>fa :: F A</code>, just use <code>fmap f fa</code> to give us some <code>fb :: F B</code>. There is no need to unwrap the <code>A</code> from the <code>F A</code> (which may not be possible), apply <code>f</code> then wrap it back in the <code>F</code>; just use <code>fmap</code>!</p>
<p>A simple example is as follows. Suppose we have our <code>head'</code> function that returns a <code>Maybe a</code>, as we have defined earlier. A possible program that we could write that operates on the result of <code>head'</code> is the following:</p>
<pre><code class="language-haskell">ls = [1, 2, 3]
x = head' ls
y = case x of 
    Just z -&gt; Just $ z + 1
    Nothing -&gt; Nothing
</code></pre>
<p>This <code>case</code> expression is actually just boilerplate and is not idiomatic! The <code>Maybe</code>-specific definition of <code>fmap</code> already handles this, therefore, we can re-write this program much more simply as such:</p>
<pre><code class="language-haskell">ls = [1, 2, 3]
x = head' ls
y = fmap (+1) x
</code></pre>
<h2 id="category-theory-and-functional-programming"><a class="header" href="#category-theory-and-functional-programming">Category Theory and Functional Programming</a></h2>
<p>Although we introduced some formalisms of category theory, rest assured that category theory is <strong>not the main point</strong> of this chapter. Instead, category theory <em>inspires</em> tools that support <em>commonly-used programming patterns</em> backed by <em>well-defined theoretical notions</em>. Therefore, when we say that a type is a functor, not only do we mean that it has an <code>fmap</code> definition, we also mean that this definition of <code>fmap</code> obeys well-understood laws (in the case of functors, <code>fmap</code> preserves compositions and identities) and you can use it assuredly.</p>
<p>That being said, we now have a very powerful tool, <code>fmap</code>, that allows us to perform computations in context. What other operations might we need to make the railway pattern more ergonomic?</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>We do not cover category theory in too much detail since it is not <em>required</em> for functional programming, although an appreciation of it can help with understanding. For a more detailed walkthrough of the connections between functional programming and category theory, see my <a href="https://yongqi.foo/blog/posts/monads/">article on category theory</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Not really... due to the laziness of Haskell and functions like <code>seq</code>, the types and functions in Haskell do not actually assemble in to a category. However, just to put some ideas across, we shall assume that they do.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>We abuse the notation of set membership here. It is not necessary for the collections of objects and morphisms of a category to be sets, as is the case for the category of sets.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="applicative-functors"><a class="header" href="#applicative-functors">Applicative Functors</a></h1>
<p>What if we had 2 (or more) parallel railways and want to merge them? For example, by using <code>head</code>, we can easily retrieve the elements of the list and combine them together in whatever manner we wish:</p>
<pre><code>        head         (+)
[Int] -------&gt; Int ━━━┓
                      ┣━━━ Int
[Int] -------&gt; Int ━━━┛
        head
</code></pre>
<pre><code class="language-haskell">x, y, z :: Int
x = head [1, 2, 3]
y = head [4, 5, 6]
z = x + y -- 5
</code></pre>
<p>However, when we are using <code>head'</code>, combining them is not so easy!</p>
<pre><code>       head'               ???
[Int] -------&gt; Maybe Int ━━━┓
                            ┣━━━ ???
[Int] -------&gt; Maybe Int ━━━┛
       head'
</code></pre>
<pre><code class="language-haskell">x, y :: Maybe Int
x = head' [1, 2, 3]
y = head' [4, 5, 6]
z = x + y -- ???
</code></pre>
<p>As a first attempt, let us try mapping <code>(+)</code> onto <code>x</code>:</p>
<pre><code class="language-haskell">x, y :: Maybe Int
x = head' [1, 2, 3]
y = head' [4, 5, 6]

f :: Maybe (Int -&gt; Int)
f = fmap (+) x
</code></pre>
<p>The question now is, how do we apply <code>f :: Maybe (Int -&gt; Int)</code> above onto <code>y :: Maybe Int</code>?</p>
<h2 id="applicatives"><a class="header" href="#applicatives">Applicatives</a></h2>
<p>If a functor <code>f</code> has the ability to apply <code>f (a -&gt; b)</code> onto a <code>f a</code> to give an <code>f b</code>, then it is an <em>applicative functor</em>, which has the same laws of a <em>(lax-) closed (lax-) monoidal functor</em> in category theory. Although we could give the formal definition of these, it is quite a lot to unpack, and not necessary for understanding how to use them. Instead, let us directly show the <code>Applicative</code> typeclass and some <em>laws</em> that govern these typeclass methods.</p>
<pre><code class="language-haskell">class Functor f =&gt; Applicative f where
    -- pure computation in context
    pure :: a -&gt; f a 
    -- function application in context
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>These methods are subject to:</p>
<ul>
<li>Identity: <code>pure id &lt;*&gt; v</code> = <code>v</code></li>
<li>Homomorphism: <code>pure f &lt;*&gt; pure x</code> = <code>pure (f x)</code></li>
<li>Interchange: <code>u &lt;*&gt; pure y</code> = <code>pure ($ y) &lt;*&gt; u</code></li>
<li>Composition: <code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w</code> = <code>u &lt;*&gt; (v &lt;*&gt; w)</code></li>
</ul>
<p>The four laws above, again, govern <code>Applicatives</code> to behave in the obvious way. However, as we shall see, there is more than one <em>obvious way</em>, therefore, whenever you're using instances of <code>Functor</code>s, <code>Applicative</code>s and some of the other typeclasses, ensure you read their documentation to understand <em>which</em> obvious way it behaves.</p>
<p>Let us look at an example <code>Applicative</code> instance:</p>
<pre><code class="language-haskell">instance Applicative Maybe where
    pure :: a -&gt; Maybe a
    pure = Just

    (&lt;*&gt;) :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
    Nothing &lt;*&gt; _ = Nothing
    _ &lt;*&gt; Nothing = Nothing
    Just f &lt;*&gt; Just x = Just $ f x
</code></pre>
<p>As you can see, <code>pure</code> just raises a value into the <code>Maybe</code> context using the <code>Just</code> constructor, and <code>(&lt;*&gt;)</code> applies a function in context onto an argument in context when they exist. In other words, <code>pure</code> and <code>&lt;*&gt;</code> behave in the most obvious way.</p>
<p>With this in mind, let us show how we can use <code>pure</code> and <code>&lt;*&gt;</code> for <code>Maybe</code>, but also, applicatives in general. Suppose we have <code>f :: a -&gt; b -&gt; c</code>, <code>x :: a</code> and <code>y :: b</code>. Then, <code>f x y</code> would give us something of type <code>c</code>.</p>
<p>However, Let us raise <code>x</code> and <code>y</code> into the <code>Maybe</code> context, i.e. <code>x :: Maybe a</code> and <code>y :: Maybe b</code>. Let's see how we can perform the same application (similar to <code>f x y</code>) to give us something of <code>Maybe c</code>.</p>
<p>To start, we know that we have <code>&lt;*&gt;</code> which applies a function in context with an argument in context. Therefore, we first raise <code>f</code> into the <code>Maybe</code> context using <code>pure</code>, then apply it onto <code>x</code> using <code>&lt;*&gt;</code>:</p>
<ul>
<li><code>pure f :: Maybe (a -&gt; b -&gt; c)</code></li>
<li><code>pure f &lt;*&gt; x :: Maybe (b -&gt; c)</code></li>
</ul>
<p>Finally, using <code>&lt;*&gt;</code> again allows us to apply the resulting function onto <code>y</code>, giving us a result of type <code>Maybe c</code>:</p>
<p><code>pure f &lt;*&gt; x &lt;*&gt; y :: Maybe c</code></p>
<pre><code>                  pure f   
Maybe a --&lt;*&gt;--&gt; ━━━┓
                    ┣━━━━ Maybe c
Maybe b --&lt;*&gt;--&gt; ━━━┛
</code></pre>
<p>However, recall from our very first example that we had attempted to use <code>fmap</code> to apply <code>(+)</code> onto a <code>Maybe Int</code> to give a <code>Maybe (Int -&gt; Int)</code>. Now we know that we can directly use this result and apply it onto another <code>Maybe Int</code> to give us a <code>Maybe Int</code>, thereby applying <code>(+)</code> in context! This is a natural consequence of the applicative laws, where <code>pure f &lt;*&gt; x</code> is the same as <code>fmap f x</code>!</p>
<pre><code class="language-haskell">pure f &lt;*&gt; x == Just f &lt;*&gt; x
             == case x of
                    Just y -&gt; Just $ f y
                    Nothing -&gt; Nothing
             == fmap f x
</code></pre>
<p>Therefore, Haskell also defines a function <code>&lt;$&gt;</code> as an alias of <code>fmap</code>:</p>
<pre><code class="language-haskell">(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
(&lt;$&gt;) = fmap
</code></pre>
<p>Therefore, instead of using <code>pure f &lt;*&gt; x</code>, we can just write <code>fmap f x</code> or <code>f &lt;$&gt; x</code> to achieve the same effect!</p>
<p><code>pure f &lt;*&gt; x &lt;*&gt; y</code> = <code>fmap f x &lt;*&gt; y</code> = <code>f &lt;$&gt; x &lt;*&gt; y</code></p>
<p>Now let us revisit our earlier example again! Here is a naive approach to applying <code>(+)</code> onto <code>x</code> and <code>y</code>:</p>
<pre><code class="language-haskell">x, y, z :: Maybe Int
x = head' [1, 2, 3]
y = head' [4, 5, 6]
z = case (x, y) of
    (Just x, Just y) -&gt; x + y
    _ -&gt; Nothing
</code></pre>
<p>Don't torture yourself! Instead, knowing that <code>Maybe</code> is an applicative (and therefore also a functor), let us just use <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code>!</p>
<pre><code class="language-haskell">x, y, z :: Maybe Int
x = head' [1, 2, 3]
y = head' [4, 5, 6]
z = (+) &lt;$&gt; x &lt;*&gt; y -- Just 5
</code></pre>
<p>As you can see, <code>Applicative</code>s allow us to perform computation in context separately, and apply a function over the results over these terms in context!</p>
<p>So far, you should have noticed that the functions and typeclasses presented perform the usual stuff, but in context:</p>
<ul>
<li><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>: lifts a function into a function in context</li>
<li><code>pure :: a -&gt; f a</code>: puts pure computation in context</li>
<li><code>&lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b</code>: function application in context</li>
</ul>
<p>With these, here are some guidelines for when to use <code>fmap</code>, <code>pure</code> and <code>&lt;*&gt;</code>:</p>
<ul>
<li><code>f x</code> becomes <code>fmap f x</code> or <code>f &lt;$&gt; x</code> or <code>pure f &lt;*&gt; x</code> if <code>x</code> becomes in context</li>
<li><code>f x</code> becomes <code>f &lt;*&gt; x</code> if both <code>f</code> and <code>x</code> become in context</li>
<li><code>f x y z</code> becomes <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code> if <code>x</code>, <code>y</code> and <code>z</code> become in context</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="validation"><a class="header" href="#validation">Validation</a></h1>
<p>One of the most common use of applicatives is <em>validation</em>. From our example at the start of this chapter, we have several data structures and we want to be able to parse them from strings:</p>
<pre><code class="language-haskell">data Email = Email { emailUsername :: String
                   , emailDomain   :: String }
  deriving (Eq, Show)

data Salary = SInt Int 
            | SDouble Double
  deriving (Eq, Show)

data User = User { username   :: String
                 , userEmail  :: Email
                 , userSalary :: Salary }
  deriving (Eq, Show)
</code></pre>
<p>Parsing them from strings may not always succeed, therefore it is imperative that our parsing function does not guarantee that it returns the desired data structure. Therefore, what we can do instead is to have our parsing functions return results in the <code>Maybe</code> context to express this fact. This makes our parsing functions have the following type signatures:</p>
<pre><code class="language-haskell">parseEmail :: String -&gt; Maybe Email
parseSalary :: String -&gt; Maybe Salary
</code></pre>
<p>Given these functions, we should be able to define a function that parses a <code>User</code> from three strings: the user name (which requires no parsing), the email (which is parsed using <code>parseEmail</code>) and the salary (which is parsed using <code>parseSalary</code>). One way we can implement this <code>parseUser</code> function is by receiving the three strings, performing parsing on the <code>email</code> and <code>salary</code> (in <em>parallel</em><sup class="footnote-reference"><a href="#1">1</a></sup>), then constructing our <code>User</code> term with the usual <code>Functor</code> and <code>Applicative</code> methods.</p>
<pre><code class="language-haskell">parseUser :: String -- name
             -&gt; String -- email
             -&gt; String -- salary
             -&gt; Maybe User -- user
parseUser name email salary =
    let e = parseEmail email
        s = parseSalary salary
    in  User name &lt;$&gt; e &lt;*&gt; s
</code></pre>
<p>Now our parsing function works just fine!</p>
<pre><code class="language-haskell">ghci&gt; parseUser "Foo" "yong@qi.com" "1000"
Just (User "Foo" (Email "yong" "qi.com") 1000)
ghci&gt; parseUser "Foo" "yong" "1000"
Nothing
</code></pre>
<h2 id="validation-with-error-messages"><a class="header" href="#validation-with-error-messages">Validation with Error Messages</a></h2>
<p>However, this is not always helpful since when parsing a user, several things could go wrong—either (1) the supplied email is invalid, (2) the supplied salary is invalid, or (3) both. Therefore, let's have our parsing functions return an error message instead of <code>Nothing</code>. For this, what we want to rely on is the <code>Either</code> type, which consists of a <code>Left</code> of something sad (like an error message), or a <code>Right</code> of something happy (the desired result type). We show the definitions of <code>Either</code> and its supporting typeclass instances here.</p>
<pre><code class="language-haskell">data Either a b = Left a -- sad
                | Right b -- happy

instance Functor (Either a) where
    fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c
    fmap _ (Left x) = Left x
    fmap f (Right x) = Right $ f x

instance Applicative (Either a) where
    pure :: b -&gt; Either a b
    pure = Right

    (&lt;*&gt;) :: Either a (b -&gt; c) -&gt; Either a b -&gt; Either a c
    Left f &lt;*&gt; _ = Left f
    _ &lt;*&gt; Left x = Left x
    Right f &lt;*&gt; Right x = Right $ f x
</code></pre>
<p>Let us change the context that our parsing functions will return. Some of the implementation of <code>parseEmail</code> and <code>parseSalary</code> will need to be changed to add descriptive error messages, and so will their type signatures.</p>
<pre><code class="language-haskell">parseEmail :: String -&gt; Either String Email
parseEmail email = 
    if ... then
        Left $ "error: " ++ email ++ " is not an email"
    else
        Right $ Email ...

parseSalary :: String -&gt; Either String Salary
parseSalary salary = 
    if ... then
        Left $ "error: " ++ salary ++ " is not a number"
    else
        Right $ SInt ...

</code></pre>
<p>The great thing is that although we have changed the return types of our individual parsing functions, the implementation of <code>parseUser</code> does not, because our definition only relies on the typeclass methods of <code>Functor</code> and <code>Applicative</code>. Since <code>Either a</code> is also an <code>Applicative</code>, our definition can be unchanged, and only the type signature of <code>parseUser</code> needs to be updated.</p>
<pre><code class="language-haskell">parseUser :: String -- name
             -&gt; String -- email
             -&gt; String -- salary
             -&gt; Either String User -- user
parseUser name email salary =
    let e = parseEmail email
        s = parseSalary salary
    in  User name &lt;$&gt; e &lt;*&gt; s
</code></pre>
<p>Now, users of our <code>parseUser</code> function will get more descriptive error message reports when parsing fails!</p>
<pre><code class="language-haskell">ghci&gt; parseUser "Foo" "yong@qi.com" "1000"
Right (User "Foo" (Email "yong" "qi.com") 1000)
ghci&gt; parseUser "Foo" "yong" "1000"
Left "error: yong is not an email"
ghci&gt; parseUser "Foo" "yong@qi.com" "x"
Left "error: x is not a number"
</code></pre>
<h2 id="accumulating-error-messages"><a class="header" href="#accumulating-error-messages">Accumulating Error Messages</a></h2>
<p>However, there is one case that is not handled in our validation function. Let's see what that is:</p>
<pre><code class="language-haskell">ghci&gt; parseUser "Foo" "abc" "x"
Left "error: abc is not an email"
</code></pre>
<p>Notice that although <em>both</em> the email and salaries are invalid, the error message shown <em>only</em> highlights the invalid email address. This is misleading because, in fact, the salary is invalid as well, and the user of this function does not know that!</p>
<p>The reason for this lies in the definition of the typeclass instance <code>Applicative (Either a)</code>. Notice that in the case of <code>Left f &lt;*&gt; Left x</code>, the result is <code>Left f</code>, ignoring the other error message <code>Left x</code>! In other words, <code>Either</code> is a fail-fast <code>Applicative</code>, and this is not what we want for our parsing function!</p>
<p>As briefly stated earlier, although the <code>Applicative</code> laws describe how an <code>Applicative</code> behaves in the <em>most obvious way</em>, there is in fact, multiple <em>most obvious ways</em> an instance can behave. In fact, we can define a data structure that does not exhibit fail-fastness, and yet, is still a valid <code>Applicative</code>—the result of which is an <code>Applicative</code> that allows us to collect all error messages! Let us give this a try.</p>
<p>The first is to re-define <code>Either</code> as an ADT called <code>Validation</code> that is practically the same (isomorphic) to <code>Either</code>, since that structure is still useful for our purposes. The <code>Functor</code> instance of this ADT will remain the same.</p>
<pre><code class="language-haskell">data Validation err a = Success a
                      | Failure err

instance Functor (Validation err) where
    fmap _ (Failure e) = Failure e
    fmap f (Success x) = Success $ f x
</code></pre>
<p>Notice that our <code>err</code> type variable remains as a type variable, instead of a pre-defined error message collection type like <code>[String]</code>. This is because, as always, we want to keep our types as general as possible so that it can be used liberally. However, it is now incumbent on us to restrict or constraint <code>err</code> in a way that makes it amenable to collecting error messages in an obvious way so that we can still use it for our purposes. In essence, we just need <code>err</code> to have some binary operation that is <em>associative</em>:</p>
<p>\[E_1\oplus(E_2 \oplus E_3) = (E_1 \oplus E_2) \oplus E_3 \]</p>
<p>For this, we introduce the <code>Semigroup</code> typeclass which represents just that!</p>
<pre><code class="language-haskell">class Semigroup a where
    -- must be associative
    (&lt;&gt;) :: a -&gt; a -&gt; a 
</code></pre>
<p>Any type is a semigroup as long as it is closed under an associative binary operation. With this, as long as our error is a semigroup, we can use that as our errors in <code>Validation</code>! Let us define our <code>Applicative</code> instance for this:</p>
<pre><code class="language-haskell">instance Semigroup err =&gt; Applicative (Validation err) where
    pure :: a -&gt; Validation err a
    pure = Success

    (&lt;*&gt;) :: Validation err (a -&gt; b) -&gt; Validation err a -&gt; Validation err b
    Failure l &lt;*&gt; Failure r = Failure (l &lt;&gt; r)
    Failure l &lt;*&gt; _ = Failure l
    _ &lt;*&gt; Failure r = Failure r
    Success f &lt;*&gt; Success x = Success (f x)
</code></pre>
<p>Notice the double-failure case—the errors are combined or aggregated using the semigroup binary operation <code>(&lt;&gt;)</code>. This way, no information is lost if both operands are <code>Failure</code> cases since they are accumulated together.</p>
<p>Assuredly, using a list of strings as our error log is fine because concatenation is an associative binary operation over lists!</p>
<pre><code class="language-haskell">instance Semigroup [a] where
    (&lt;&gt;) :: [a] -&gt; [a] -&gt; [a]
    (&lt;&gt;) = (++)
</code></pre>
<p>Therefore, with these definitions we can now amend our parsing functions to use our new <code>Validation</code> <code>Applicative</code>. First, as per usual, we amend <code>parseEmail</code> and <code>parseUser</code> so that they correctly use <code>Validation</code> instead of <code>Either</code></p>
<pre><code class="language-haskell">parseEmail :: String -&gt; Validation [String] Email
parseEmail email =
    if ... then
        Failure ["error: " ++ email ++ " is not an email"]
    else
        Success $ Email ...

parseSalary :: String -&gt; Validation [String] Salary
parseSalary salary =
    if ... then
        Failure ["error: " ++ salary ++ " is not a number"]
    else
        Success $ SInt ...
</code></pre>
<p>Once again, our <code>parseUser</code> function does not need to change, except for the type signature.</p>
<pre><code class="language-haskell">parseUser :: String -- name
             -&gt; String -- email
             -&gt; String -- salary
             -&gt; Validation [String] User -- user
parseUser name email salary =
    let e = parseEmail email
        s = parseSalary salary
    in  User name &lt;$&gt; e &lt;*&gt; s
</code></pre>
<p>Now, our parsing function works exactly as we want!</p>
<pre><code class="language-haskell">ghci&gt; parseUser "Foo" "yong@qi.com" "1000"
Success (User "Foo" (Email "yong" "qi.com") 1000)
ghci&gt; parseUser "Foo" "yong" "1000"
Failure ["error: yong is not an email"]
ghci&gt; parseUser "Foo" "yong@qi.com" "x"
Failure ["error: x is not a number"]
ghci&gt; parseUser "Foo" "abc" "x"
Failure ["error: abc is not an email", "error: x is not a number"]
</code></pre>
<h2 id="hands-on"><a class="header" href="#hands-on">Hands-On</a></h2>
<p>In this chapter, we went from parsing with <code>Maybe</code>s to parsing with <code>Either</code>s and finally to parsing with <code>Validation</code>s. Give this a try for yourself!</p>
<p>Written below is the full program for parsing users with <code>Maybe</code>. Try replacing the <code>Maybe</code>s with <code>Either</code>s, then with <code>Validation</code>s and see the outcome of running the program each time!</p>
<pre><code class="language-haskell">module Main where

import Control.Applicative
import Text.Read
import System.IO

-- edit these!
parseEmail :: String -&gt; Maybe Email
parseEmail email = 
    if '@' `elem` email &amp;&amp; length e == 2 &amp;&amp; '.' `elem` last e
    -- edit the following two lines when replacing Maybe with
    -- Either or Validation
    then Just $ Email (head e) (last e)
    else Nothing
  where e = split '@' email

parseSalary :: String -&gt; Maybe Salary
parseSalary s = 
  let si = SInt &lt;$&gt; readMaybe s
      sf = SDouble &lt;$&gt; readMaybe s
  in  case si &lt;|&gt; sf of
        Just x -&gt; Just x -- change the RHS `Just x` when replacing
                         -- Maybe with Either or Validation
        Nothing -&gt; Nothing -- change the RHS `Nothing` when replacing
                           -- Maybe with Either or Validation

-- you should only need to change the type of `parseUser` when 
-- replacing Maybe with Either or Validation
parseUser :: String -- name
          -&gt; String -- email
          -&gt; String -- salary
          -&gt; Maybe User 
parseUser name email salary = 
    let e = parseEmail email
        s = parseSalary salary
    in  User name &lt;$&gt; e &lt;*&gt; s

-- no need to edit the rest!

-- the data structures
data Email = Email { emailUsername :: String,
                     emailDomain :: String    }
  deriving (Eq, Show)

data Salary = SInt Int | SDouble Double
  deriving (Eq, Show)

data User = User { username :: String,
                   userEmail :: Email,
                   userSalary :: Salary }
  deriving (Eq, Show)

-- user input with a prompt
input :: String -&gt; IO String
input prompt = do
  putStr prompt
  hFlush stdout
  getLine

-- splitting strings
split :: Char -&gt; String -&gt; [String]
split _ [] = [""]
split delim (x : xs)
    | x == delim = "" : xs'
    | otherwise  = (x : head xs') : tail xs'
  where xs' = split delim xs

-- validation
data Validation err a = Success a
                      | Failure err
    deriving (Eq, Show)

instance Functor (Validation err) where
    fmap :: (a -&gt; b) -&gt; Validation err a -&gt; Validation err b
    fmap _ (Failure e) = Failure e
    fmap f (Success x) = Success $ f x

instance Semigroup err =&gt; Applicative (Validation err) where
    pure :: a -&gt; Validation err a
    pure = Success

    (&lt;*&gt;) :: Validation err (a -&gt; b) -&gt; Validation err a -&gt; Validation err b
    Failure l &lt;*&gt; Failure r = Failure (l &lt;&gt; r)
    Failure l &lt;*&gt; _ = Failure l
    _ &lt;*&gt; Failure r = Failure r
    Success f &lt;*&gt; Success x = Success (f x)

main :: IO ()
main = do
  n &lt;- input "Enter name: "
  e &lt;- input "Enter email: "
  s &lt;- input "Enter salary: "
  print $ parseUser n e s
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>It is important to note that the use of the word "parallel" in this chapter has nothing to do with <em>parallelism</em>. The word "parallel" is only used to describe the notion of merging parallel railways into a single rail line via <code>&lt;*&gt;</code>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="monads"><a class="header" href="#monads">Monads</a></h1>
<p>Another incredibly useful tool is to be able to perform <em>composition in context</em>. That is, that given something of <code>f a</code> and a function from <code>a -&gt; f b</code>, how do we get an <code>f b</code>?</p>
<p>Consider the following example. We can write 123 divided by 4 <em>and then</em> divided by 5 via the following straightforward program:</p>
<pre><code class="language-haskell">x, y, z :: Int
x = 123
y = (`div` 4) x
z = (`div` 5) y
</code></pre>
<p>However, we know that <code>div</code> is unsafe since dividing it by 0 gives a zero division error. Therefore, we should write a safe <code>div</code> function that returns <code>Nothing</code> if division by 0 is to be expected:</p>
<pre><code class="language-haskell">safeDiv x y :: Int -&gt; Maybe Int
safeDiv x 0 = Nothing
safeDiv x y = div x y
</code></pre>
<p>However, composing <code>safeDiv</code> is now no longer straightforward:</p>
<pre><code class="language-haskell">x = 123
y = (`safeDiv` 4) x
z = ???
</code></pre>
<pre><code>     safeDiv                             safeDiv
        ┏━━━━                ?              ┏━━━━
Int ━━━━┫      Maybe Int  &lt;-----&gt;   Int ━━━━┫     Maybe Int
        ┗━━━━                               ┗━━━━
</code></pre>
<p>Let us try using <code>fmap</code>:</p>
<pre><code class="language-haskell">x :: Int
x = 123

y :: Maybe Int
y = (`safeDiv` 4) x

z :: Maybe (Maybe Int)
z = fmap (`safeDiv` 5) y
</code></pre>
<p>Although this typechecks, the resulting type <code>Maybe (Maybe Int)</code> is incredibly awkward. It tells us that there is potentially a <code>Maybe Int</code> term, which means that there is <em>potentially</em> a <em>potential</em> <code>Int</code>. What would be better is to collapse the <code>Maybe (Maybe Int)</code> into just <code>Maybe Int</code>.</p>
<p>For this, we introduce the notion of a <em>Monad</em>, which again, can be described by a typeclass with some rules governing their methods. The primary feature of a <code>Monad</code> <code>m</code> is that it is an <code>Applicative</code> where we can collapse an <code>m (m a)</code> into an <code>m a</code> in the most obvious way. However, for convenience's sake, Haskell defines the <code>Monad</code> typeclass in a slightly different (but otherwise equivalent) formulation<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<pre><code class="language-haskell">class Applicative m =&gt; Monad m where
    return :: a -&gt; m a -- same as pure
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b -- composition in context
</code></pre>
<p>These methods are governed by the following laws:</p>
<ul>
<li>Left identity: <code>return a &gt;&gt;= h</code> = <code>h a</code></li>
<li>Right identity: <code>m &gt;&gt;= return</code> = <code>m</code></li>
<li>Associativity: <code>(m &gt;&gt;= g) &gt;&gt;= h</code> = <code>m &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</code></li>
</ul>
<p><code>return</code> is practically the same as <code>pure</code> (in fact it is almost always defined as <code>return = pure</code>). Although the word <code>return</code> feels incredibly odd, we shall see very shortly why it was named this way. <code>&gt;&gt;=</code> is known as the <em>monadic bind</em><sup class="footnote-reference"><a href="#1">1</a></sup> <sup class="footnote-reference"><a href="#2">2</a></sup>, and allows us to perform computation in context on a term in context, thereby achieving <em>composition in context</em>.</p>
<p><code>&gt;&gt;=</code> is somewhat similar to <code>fmap</code>, in that while <code>fmap</code> allows us to apply an <code>a -&gt; b</code> onto an <code>f a</code>, <code>&gt;&gt;=</code> allows us to apply an <code>a -&gt; m b</code> onto an <code>m a</code>.</p>
<p>Let us see an instance of <code>Monad</code>:</p>
<pre><code class="language-haskell">instance Monad Maybe where
    return :: a -&gt; Maybe a
    return = pure

    (&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
    Nothing &gt;&gt;= _ = Nothing
    Just x &gt;&gt;= f  = f x
</code></pre>
<p>With this instance, instead of using <code>fmap</code> to bring our <code>Maybe Int</code> into a <code>Maybe (Maybe Int)</code>, we can use <code>&gt;&gt;=</code> to just bring it to a <code>Maybe Int</code>!</p>
<pre><code class="language-haskell">x :: Int
x = 123

y :: Maybe Int
y = (`safeDiv` 4) x

z :: Maybe Int
z = y &gt;&gt;= (`safeDiv` 5)
</code></pre>
<p>As we know, function composition <code>(g . f) x</code> is sort of to say "do <code>f</code> <em>and then</em> do <code>g</code> on <code>x</code>". Similarly, when <code>f</code> and <code>g</code> are computations in context and <code>x</code> is a term in context, <code>x &gt;&gt;= f &gt;&gt;= g</code> also means "do <code>f</code> <em>and then</em> do <code>g</code> on <code>x</code>"! However, <code>&gt;&gt;=</code> is incredibly powerful because the actual definition of <code>&gt;&gt;=</code> depends on the monad you use—therefore, monads allow us to <em>overload</em> composition in context!<sup class="footnote-reference"><a href="#3">3</a></sup></p>
<pre><code>     safeDiv   |                       safeDiv
        ┏━━━━  |                          ┏━━━━
Int ━━━━┫      | Maybe Int  &gt;&gt;=   Int ━━━━┫     Maybe Int
        ┗━━━━  |                          ┗━━━━
</code></pre>
<p>Therefore, if you had <code>f :: a -&gt; b</code> and <code>g :: b -&gt; c</code> and <code>x :: a</code>, you would write <code>g (f x)</code> for <code>f</code> <em>and then</em> <code>g</code>. However, if you had <code>f :: a -&gt; m b</code> and <code>g :: b -&gt; m c</code> and <code>x :: m a</code>, you would write <code>x &gt;&gt;= f &gt;&gt;= g</code> for <code>f</code> <em>and then</em> <code>g</code>.</p>
<h2 id="beyond-the-railways"><a class="header" href="#beyond-the-railways">Beyond the Railways</a></h2>
<p>As we know, data structures like <code>Maybe</code>, <code>Either</code> and <code>Validation</code> support the railway pattern, and them being functors, applicatives and (in the case of <code>Maybe</code> and <code>Either</code>) monads makes them ergonomic to use. However, the use of functors, applicatives and monads extend beyond just the railway pattern.</p>
<p>As described in <a href="railway_pattern/./context.html">Chapter 4.1 (Context/Notions of Computation)</a>, types like <code>[]</code> and <code>IO</code> provide <em>context</em> around a type. As it turns out, these types are also functors, applicatives and monads. While we have not touched <code>IO</code> at all so far, and will only do so in the next chapter, let us see the instance definitions for <code>[]</code>:</p>
<pre><code class="language-haskell">instance Functor [] where
    fmap :: (a -&gt; b) -&gt; [a] -&gt; [b]
    fmap = map

instance Applicative [] where
    pure :: a -&gt; [a]
    pure x    = [x]

    (&lt;*&gt;) :: [a -&gt; b] -&gt; [a] -&gt; [b]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]

instance Monad []  where
    return :: a -&gt; [a]
    return = pure

    (&gt;&gt;=) :: [a] -&gt; (a -&gt; [b]) -&gt; [b]
    xs &gt;&gt;= f = [y | x &lt;- xs, y &lt;- f x]
</code></pre>
<p>Observe the definition of <code>&gt;&gt;=</code> for lists. The idea is that whatever <code>fmap f xs</code> produces (which is a 2+D list), <code>xs &gt;&gt;= f</code> flattens that result (it doesn't flatten it recursively, just the top layer). It does so by applying <code>f</code> onto every single <code>x</code>s in the list. As per the type signature, each <code>f x</code> produces a term of the type <code>[b]</code>, which is a list. We extract each <code>y</code> from that list, and put them all as elements of the resulting list. Let us see the action of <code>&gt;&gt;=</code> through an example:</p>
<pre><code class="language-haskell">ghci&gt; fmap (\x -&gt; return x) [1, 2, 3]
[[1], [2], [3]] -- fmap gives a 2D list
ghci&gt; [1, 2, 3] &gt;&gt;= (\x -&gt; return x)
[1, 2, 3]       -- &gt;&gt;= gives a 1D list

ghci&gt; fmap (\x -&gt; return (x, x + 1)) [1, 2, 3]
[[(1, 2)], [(2, 3)], [(3, 4)]] -- fmap gives a 2D list
ghci&gt; [1, 2, 3] &gt;&gt;= (\x -&gt; return (x, x + 1))
ghci&gt; [(1, 2), (2, 3), (3, 4)] -- &gt;&gt;= gives a 1D list

ghci&gt; [1, 2] &gt;&gt;= (\x -&gt; [3] &gt;&gt;= (\y -&gt; &gt;&gt;= return (x, y)))
[(1, 3), (2, 3)]
</code></pre>
<p>The last function can be written a little more clearly. Suppose we want to write a function that produces the "cartesian product" of two lists. Writing this function using the monad methods can look unwieldy, but will ultimately pay off as you will see shortly:</p>
<pre><code class="language-haskell">cartesian_product :: [a] -&gt; [b] -&gt; [(a, b)]
cartesian_product xs ys = xs &gt;&gt;= (\x -&gt; 
                          ys &gt;&gt;= (\y -&gt; 
                          return (x, y)))
</code></pre>
<p>As we expect, everything works!</p>
<pre><code class="language-haskell">ghci&gt; cartesian_product [1,2] [3]
[(1,3),(2,3)]
</code></pre>
<h2 id="do-notation"><a class="header" href="#do-notation">Do-notation</a></h2>
<p>The definition of <code>cartesian_product</code> above is hard to read. However, this form of programming is (as you will surely see) very common—we bind each <code>x</code> from <code>xs</code>, then bind each <code>y</code> from <code>ys</code>, and return <code>(x, y)</code>. Why not let us write the same implementation in this way:</p>
<pre><code class="language-haskell">cartesian_product :: [a] -&gt; [b] -&gt; [(a, b)]
cartesian_product xs ys = do
    x &lt;- xs
    y &lt;- ys
    return (x, y)
</code></pre>
<p>Wouldn't this be much more straightforward? In fact, Haskell supports this! This is known as <code>do</code> notation, and is supported as long as the expression's type is a monad. <code>do</code> notation is just syntactic sugar for a series of <code>&gt;&gt;=</code> and lambda expressions:</p>
<pre><code>do e1 &lt;- e2           ==&gt;      e2 &gt;&gt;= (\e1 -&gt; whatever code)
   whatever code
</code></pre>
<p>Therefore, the definition of <code>cartesian_product</code> using <code>do</code> notation is translated as follows:</p>
<pre><code>do x &lt;- xs                 xs &gt;&gt;= (\x -&gt;              xs &gt;&gt;= (\x -&gt;
   y &lt;- ys           ==&gt;      do y &lt;- ys         ==&gt;  ys &gt;&gt;= (\y -&gt;
   return (x, y)                 return (x, y))       return (x, y)))
</code></pre>
<p>More importantly, go back to the definition of <code>cartesian_product</code> using <code>do</code> notation. Compare that definition with the (more-or-less) equivalent definition in Python:</p>
<pre><code class="language-python">def cartesian_product(xs, ys):
    for x in xs:
        for y in ys:
            yield (x, y)
</code></pre>
<p>What we have done was to <strong>recover imperative programming with do-notation</strong>! Even better: while <code>for</code> loops in Python only work on iterables, <code>do</code> notation in Haskell works on <strong>any monad</strong>!</p>
<pre><code class="language-haskell">-- do notation with lists
pairs :: [a] -&gt; [(a, a)]
pairs ls = do x &lt;- ls
              y &lt;- ls
              return (x, y)

-- do notation with Maybe
z :: Maybe Int
z = do y &lt;- 123 `safeDiv` 4
       y `safeDiv` 5

-- do notation with Either
parseUser :: String -&gt; String -&gt; String -&gt; Either String User
parseUser name email salary
  = do e &lt;- parseEmail email
       s &lt;- parseSalary salary
       return $ User name e s
</code></pre>
<p>Other languages like Python, C etc. define keywords like <code>for</code>, <code>while</code>, <code>if</code>-<code>else</code> as part of the language so that programmers can use different meanings of what <em>and then</em> means. For example, a <code>while</code> loop lets you write programs like (1) check condition, <em>and then</em> (2) if its true do the loop body, <em>and then</em> (3) check the condition again, etc. In Functional Programming languages like Haskell, it is <em>monads</em> that decide what <em>and then</em> means—this is great because <strong>you</strong> get to define your own monads and decide what composition of computation means!</p>
<pre><code class="language-haskell">cartesian_product :: Monad m =&gt; m a -&gt; m b -&gt; m (a, b)
cartesian_product xs ys = do
    x &lt;- xs
    y &lt;- ys
    return (x, y)
</code></pre>
<pre><code class="language-haskell">ghci&gt; cartesian_product [1, 2] [3]
[(1, 3), (2, 3)]
ghci&gt; cartesian_product (Just 1) (Just 2)
Just (1, 2)
ghci&gt; cartesian_product (Just 1) Nothing
Nothing
ghci&gt; cartesian_product (Right 1) (Right 2)
Right (1, 2)
ghci&gt; cartesian_product getLine getLine -- getLine is like input() in Python
alice -- user input
bob   -- user input
("alice","bob")
</code></pre>
<p>As you can tell, each monad has its own way of composing computation in context and has its own meaning behind the context it provides. This is why monads are such a powerful tool for functional programming! It is for this reason that we will dedicate the entirety of the next chapter to monads.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>You might notice that the monadic bind operator <code>&gt;&gt;=</code> looks very similar to the Haskell logo. Monads are incredibly important in functional programming, and we shall spend an entire chapter dedicated to this subject.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Many popular languages call this <code>flatMap</code>.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Just like how languages like C, C++ and Java have <code>;</code> to separate statements, i.e. a program like <code>A;B</code> means do <code>A</code> and then do <code>B</code>, <code>&gt;&gt;=</code> allows us to <em>overload</em> what <em>and then</em> means!</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h2 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h2>
<ul>
<li>Instead of functions with side-effects, pure functions can emulate the desired effects (like branching railways) using the right data structures as notions of computation</li>
<li>We can operate in context using regular functions when the context is a functor</li>
<li>We can combine context when the context is an applicative</li>
<li>We can compose functions in context sequentially when they are monads</li>
</ul>
<h1 id="railway-pattern-in-python"><a class="header" href="#railway-pattern-in-python">Railway Pattern in Python</a></h1>
<p>Aside from <code>do</code>-notation and all the niceties of programming with typeclasses, nothing else we have discussed in this chapter is exclusive to Haskell. In fact, many other languages have similar data structures to the ones we have seen, and are all functors and monads too! For example, we can implement <code>safeDiv</code> in <code>Java</code> using the built-in <code>Optional</code> class, which is the same as <code>Maybe</code> in Haskell, and to use its <code>flatMap</code> method instead of <code>&gt;&gt;=</code> in Haskell:</p>
<pre><code class="language-java">import java.util.Optional;
public class Main {
  static Optional&lt;Integer&gt; safeDiv(int num, int den) {
    if (den == 0) {
      return Optional.empty();
    }
    return Optional.of(num / den);
  }

  public static void main(String[] args) {
    Optional&lt;Integer&gt; x = safeDiv(123, 4)
        .flatMap(y -&gt; safeDiv(y, 5))
        .flatMap(z -&gt; safeDiv(z, 2));
    x.ifPresent(System.out::println);
  }
}
</code></pre>
<p>Therefore, what is required for using the railway pattern are</p>
<ul>
<li>the right data structures that have happy/sad paths, just like <code>Maybe</code>, <code>Either</code> and <code>Validation</code> (or even <code>[]</code>)</li>
<li>the right methods so that they are functors, applicatives, monads etc, ensuring that they adhere to the laws as derived from category theory</li>
<li>idiomatic <em>uses</em> of these data structures write pure functions, and to <em>use</em> their methods to concisely express functorial, applicative or monadic actions</li>
</ul>
<p>Give these a try in the exercises!</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h1>
<p>These exercises have questions that will require you to write code in Python and Haskell. All your Python code should be written in a purely-functional style.</p>
<h2 id="question-1-3"><a class="header" href="#question-1-3">Question 1</a></h2>
<p>Create the following ADTs in Python:</p>
<ul>
<li>A singly linked list</li>
<li>A <code>Maybe</code>-like type, with "constructors" <code>Just</code> and <code>Nothing</code></li>
<li>An <code>Either</code>-like type, with "constructors" <code>Left</code> and <code>Right</code></li>
<li>A <code>Validation</code>-like type, with "constructors" <code>Success</code> and <code>Failure</code>. Because Python does not have higher-kinds, you may assume that <code>Failure</code>s always hold a list of strings.</li>
</ul>
<p>Then define methods on all these types so that they are all functors, applicatives and monads (<code>Validation</code> does not need to be a monad). <code>fmap</code> can be called <code>map</code>, <code>&lt;*&gt;</code> can be called <code>ap</code>, <code>return</code> can just be <code>pure</code>, and <code>&gt;&gt;=</code> can be called <code>flatMap</code>.</p>
<p>Due to Python's inexpressive type system, you are free to omit type annotations.</p>
<p><strong>Try not to look at Haskell's definitions when doing this exercise to truly understand how these data structures work!</strong></p>
<p>Example runs for each data structure follow:</p>
<h4 id="lists"><a class="header" href="#lists">Lists</a></h4>
<pre><code class="language-python"># lists
&gt;&gt;&gt; my_list = Node(1, Node(2, Empty()))

# map
&gt;&gt;&gt; my_list.map(lambda x: x + 1)
Node(2, Node(3, Empty()))

# pure
&gt;&gt;&gt; List.pure(1)
Node(1, Empty())

# ap
&gt;&gt;&gt; Node(lambda x: x + 1, Empty()).ap(my_list)
Node(2, Node(3, Empty()))

# flatMap
&gt;&gt;&gt; my_list.flatMap(lambda x: Node(x, Node(x + 1, Empty())))
Node(1, Node(2, Node(2, Node(3, Empty()))))
</code></pre>
<h4 id="maybe"><a class="header" href="#maybe">Maybe</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; my_just = Just(1)
&gt;&gt;&gt; my_nothing = Nothing()

# map
&gt;&gt;&gt; my_just.map(lambda x: x + 1)
Just(2)
&gt;&gt;&gt; my_nothing.map(lambda x: x + 1)
Nothing()

# pure
&gt;&gt;&gt; Maybe.pure(1)
Just(1)

# ap
&gt;&gt;&gt; Just(lambda x: x + 1).ap(my_just)
Just(2)
&gt;&gt;&gt; Just(lambda x: x + 1).ap(my_nothing)
Nothing()
&gt;&gt;&gt; Nothing().ap(my_just)
Nothing()
&gt;&gt;&gt; Nothing().ap(my_nothing)
Nothing()

# flatMap
&gt;&gt;&gt; my_just.flatMap(lambda x: Just(x + 1))
Just(2)
&gt;&gt;&gt; my_nothing.flatMap(lambda x: Just (x + 1))
Nothing()
</code></pre>
<h4 id="either"><a class="header" href="#either">Either</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; my_left = Left('boohoo')
&gt;&gt;&gt; my_right = Right(1)

# map
&gt;&gt;&gt; my_left.map(lambda x: x + 1)
Left('boohoo')
&gt;&gt;&gt; my_right.map(lambda x: x + 1)
Right(2)

# pure
&gt;&gt;&gt; Either.pure(1)
Right(1)

# ap
&gt;&gt;&gt; Left('sad').ap(my_right)
Left('sad')
&gt;&gt;&gt; Left('sad').ap(my_left)
Left('sad')
&gt;&gt;&gt; Right(lambda x: x + 1).ap(my_right)
Right(2)
&gt;&gt;&gt; Right(lambda x: x + 1).ap(my_left)
Left('boohoo')

# flatMap
&gt;&gt;&gt; my_right.flatMap(lambda x: Right(x + 1))
Right(2)
&gt;&gt;&gt; my_left.flatMap(lambda x: Right(x + 1))
Left('boohoo')
</code></pre>
<h4 id="validation-1"><a class="header" href="#validation-1">Validation</a></h4>
<pre><code class="language-python">&gt;&gt;&gt; my_success = Success(1)
&gt;&gt;&gt; my_failure = Failure(['boohoo'])

# map
&gt;&gt;&gt; my_failure.map(lambda x: x + 1)
Failure(['boohoo'])
&gt;&gt;&gt; my_success.map(lambda x: x + 1)
Right(2)

# pure
&gt;&gt;&gt; Validation.pure(1)
Right(1)

# ap
&gt;&gt;&gt; Failure(['sad']).ap(my_success)
Failure(['sad'])
&gt;&gt;&gt; Failure(['sad']).ap(my_failure)
Failure(['sad', 'boohoo'])
&gt;&gt;&gt; Success(lambda x: x + 1).ap(my_success)
Success(2)
&gt;&gt;&gt; Success(lambda x: x + 1).ap(my_failure)
Failure(['boohoo'])
</code></pre>
<h2 id="question-2-3"><a class="header" href="#question-2-3">Question 2</a></h2>
<h4 id="question-21-unsafe-sum"><a class="header" href="#question-21-unsafe-sum">Question 2.1: Unsafe Sum</a></h4>
<p>Recall Question 6 in <a href="railway_pattern/../course_introduction/sections/exercises.html">Chapter 1.4 (Exercises)</a> where we defined a function <code>sumDigits</code> in Haskell. Now write a function <code>sum_digits(n)</code> that does the same, i.e. sums the digits of a nonnegative integer \(n\), in Python. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; sum_digits(1234)
10
&gt;&gt;&gt; sum_digits(99999)
45
</code></pre>
<p>Your Haskell definition should also run similarly:</p>
<pre><code class="language-haskell">ghci&gt; sumDigits 1234
10
ghci&gt; sumDigits 99999
45
</code></pre>
<h4 id="question-22-safe-sum"><a class="header" href="#question-22-safe-sum">Question 2.2: Safe Sum</a></h4>
<p>Try entering negative integers as arguments to your functions. My guess is that something bad happens.</p>
<p>Let us make <code>sum_digits</code> safe. Re-define <code>sum_digits</code> so that we can drop the assumption that \(n\) is nonnegative (but will still be an integer), correspondingly using the <code>Maybe</code> context to keep our function pure. Use the <code>Maybe</code> data structure that you have defined from earlier for the Python version, and use Haskell's built-in <code>Maybe</code> to do so. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; sum_digits(1234)
Just(10)
&gt;&gt;&gt; sum_digits(99999)
Just(45)
&gt;&gt;&gt; sum_digits(-1)
Nothing
</code></pre>
<pre><code class="language-haskell">ghci&gt; sumDigits 1234
Just 10
ghci&gt; sumDigits 99999
Just 45
ghci&gt; sumDigits (-1)
Nothing
</code></pre>
<h4 id="question-23-final-sum"><a class="header" href="#question-23-final-sum">Question 2.3: Final Sum</a></h4>
<p>Now define a function <code>final_sum(n)</code> that repeatedly calls <code>sum_digit</code> until a single-digit number arises. Just like your safe implementation of <code>sum_digit</code>, <code>final_sum</code> should also be safe. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; final_sum(1234)
Just(1)
&gt;&gt;&gt; final_sum(99999)
Just(9)
&gt;&gt;&gt; final_sum(-1)
Nothing()
</code></pre>
<pre><code class="language-haskell">ghci&gt; finalSum 1234
Just 1
ghci&gt; finalSum 99999
Just 9
ghci&gt; finalSum (-1)
Nothing
</code></pre>
<blockquote>
<p>Tip: Use <code>do</code>-notation in your Haskell implementation!</p>
</blockquote>
<h2 id="question-3-3"><a class="header" href="#question-3-3">Question 3</a></h2>
<h4 id="question-31-splitting-strings"><a class="header" href="#question-31-splitting-strings">Question 3.1: Splitting Strings</a></h4>
<p>Define a function <code>split</code> that splits a string delimited by a character. This is very similar to <code>s.split(c)</code> in Python. However, the returned result should be a singly-linked list—in Python, this would be the singly-linked-list implementation you defined in Question 1, and in Haskell, this would be just <code>[String]</code>.</p>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; split('.', 'hello. world!. hah')
Node('hello', Node(' world!', Node(' hah', Empty())))
&gt;&gt;&gt; split(' ', 'a   b')
Node('this', Node('', Node('', Node('is', Empty()))))
</code></pre>
<pre><code class="language-haskell">ghci&gt; split '.' "hello. world!. hah"
["hello"," world!"," hah"]
ghci&gt; split ' ' "a   b"
["a","","","b"]
</code></pre>
<blockquote>
<p>Hint: The <code>split</code> function in Haskell was defined in the hands-on section in <a href="railway_pattern/./validation.html">Chapter 4.4 (Railway Pattern#Validation)</a>.</p>
</blockquote>
<h4 id="question-32-csv-parsing"><a class="header" href="#question-32-csv-parsing">Question 3.2: CSV Parsing</a></h4>
<p>The Python <code>csv</code> library allows us to read CSV files to give us a list of rows, each row being a list of cells, and each cell is a string. Our goal is to do something similar using the list data structure.</p>
<p>A CSV-string is a string where each row is separated by <code>\n</code>, and in each row, each cell is separated by <code>,</code>. Our goal is to write a function <code>csv</code> that receives a CSV-string and puts all the cells in a two-dimensional list. Example runs follow.</p>
<pre><code class="language-python">&gt;&gt;&gt; csv('a,b,c\nd,e\nf,g,h')
Node(Node('a', Node('b', Node('c', Empty()))), 
Node(Node('d', Node('e', Empty())), 
Node(Node('f', Node('g', Node('h', Empty()))), 
Empty())))
</code></pre>
<pre><code class="language-haskell">ghci&gt; csv "a,b,c\nd,e\nf,g,h"
[["a","b","c"],["d","e"],["f","g","h"]]
</code></pre>
<h2 id="question-4-3"><a class="header" href="#question-4-3">Question 4</a></h2>
<p>The formula \(n\choose k\) is incredibly useful and has applications in domains like <del>gambling</del>probability and statistics, combinatorics etc. The way to compute \(n\choose k\) is straightforward:
\[\binom{n}{k} = \frac{n!}{k!(n - k)!}\]</p>
<h4 id="question-41-factorial"><a class="header" href="#question-41-factorial">Question 4.1: Factorial</a></h4>
<p>Clearly, being able to compute factorials would make computing \(\binom{n}{k}\) more convenient. Therefore, write a function <code>factorial</code> that computes the factorial of a nonnegative integer. Do so in Python and Haskell. Example runs follow.</p>
<pre><code class="language-python">&gt;&gt;&gt; factorial(4)
24
&gt;&gt;&gt; factorial(5)
120
</code></pre>
<pre><code class="language-haskell">ghci&gt; factorial 4
24
ghci&gt; factorial 5
120
</code></pre>
<h4 id="question-42-safe-factorial"><a class="header" href="#question-42-safe-factorial">Question 4.2: Safe Factorial</a></h4>
<p>Just like we have done in Question 2, our goal is to make our functions safer! Re-define <code>factorial</code> so that we can drop the assumption that the integer is nonnegative. In addition, your function should receive the name of a variable so that more descriptive error messages can be emitted. Use the <code>Either</code> type. Again, do so in Python and Haskell. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; factorial(4, 'n')
Right(24)
&gt;&gt;&gt; factorial(5, 'k')
Right(120)
&gt;&gt;&gt; factorial(-1, 'n')
Left('n cannot be negative!')
&gt;&gt;&gt; factorial(-1, 'k')
Left('k cannot be negative!')
</code></pre>
<pre><code class="language-haskell">ghci&gt; factorial 4 "n"
Right 24
ghci&gt; factorial 5 "k"
Right 120
ghci&gt; factorial (-1) "n"
Left "n cannot be negative!"
ghci&gt; factorial (-1) "k"
Left "k cannot be negative!"
</code></pre>
<h4 id="question-43-safe-n-choose-k"><a class="header" href="#question-43-safe-n-choose-k">Question 4.3: Safe n choose k</a></h4>
<p>Now let us use <code>factorial</code> to define \(n\choose k\)! Use the formula described at the beginning of the question and our <code>factorial</code> functions to define a function <code>choose</code> that receives integers \(n\) and \(k\) and returns \(n\choose k\). Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; choose(5, 2)
Right(10)
&gt;&gt;&gt; choose(-1, -3)
Left('n cannot be negative!')
&gt;&gt;&gt; choose(1, -3)
Left('k cannot be negative!')
&gt;&gt;&gt; choose(3, 6)
Left('n - k cannot be negative!')
</code></pre>
<pre><code class="language-haskell">ghci&gt; choose 5 2
Right 10
ghci&gt; choose (-1) (-3)
Left "n cannot be negative!"
ghci&gt; choose 1 (-3)
Left "k cannot be negative!"
ghci&gt; choose 3 6
Left "n - k cannot be negative!"
</code></pre>
<h4 id="question-44-n-choose-k-with-validation"><a class="header" href="#question-44-n-choose-k-with-validation">Question 4.4: n choose k With Validation</a></h4>
<p>Notice that several things could go wrong with \(n\choose k\)! Instead of using <code>Either</code>, change the implementation of <code>factorial</code> so that it uses the <code>Validation</code> applicative instead. This is so that all the error messages are collected. Your <code>choose</code> function definition should not change, aside from its type. Example runs follow.</p>
<pre><code class="language-python">&gt;&gt;&gt; choose(5, 2)
Success(10)
&gt;&gt;&gt; choose(-1, -3)
Failure(['n cannot be negative!', 'k cannot be negative!'])
&gt;&gt;&gt; choose(1, -3)
Failure(['k cannot be negative!'])
&gt;&gt;&gt; choose(3, 6)
Failure(['n - k cannot be negative!'])
</code></pre>
<pre><code class="language-haskell">ghci&gt; choose 5 2
Success 10
ghci&gt; choose (-1) (-3)
Failure ["n cannot be negative!","k cannot be negative!"]
ghci&gt; choose 1 (-3)
Failure ["k cannot be negative!"]
ghci&gt; choose 3 6
Failure ["n - k cannot be negative!"]
</code></pre>
<blockquote>
<p>Tip: With the <code>-XApplicativeDo</code> extension, you can actually use <code>do</code> notation on <code>Functor</code>s and <code>Applicative</code>s. Give it a try by defining <code>choose</code> using <code>do</code>-notation! For more information on the conditions for when you can use <code>Applicative</code> <code>do</code>-notation, see the <a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/applicative_do.html">GHC Users Guide</a>.</p>
</blockquote>
<blockquote>
<p>Note: <code>Validation</code> is not included in Haskell's Prelude. You can use the <code>Validation</code> datatype definition and its supporting typeclass instances as defined in the hands-on portion of <a href="railway_pattern/./validation.html">Chapter 4.4 (Railway Pattern#Validation)</a>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>Monads are a frequently recurring construct in functional programming, declarative programming and computer science, especially in programming language and logical semantics. In this chapter, we dive deeper into programming with monads and some additional supported operations beyond <code>return</code> and <code>&gt;&gt;=</code> and how to use them. Additionally, we show some more frequently used monads that go beyond the railway pattern, and show how monads <em>themselves</em> can be composed using <em>monad transformers</em>.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="more-on-monads"><a class="header" href="#more-on-monads">More on Monads</a></h1>
<p>Recall from <a href="monads/../railway_pattern/monad.html">Chapter 4.5 (Railway Pattern#Monads)</a> that monads support <em>composition in context</em>. This idea extends beyond the composition of functions that each branch out to happy and sad paths in the railway pattern. As you have seen, other types like <code>[]</code> don't have much to do with the railway pattern, but is still a monad. This because as long as a type describes some <em>notion of computation</em>, it can be a monad which supports composition in context. We have also seen how this can be useful when the programming language supports easy monadic computations, for example, with Haskell's <code>do</code> notation.<sup class="footnote-reference"><a href="#1">1</a></sup></p>
<p>However, if you observe the definition of the <code>Monad</code> type class carefully (see <a href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Monad.html">GHC Base: Control.Monad</a>), you might notice that there are more methods and monadic operations than just <code>return</code> and <code>&gt;&gt;=</code>.</p>
<h2 id="ignoring-values"><a class="header" href="#ignoring-values">Ignoring values</a></h2>
<p>In an imperative programming language like Python, we can write standalone expressions as statements, primarily to perform some side-effects. For example:</p>
<pre><code class="language-python">def my_function(x):
    print(x) # standalone statement
    return x
</code></pre>
<p>We can, in fact, write the <code>print</code> statement in the style of <code>z &lt;- print x</code> in Haskell, although that would be useless since that variable's value is not used at all and is not meaningful to begin with:</p>
<pre><code class="language-python">def my_function(x):
    z = print(x) # why?
    return x
</code></pre>
<p>Therefore, monads also have a method <code>&gt;&gt;</code> that basically discards the result of a monadic action. This method has the following type signature, which, in comparing with that of <code>&gt;&gt;=</code> should make this more apparent:</p>
<pre><code class="language-haskell">class Applicative m =&gt; Monad m where
    return :: a -&gt; m a
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
    (&gt;&gt;)  :: m a -&gt;       m b  -&gt; m b
</code></pre>
<p>As you can tell, unlike <code>&gt;&gt;=</code>, the second argument to <code>&gt;&gt;</code> is not a function, but is just another term of the monad. It ignores whatever <code>a</code> is in context in the first argument, and only uses it for sequencing with the second argument of type <code>m b</code>.</p>
<p>Thus, <code>do</code> notation actually uses <code>&gt;&gt;</code> when composing monadic operations when the result of an operation is to be discarded. We give some more rules of <code>do</code> notation, including the rules for translating <code>let</code> binds, which allows <em>pure</em> bindings, in contrast with <code>&lt;-</code> which defines a monadic bind. Note that in <code>do</code> notation, there is no need to write <code>in</code> for <code>let</code> binds:</p>
<pre><code>do s           ==&gt;    s                         -- plain

do e1 &lt;- e2    ==&gt;    e2 &gt;&gt;= (\e1 -&gt; do s)      -- monadic bind
   s

do e           ==&gt;    e &gt;&gt; do s                 -- monadic bind, ignore
   s

do let x = e   ==&gt;    let x = e in do s         -- pure bind
   s
</code></pre>
<p>For example, we have seen how <code>&gt;&gt;=</code> on lists performs a <code>for</code> loop of sorts. For lists, <code>&gt;&gt;</code> does more or less the same thing, except that the values in the previous list cannot be accessed. For example,</p>
<pre><code class="language-haskell">ghci&gt; [1, 2] &gt;&gt;= (\x -&gt; [(x, 3)])
[(1, 3), (2, 3)]
ghci&gt; [1, 2] &gt;&gt;= (\_ -&gt; [3])
[3, 3]
ghci&gt; [1, 2] &gt;&gt; [3]
[3, 3]
</code></pre>
<p>Of course, <code>&gt;&gt;</code> on lists is not particularly useful, but we shall see some uses of <code>&gt;&gt;</code> for other monads shortly.</p>
<h2 id="monadic-equivalents-of-functions"><a class="header" href="#monadic-equivalents-of-functions">Monadic Equivalents of Functions</a></h2>
<p>Due to the prevalence of monads, many of the familiar functions like <code>map</code> and <code>filter</code> have monadic equivalents. These are usually written with a postfix <code>M</code>, such as <code>mapM</code> or <code>filterM</code>. In addition, such functions can also ignore results and are written with a postfix <code>_</code>, such as <code>mapM_</code> or <code>filterM_</code>. We show what we mean by "monadic equivalent" by juxtaposing the type signatures of some familiar functions and their monadic counterparts:</p>
<pre><code class="language-haskell">map      ::            (a -&gt; b)   -&gt; [a] -&gt; [b]
mapM @[] :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]

filter  ::            (a -&gt; Bool)   -&gt; [a] -&gt; [a]
filterM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]
</code></pre>
<p>Let us see some examples of <code>mapM</code> in action:</p>
<pre><code class="language-haskell">ghci&gt; map (+2) [1, 2, 3]
[3, 4, 5]
ghci&gt; map (Just . (+2)) [1, 2, 3]
[Just 3, Just 4, Just 5]
ghci&gt; mapM (Just . (+2)) [1, 2, 3]
Just [3, 4, 5]
</code></pre>
<p>One example of <code>mapM</code> over lists and <code>Maybe</code>s is with validation. Let us suppose we want to read a list of strings as a list of integers. To start with, we can use a function <code>readMaybe</code> that attempts to parse a <code>String</code> into a desired data type:</p>
<pre><code class="language-haskell">ghci&gt; import Text.Read
ghci&gt; :{
ghci| toInt :: String -&gt; Maybe Int
ghci| toInt = readMaybe
ghci| :}
ghci&gt; toInt "123"
Just 123
ghci&gt; toInt "hello"
Nothing
</code></pre>
<p>The <code>mapM</code> function allows us to ensure that all elements of a list of strings can be converted into <code>Int</code>s!</p>
<pre><code class="language-haskell">ghci&gt; mapM toInt ["1", "2", "3"]
Just [1, 2, 3]
ghci&gt; mapM toInt ["hello", "1", "2"]
Nothing
</code></pre>
<h2 id="monadic-controls"><a class="header" href="#monadic-controls">Monadic Controls</a></h2>
<p>Another useful tool that comes with monads are control functions. For example, in an imperative program we might write something like the following:</p>
<pre><code class="language-python">def f(x):
    if x &gt; 10:
        print(x)
    return x
</code></pre>
<p>In Haskell, since <code>if</code>-<code>else</code> statements are actually expressions and must have an <code>else</code> branch, we might have to write something like the following:</p>
<pre><code class="language-haskell">f x = do
    if x &gt; 10
    then someAction x
    else return () -- basically does nothing
    return x
</code></pre>
<p>Notice the <code>return ()</code> expression. Because every "statement" in a <code>do</code> block must be monadic, we must write a monadic expression in every branch. In addition, we are clearly using <code>someAction</code> for its monadic effects, so the "returned" value is completely useless, likely just <code>()</code> (the unit type, which means nothing significant). Therefore, the corresponding <code>else</code> branch must also evaluate to <code>m ()</code> for whatever monad <code>m</code> we are working with. This is a chore and much less readable!</p>
<p>Instead, we can use regular functions to simulate <code>if ... then ...</code> statements in a monadic expression. This is the <code>when</code> function defined in <code>Control.Monad</code><sup class="footnote-reference"><a href="#2">2</a></sup>:</p>
<pre><code class="language-haskell">when :: Applicative f =&gt; Bool -&gt; f () -&gt; f ()
</code></pre>
<p>As you can tell, <code>when</code> receives a boolean condition and one monadic action and gives you a monadic action. Importantly, the monad wraps around <code>()</code>, which means that this operation is useful for some monadic effect, such as <code>IO</code>. This allows our function above to be written as:</p>
<pre><code class="language-haskell">import Control.Monad
f x = do
    when (x &gt; 10) (someAction x)
    return x
</code></pre>
<p>Although later we will see that the monadic action <code>someAction</code> can actually cause side effects, it is not necessarily the case that side effects are the only reason why a monadic action <code>m ()</code> is useful. Another example of this is the <code>guard</code> function:</p>
<pre><code class="language-haskell">guard :: Alternative f :: Bool -&gt; f ()
</code></pre>
<p>If the monad you are working with is also an <code>Alternative</code>, the <code>guard</code> function, essentially, places a guard (like guards in imperative programming) based on a condition, returning the sad path immediately if the condition fails. To see this in action, let us see how we can use <code>guard</code> to implement <code>safeDiv</code>:</p>
<pre><code class="language-haskell">import Control.Monad

safeDiv1 :: Int -&gt; Int -&gt; Maybe Int
safeDiv1 x y = if y == 0
               then Nothing
               else Just (x `div` y)

safeDiv2 :: Int -&gt; Int -&gt; Maybe Int
safeDiv2 x y
    = do guard (y /= 0)
         return $ x `div` y
</code></pre>
<p>An <code>Alternative</code> is an applicative structure that has an <code>empty</code> case. For example, an <code>empty</code> list is <code>[]</code>, and an <code>empty</code> <code>Maybe</code> is <code>Nothing</code>. The definition of <code>guard</code> makes this really simple:</p>
<pre><code class="language-haskell">guard :: Alterative f =&gt; Bool -&gt; f ()
guard True = pure ()
guard False = empty
</code></pre>
<p>Notice how <code>guard</code> works in <code>safeDiv2</code>. If <code>y</code> is not <code>0</code>, then <code>guard (y /= 0)</code> evaluates to <code>Just ()</code>. Sequencing <code>Just ()</code> with <code>return $ x `div` y</code> gives <code>Just (x `div` y)</code>. However, if <code>y</code> is equal to <code>0</code>, then <code>guard (y /= 0)</code> evaluates to <code>Nothing</code>. We know that <code>Nothing &gt;&gt;= f</code> for any <code>f</code> will always give <code>Nothing</code>, so <code>Nothing &gt;&gt; x</code> will also always give <code>Nothing</code>. Therefore, <code>Nothing &gt;&gt; return (x `div` y)</code> will give us <code>Nothing</code>. As you can see, <code>guard</code> makes monadic control easy!</p>
<p>As before, <code>guard</code> works on any <code>Alternative</code>. For this reason, let us see how <code>guard</code> works in the <code>[]</code> monad:</p>
<pre><code class="language-haskell">ghci&gt; import Control.Monad
ghci&gt; ls = [-2, -1, 0, 1, 2]
ghci&gt; :{
ghci&gt; ls2 = do x &lt;- ls
ghci|          guard (x &gt; 0)
ghci|          return x
ghci| :}
ghci&gt; ls2
[1, 2]
</code></pre>
<p>As you can see, <code>guard</code> essentially places a filter on the elements of the list! This is because <code>[()] &gt;&gt; ls</code> just gives <code>ls</code>, whatever <code>ls</code> is, and <code>[] &gt;&gt; ls</code> just gives <code>[]</code>. In fact, <code>&gt;&gt;</code> over lists somewhat like the following function using a <code>for</code> loop in Python:</p>
<pre><code class="language-python">&gt;&gt;&gt; def myfunction(ls2, ls):
...     x = []
...     for _ in ls2:
...         x.extend(ls)
...     return x
&gt;&gt;&gt; my_function([()], [1, 2, 3])
[1, 2, 3]
&gt;&gt;&gt; my_function([], [1, 2, 3])
[]
</code></pre>
<p>As you can tell, if <code>f</code> is <code>False</code>, then <code>guard f &gt;&gt; ls</code> will give <code>[]</code>; otherwise, it will just give <code>ls</code> itself. This makes it such that we now have a way to filter elements of a list! Better still, if we combined this with something else:</p>
<pre><code class="language-haskell">ghci&gt; import Control.Monad
ghci&gt; ls = [-2, -1, 0, 1, 2]
ghci&gt; :{
ghci&gt; ls2 = do x &lt;- ls
ghci|          guard (x &gt; 0)
ghci|          return $ x * 2
ghci| :}
ghci&gt; ls2
[2, 4]
</code></pre>
<p>Notice how we have just recovered list comprehension! The definition of <code>ls2</code> can also be written as the following:</p>
<pre><code class="language-haskell">ghci&gt; ls = [-2, -1, 0, 1, 2]
ghci&gt; ls2 = [x * 2 | x &lt;- ls, x &gt; 0]
ghci&gt; ls2
[2, 4]
</code></pre>
<p>Thus, as you can see, list comprehensions are just monadic binds and guards specialized to lists! Even better, <code>do</code> notation allows you to use <code>guards</code>, monadic binds etc. in any order and over any monad, giving you maximum control over how you write monadic programs.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Other languages like Scala also have similar facilities for writing monadic computations. In fact, the Lean 4 programming language takes Haskell's <code>do</code> notation much further <a href="monads/more_monads.html#do-unchained">(Ullrich and de Moura; 2022)</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>The monadic control functions described in this section are defined in the <code>Control.Monad</code> module in Haskell's <code>base</code> library, i.e., they need to be imported, but do not need to be installed (just like the <code>math</code> library in Python).</p>
</div>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p><a id="do-unchained" class="cite">Sebastian Ullrich and Leonardo de Moura. 2022. <code>do</code> Unchained: Embracing Local Imperativity in a Purely Functional Language (Functional Pearl). <i>Proceedings of the ACM on Programming Languages (PACMPL)</i>. 6(ICFP) Article 109 (August 2022), 28 pages. URL: <a class="cite" href="https://doi.org/10.1145/3547640">https://doi.org/10.1145/3547640</a>.</a></p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="commonly-used-monads"><a class="header" href="#commonly-used-monads">Commonly Used Monads</a></h1>
<p>Thus far, we have looked at monads like <code>[]</code>, <code>Maybe</code> and <code>Either</code>. Recall that these monads describe the following notions of computation:</p>
<ul>
<li><code>[]</code>: nondeterminism</li>
<li><code>Maybe</code>: potentially empty computation</li>
<li><code>Either a</code>: potentially failing computation</li>
</ul>
<p>However, there are many more monads that you will frequently encounter, and in fact, many libraries (even in other programming languages) expose classes or data types that work as monads. Most of these monads involve one or both of the following notions of computation:</p>
<ol>
<li>Reading from state</li>
<li>Writing to, or editing state</li>
</ol>
<p>In fact, side effects can also be seen as reading from and writing to state. In this section, we shall describe some commonly used monads that implement these ideas.</p>
<h2 id="reader"><a class="header" href="#reader">Reader</a></h2>
<p>A very common pattern of computation is <em>reading from state</em>, i.e. performing computations based on some environment. For example, we may have a local store of users in an application, from which we retrieve some user information and do stuff with it. Typically, this is represented by a plain function of type <code>env -&gt; a</code>, where <code>env</code> is the environment to read from, and <code>a</code> is the type of the result that depends on the environment. For example, we can determine if two nodes are connected in a graph by using depth-first search—however, connectivity of two nodes depends on the graph, where two nodes might be connected in one graph, but not in another. Therefore, the result of a depth-first search depends on the graph. However, depth-first search requires us to look up the neighbours of a node so that we can recursively search them, thereby also depending on the graph. As such, we want some way to compose two functions that receive a graph (monadically).</p>
<p>In general, we can let any term of type <code>env -&gt; a</code> be seen as a term of type <code>a</code> that depends on an environment <code>env</code>. In other words, the type <code>env -&gt; ?</code> describes the notion of computation of something depending on an environment. And as it turns out, for any environment type <code>env</code>, the partially applied type <code>(-&gt;) env</code> i.e. <code>env -&gt; a</code> for all <code>a</code> is a <code>Monad</code>!</p>
<pre><code class="language-haskell">instance Functor ((-&gt;) env) where
    fmap :: (a -&gt; b) -&gt; (env -&gt; a) -&gt; (env -&gt; b)
    fmap f x = f . x

instance Applicative ((-&gt;) env) where
    pure :: a -&gt; (env -&gt; a)
    pure = const
    (&lt;*&gt;) :: (env -&gt; (a -&gt; b)) -&gt; (env -&gt; a) -&gt; env -&gt; b
    (&lt;*&gt;) f g x = f x (g x)

instance Monad ((-&gt;) env) where
    return :: a -&gt; (env -&gt; a)
    return = pure
    (&gt;&gt;=) :: (env -&gt; a) -&gt; (a -&gt; (env -&gt; b)) -&gt; env -&gt; b
    (&gt;&gt;=) m f x = f (m x) x
</code></pre>
<p>The definition of <code>fmap</code> is incredibly straightforward, essentially just doing plain function composition. The definition of <code>pure</code> is just <code>const</code>, where <code>const</code> is defined to be <code>const x = \_ -&gt; x</code>, i.e. <code>pure</code> receives some value and produces a function that ignores the environment and produces that value. <code>&lt;*&gt;</code> takes two functions <code>f</code> and <code>g</code> and performs applicative application by applying each of them to the same environment <code>x</code>. Most notably, <code>&lt;*&gt;</code> applies the same environment <em>unmodified</em> to both functions. Finally, <code>&gt;&gt;=</code> operates pretty similar to <code>&lt;*&gt;</code> except with some changes to how the functions are applied.</p>
<p>For clarity, let's define a type alias <code>Reader env a</code> which means that it is a type that reads an environment of type <code>env</code> and returns a result of type <code>a</code>:</p>
<pre><code class="language-haskell">type Reader = (-&gt;)
</code></pre>
<p>Then, let's try to implement depth-first search with the <code>Reader</code> monad. First, we define some additional types, like the graph, which for us, has nodes as integers, and is represented using an adjacency list:</p>
<pre><code class="language-haskell">type Node = Int
type Graph = [(Node, [Node])]
</code></pre>
<p>Next, we define a function <code>getNeighbours</code> which gets the nodes that are adjacent to a node in the graph:</p>
<pre><code class="language-haskell">getNeighbours :: Node -&gt; Reader Graph [Node]
getNeighbours x = do
    neighbours &lt;- lookup x
    return $ concat neighbours
</code></pre>
<p>Notice that our <code>getNeighbours</code> function does not refer to the graph at all! We can just use <code>do</code> notation, and Haskell knows how to compose these computations!</p>
<p>Using <code>getNeighbours</code>, we can now define <code>dfs</code> which performs a depth-first search via recursion:</p>
<pre><code class="language-haskell">dfs :: Node -&gt; Node -&gt; Reader Graph Bool
dfs src dst = aux [] src where
  aux :: [Node] -&gt; Node -&gt; Reader Graph Bool
  aux visited current
    | arrived         = return True
    | alreadyVisited  = return False
    | otherwise       = do
      neighbours &lt;- getNeighbours current
      ls &lt;- mapM (aux (current : visited)) neighbours
      return $ or ls
      where arrived = current == dst
            alreadyVisited = current `elem` visited
</code></pre>
<p>Let us learn how this works. Within the <code>dfs</code> function we define an auxiliary function that has a <code>visited</code> parameter. This is so that a user using the <code>dfs</code> function will not have to pass in the empty list as our <code>visited</code> "set". The <code>aux</code> function is where the main logic of the function is written. The first two cases are straightforward: (1) if we have arrived at the destination then we return <code>True</code>, and (2) if we have already visited the current node then we return <code>False</code>. If both (1) and (2) are not met, then we must continue searching the graph. We first get the neighbours of the current node using the <code>getNeighbours</code> function, giving us <code>neighbours</code>, which are the neighbours of the current node. Then, we recursively map <code>aux</code> (thereby recursively performing <code>dfs</code>) over all the neighbours. However, since <code>aux</code> is a monadic operation, we use <code>mapM</code> to map over the neighbours, giving us a list of results. We finally just check whether any of the nodes give us a positive result using the <code>or</code> function, corresponding to the <code>any</code> function in Python. Note one again that our <code>dfs</code> function makes no mention of the map at all, and we do not even need to pass the map into <code>getNeighbours</code>! The <code>Reader</code> monad automatically passes the same environment into all the other <code>Reader</code> terms that receive the environment.</p>
<p>Using the <code>dfs</code> function is very simple. Since the <code>Reader</code> monad is actually just a function that receives an environment and produces output, to use a <code>Reader</code> term, we can just pass in the environment we want!</p>
<pre><code class="language-haskell">ghci&gt; my_map = [(1, [2, 3])
              , (2, [1])
              , (3, [1, 4])
              , (4, [3])
              , (5, [6])
              , (6, [5])]
ghci&gt; dfs 5 6 my_map
True
ghci&gt; dfs 5 2 my_map
False
ghci&gt; dfs 1 2 [] -- empty map
False
</code></pre>
<p>Finally, note that we can retrieve the environment directly within the <code>Reader</code> monad by just using the identity function <code>id</code>!</p>
<pre><code class="language-haskell">ask :: Reader env env
ask = id

getNeighbours :: Node -&gt; Reader Graph [Node]
getNeighbours x = do
    my_graph &lt;- ask -- gets the graph directly
    let neighbours = lookup x my_graph
    return $ concat neighbours
</code></pre>
<h2 id="writer"><a class="header" href="#writer">Writer</a></h2>
<p>The dual of a <code>Reader</code> is a <code>Writer</code>. In other words, instead of reading from some state or environment, the <code>Writer</code> monad has state that it writes to. The simplest example of this is logging. When writing an application, some (perhaps most) operations should be logged, so that we developers have usage information, crash dumps and so on, which can be later analysed.</p>
<p>In general, we can let any term of type <code>(log, a)</code> be seen as a type <code>a</code> that also has a log <code>log</code>. And as it turns out, for any log type <code>log</code>, the partially applied type <code>(log,)</code>, i.e. <code>(log, a)</code> for all <code>a</code> is a <code>Monad</code>!</p>
<pre><code class="language-haskell">instance Functor (log,) where
    fmap :: (a -&gt; b) -&gt; (log, a) -&gt; (log, b)
    fmap f (log, a) = (log, f a)

instance Monoid log =&gt; Applicative (log,) where
    pure :: a -&gt; (log, a)
    pure = (mempty,)
    (&lt;*&gt;) :: (log, a -&gt; b) -&gt; (log, a) -&gt; (log, b)
    (&lt;*&gt;) (log1, f) (log2, x) = (log1 `mappend` log2, f x)

instance Monad (log,) where
    return :: a -&gt; (log, a)
    return = pure
    (&gt;&gt;=) :: (log, a) -&gt; (a -&gt; (log, b)) -&gt; (log, b)
    (log, a) &gt;&gt;= f = let (log2, b) = f a
                     in  (log1 `mappend` log2, b)
</code></pre>
<p>Let's carefully observe what the instances say. The <code>Functor</code> instance is straightforward—it applies the mapping function onto the second element of the tuple. The <code>Applicative</code> and <code>Monad</code> instances are more interesting. Importantly, just like the definition of the <code>Applicative</code> instance for <code>Validation</code>, the two logs are to be combined via an associative binary operation <code>&lt;&gt;</code>, which in this case is <code>mappend</code>. In most occasions, <code>mappend</code> is the same as <code>&lt;&gt;</code>. However, applicatives must also have a <code>pure</code> operation. In the case of <code>Either</code> and <code>Validation</code>, <code>pure</code> just gives a <code>Right</code> or <code>Success</code>, therefore not requiring any <code>log</code>. However, in a tuple, we need some "empty" <code>log</code> to add to the element to wrap in the tuple.</p>
<p>Thus, the <code>log</code> not only must have an associative binary operation, it needs some "empty" term that acts as the identity of the binary operation:
\[E\oplus\textit{empty}=\textit{empty}\oplus E=E\]
\[E_1\oplus(E_2\oplus E_3)=(E_1\oplus E_2)\oplus E_3\]</p>
<p>This is known as a <code>Monoid</code>, which is an extension of <code>Semigroup</code>!</p>
<pre><code class="language-haskell">class Semigroup a =&gt; Monoid a where
    mempty :: a
    mappend :: a -&gt; a -&gt; a
</code></pre>
<p>Typically, <code>mappend</code> is defined as <code>&lt;&gt;</code>.</p>
<p>Recall that <code>[a]</code> with concatenation is a <code>Semigroup</code>. In fact, <code>[a]</code> is also a <code>Monoid</code>, where <code>mempty</code> is the empty list!</p>
<pre><code>ls ++ [] = [] ++ ls = ls
x ++ (y ++ z) = (x ++ y) ++ z
</code></pre>
<p>Therefore, as long as <code>a</code> is a <code>Monoid</code>, then <code>(a, b)</code> is a monad!</p>
<p>Lastly, just like how <code>Reader</code>s have an <code>ask</code> function which obtains the environment, <code>Writer</code>s have a <code>write</code> function which writes a message to your log—the definition of <code>write</code> makes this self-explanatory.</p>
<pre><code class="language-haskell">write :: w -&gt; (w, ())
write = (,())
</code></pre>
<p>Let us see this monad in action. Just like with <code>Validation</code>, we are going to let <code>[String]</code> be our log.</p>
<pre><code class="language-haskell">type Writer = (,)
type Log = [String]
</code></pre>
<p>Then, we write an example simple function that adds a log message:</p>
<pre><code class="language-haskell">loggedAdd :: Int -&gt; Int -&gt; Writer Log Int
loggedAdd x y = do
    let z = x + y
    write [show x ++ " + " ++ show y ++ " = " ++ show z]
    return z
</code></pre>
<p>Composing these functions is, once again, incredibly straightforward with <code>do</code> notation!</p>
<pre><code class="language-haskell">loggedSum :: [Int] -&gt; Writer Log Int
loggedSum [] = return 0
loggedSum (x:xs) = do
    sum' &lt;- loggedSum xs
    loggedAdd x sum'
</code></pre>
<p>With this, the <code>loggedSum</code> function receives a list of integers and returns a pair containing the steps it took to arrive at the sum, and the sum itself:</p>
<pre><code class="language-haskell">ghci&gt; y = loggedSum [1, 2, 3]
ghci&gt; snd y
6
ghci&gt; fst y
["3 + 0 = 3","2 + 3 = 5","1 + 5 = 6"]
</code></pre>
<h2 id="state"><a class="header" href="#state">State</a></h2>
<p>However, many times, we will also want to compose functions that do <em>both</em> reading from, and writing to or modifying state. In essence, it is somewhat a combination of the <code>Reader</code> and <code>Writer</code> monads we have seen. One example is pseudorandom number generation. A pseudorandom number generator receives a seed, and produces a random number and the next seed, which can then be used to generate more random numbers. The type signature of a pseudorandom number generation function would be something of the form:</p>
<pre><code class="language-haskell">randomInt :: Seed -&gt; (Int, Seed)
</code></pre>
<p>This pattern extends far beyond random number generation, and can be used to encapsulate the idea of a stateful transformation. For this, let us define a type called <code>State</code>:</p>
<pre><code class="language-haskell">newtype State s a = State { runState :: s -&gt; (a, s) }
</code></pre>
<p>Notice the <code>newtype</code> declaration. A <code>newtype</code> declaration is basically a <code>data</code> declaration, except that it must have exactly one constructor with exactly one field. In other words, a <code>newtype</code> declaration is a wrapper over a single type, in our case, the type <code>s -&gt; (a, s)</code>. <code>newtype</code>s only differ from their wrapped types while programming and during type checking, but have no operational differences—after compilation, <code>newtype</code>s are represented exactly as the type they wrap, thereby introducing no additional overhead. However, <code>newtype</code> declarations also behave like <code>data</code> declarations, which allow us to create a new type from the types they wrap, allowing us to give new behaviours to the new type.</p>
<p>With this in mind, let us define the <code>Monad</code> instance for our <code>State</code> monad:</p>
<pre><code class="language-haskell">instance Functor (State s) where
    fmap :: (a -&gt; b) -&gt; State s a -&gt; State s b
    fmap f (State f') = State $ 
        \s -&gt; let (a, s') = f' s
              in  (f a, s')

instance Applicative (State s) where
    pure :: a -&gt; State s a
    pure x = State (x,)
    (&lt;*&gt;) :: State s (a -&gt; b) -&gt; State s a -&gt; State s b
    (&lt;*&gt;) (State f) (State x) = State $ 
        \s -&gt; let (f', s') = f s
                  (x', s'') = x s'
              in  (f' x', s'')

instance Monad (State s) where
    return :: a -&gt; State s a
    return = pure
    (&gt;&gt;=) :: State s a -&gt; (a -&gt; State s b) -&gt; State s b
    (State f) &gt;&gt;= m = State $ 
        \s -&gt; let (a, s') = f s
                  State f' = m a
              in  f' s'
</code></pre>
<p>The instance definitions are tedious to define. Furthermore, nothing worthy of note is defined—the methods implement straightforward function composition. However, it is these methods that allow us to compose stateful computation elegantly!</p>
<p>Finally, just like <code>ask</code> for <code>Reader</code>s and <code>write</code> for <code>Writer</code>s, we have <code>get</code> and <code>put</code> to retrieve and update the state of the monad accordingly, and an additional <code>modify</code> function which modifies the state:</p>
<pre><code class="language-haskell">put :: s -&gt; State s ()
put s = State $ const ((), s)

get :: State s s 
get = State $ \s -&gt; (s, s)

modify :: (s -&gt; s) -&gt; State s ()
modify f = do s &lt;- get
              put (f s)
</code></pre>
<p>Let's try this with an example. Famously, computing the fibonacci numbers in a naive recursive manner is incredibly slow. Instead, by employing memoization, we can take the time complexity of said function from \(O(2^n)\) down to \(O(n)\). Memoization requires retrieving and updating state, making it an ideal candidate for using the <code>State</code> monad!</p>
<p>We first define our state to be a table storing inputs and outputs of the function. Then, writing the fibonacci function is straightforward. Note the use of <code>Integer</code> instead of <code>Int</code> so that we do not have integer overflow issues when computing large fibonacci numbers:</p>
<pre><code class="language-haskell">type Memo = [(Integer, Integer)]
getMemoized :: Integer -&gt; State Memo (Maybe Integer)
getMemoized n = lookup n &lt;$&gt; get

fib :: Integer -&gt; Integer
fib n = fst $ runState (aux n) [] where
  aux :: Integer -&gt; State Memo Integer
  aux 0 = return 0
  aux 1 = return 1
  aux n = do 
    x &lt;- getMemoized n
    case x of
        Just y -&gt; return y
        Nothing -&gt; do
            r1 &lt;- aux (n - 1)
            r2 &lt;- aux (n - 2)
            let r = r1 + r2
            modify ((n, r) :)
            return r
</code></pre>
<p>The <code>getMemoized</code> function essentially just performs a lookup of the memoized input from the state. Then, the <code>fib</code> function defines an auxiliary function <code>aux</code> like before, which contains the main logic describing the computation of the fibonacci numbers. In particular, the <code>aux</code> function returns <code>State Memo Integer</code>. As such, to access the underlying state processing function produced by <code>aux n</code>, we must use the <code>runState</code> accessor function as defined in the <code>newtype</code> declaration for <code>State</code>. <code>runState (aux n)</code> gives us a function <code>Memo -&gt; (Integer, Memo)</code>, and thus passing in the empty memo (<code>runState (aux n) []</code>) gives us the result. The result is a pair <code>(Integer, Memo)</code>, and since we do not need the memo after the result has been computed, we just discard it and return it from <code>fib</code>.</p>
<p>The <code>aux</code> function is similarly straightforward, with the usual two base cases. In the recursive case <code>aux n</code>, we first attempt to retrieve any memoized result using the <code>getMemoized</code> function. If the result has already been computed (<code>Just y</code>), then we return the memoized result directly. Otherwise, we recursively compute <code>aux (n - 1)</code> and <code>aux (n - 2)</code>. Importantly, <code>aux (n - 1)</code> will perform updates to the state (the memo), which is then passed along automatically (via monadic bind) to the call to <code>aux (n - 2)</code>, eliminating the exponential time complexity. Once <code>r1</code> and <code>r2</code> have been computed, the final result is <code>r</code>. Of course, we add the entry <code>n -&gt; r</code> into the memo, and we can do so using the <code>modify</code> function, where <code>modify ((n, r) :)</code> prepends the pair <code>(n, r)</code> onto the memo. Of course, we finally return <code>r</code> after all of the above has been completed.</p>
<p>The result of this is polynomial-time <code>fib</code> function that can comfortably compute large fibonacci numbers:</p>
<pre><code class="language-haskell">ghci&gt; fib 1
1
ghci&gt; fib 5
5
ghci&gt; fib 10
55
ghci&gt; fib 20
6765
ghci&gt; fib 100
354224848179261915075
ghci&gt; fib 200
280571172992510140037611932413038677189525
</code></pre>
<h2 id="io"><a class="header" href="#io">I/O</a></h2>
<p>Until now, we still have no idea how Haskell performs simple side effects like reading user input or printing to the console. In fact, nothing we have discussed so far involves side effects, because Haskell is a purely functional programming language, and all functions are pure. One of the key innovations of monads is that it allows a purely functional programming language like Haskell to produce side effects... but how?</p>
<p>Typically, a function that produces side effects is a regular function, except that it will also cause some additional effects on the side. One example is the <code>print</code> function in Python, which has the following type signature:</p>
<pre><code class="language-python">def print(x: object) -&gt; NoneType: # prints to the console
    # ...
</code></pre>
<p>However, notice that the <code>State</code> monad is somewhat similar. A term of <code>State s a</code> wraps a function <code>s -&gt; (a, s)</code>; it is a pure function that is meant to compute a term of type <code>a</code>. However, it has the additional effect of depending on some state of type <code>s</code>, and will also produce some new state also of type <code>s</code>. Therefore, <code>State s a</code> can be seen as an impure function/term of type <code>a</code>, with the side effect of altering state.</p>
<p>What if the state <code>s</code> was actually the real world itself? In essence, the function <code>RealWorld -&gt; (a, RealWorld)</code> is a function that receives the real world (as in, literally the world), and produces some term <code>a</code> and a new state of the world? In this view, a function that prints to the console receives the current state of the world and computes nothing (just like how <code>print</code> in Python returns <code>None</code>), and also produces the new state of the world where text has been printed to the console. Then, <code>input</code> in Python can be seen as a function that receives a state of the world containing user input, and produces the value entered by the user, retaining the current state of the world! These functions can thus actually be seen as <em>pure functions</em>, as long as we view the real world as a term in our programming language! In essence:</p>
<blockquote>
<p>The <code>IO</code> monad is the <code>State</code> monad where the state is the real world.</p>
</blockquote>
<p>This is how Haskell, a purely functional programming language, performs I/O, a side effect. In fact, our characterization of <code>IO</code> is not merely an analogy, but is exactly how <code>IO</code> is represented in Haskell:</p>
<pre><code class="language-haskell">newtype IO a = IO (State# RealWorld -&gt; (# State# RealWorld, a #))
</code></pre>
<p>As such, after learning how the <code>State</code> monad works, performing I/O in Haskell should now be straightforward, especially with <code>do</code> notation. Let us finally, after five chapters, write a "Hello World" program.</p>
<pre><code class="language-haskell">main :: IO ()
main = putStrLn "Hello World!"
</code></pre>
<p>The <code>putStrLn</code> function has type <code>String -&gt; IO ()</code>. It essentially receives a string to print, and alters the state of the world by adding the string to the console.</p>
<p>Importantly, every Haskell program can be seen as the <code>main</code> function, which has type <code>IO ()</code>. Recall that <code>IO</code> is just the <code>State</code> monad, which wraps a function that receives the state of the real world at function application, and produces a new state of the world and some other pure computation. In essence, the <code>main</code> function therefore has type <code>State# RealWorld -&gt; (# State# RealWorld, () #)</code>. Therefore, we can see, roughly, that when a Haskell program is run, the current state of the world is passed into <code>main</code>, giving us a new state of the world where the program has completed execution!</p>
<p>Just like the <code>State</code> monad, we can compose <code>IO</code> operations monadically with <code>do</code> notation. For example, the <code>getLine</code> function has type <code>IO String</code>, similar to <code>input</code> in Python except it does not receive and print a prompt. Thus, we can write a program that reads the name of a user and says hello to that user like so:</p>
<pre><code class="language-haskell">-- Main.hs
main :: IO ()
main = do
    name &lt;- getLine
    putStrLn $ "Hello " ++ name ++ "!"
</code></pre>
<p>Now, instead of loading the program with GHCi, we can <em>compile</em> this program with GHC into an executable!</p>
<pre><code>ghc Main.hs
</code></pre>
<p>When we run the program, the program waits for us to enter a name, then says hello to us!</p>
<pre><code class="language-output info">Yong Qi
Hello Yong Qi!
</code></pre>
<p>Other <code>IO</code> operations can be found in Haskell's Prelude, and these should be relatively straightforward to understand.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="monad-transformers"><a class="header" href="#monad-transformers">Monad Transformers</a></h1>
<p>Monads support <em>composition in context</em>. Another question to ask is, can we <em>compose monads</em>? In other words, can we combine monads together?</p>
<p>Consider the example of finding the length of the path between two connected neighbours in a directed graph, except that we have each node connected to at most one edge. The way we might solve this problem is, once again, via DFS (which in this case is the same as BFS), except that our graph is now of type <code>[(Node, Node)]</code> and our function returns the length of the path instead of a <code>Bool</code> value describing whether the path exists:</p>
<pre><code class="language-haskell">type Node = Int
type Graph = [(Node, Node)]
dfs :: Node -&gt; Node -&gt; Graph -&gt; Maybe Int
dfs src dst gph = aux src [] gph where
    aux :: Node -&gt; [Node] -&gt; Graph -&gt; Maybe Int
    aux current visited gph'
      | arrived = return 0
      | alreadyVisited = Nothing
      | otherwise  = do
          n &lt;- lookup current gph
          (+1) &lt;$&gt; aux n (current : visited) gph'
      where arrived = current == dst
            alreadyVisited = current `elem` visited
</code></pre>
<p>Notice that just like our previous definition of <code>dfs</code>, all our functions such as <code>dfs</code> and <code>lookup</code> involve some environment which we need to pass around! Let us try changing everything of type <code>Graph -&gt; Maybe Int</code> to <code>Reader Graph (Maybe Int)</code> and modify our environment to no longer receive the <code>gph</code> argument:</p>
<pre><code class="language-haskell">type Node = Int
type Graph = [(Node, Node)]
dfs :: Node -&gt; Node -&gt; Reader Graph (Maybe Int)
dfs src dst = aux src [] where
    aux :: Node -&gt; [Node] -&gt; Reader Graph (Maybe Int)
    aux current visited 
      | arrived = return 0
      | alreadyVisited = Nothing
      | otherwise  = do
          n &lt;- lookup current
          (+1) &lt;$&gt; aux n (current : visited)
      where arrived = current == dst
            alreadyVisited = current `elem` visited
</code></pre>
<p>Unfortunately, our code doesn't type check. This is because now our <code>do</code> block performs the monadic operations based on the definition of <code>Reader</code>, not on <code>Maybe</code>! As such, we may need significant rewrites to our function to introduce the <code>Reader</code> monad to our <code>Maybe</code> computation.</p>
<h2 id="enriching-the-maybe-monad"><a class="header" href="#enriching-the-maybe-monad">Enriching the <code>Maybe</code> Monad</a></h2>
<p>Is there a better way? Yes! Let us try defining a new monad <code>ReaderMaybe</code> that essentially acts as both the <code>Reader</code> and the <code>Maybe</code> monads!</p>
<pre><code class="language-haskell">newtype ReaderMaybe env a = ReaderMaybe { runReaderMaybe :: Reader env (Maybe a) }

instance Functor (ReaderMaybe env) where
  fmap :: (a -&gt; b) -&gt; ReaderMaybe env a -&gt; ReaderMaybe env b
  fmap f (ReaderMaybe ls) = ReaderMaybe $ fmap (fmap f) ls

instance Applicative (ReaderMaybe env) where
  pure :: a -&gt; ReaderMaybe env a
  pure = ReaderMaybe . pure . pure
  (&lt;*&gt;) :: ReaderMaybe env (a -&gt; b) -&gt; ReaderMaybe env a -&gt; ReaderMaybe env b
  (ReaderMaybe f) &lt;*&gt; (ReaderMaybe x) = ReaderMaybe $ do
    maybe_f &lt;- f
    case maybe_f of 
      Nothing -&gt; return Nothing
      Just f' -&gt; do
        maybe_x &lt;- x
        case maybe_x of 
          Nothing -&gt; return Nothing
          Just x' -&gt; return $ Just (f' x')

instance Monad (ReaderMaybe env) where
  return :: a -&gt; ReaderMaybe env a
  return = pure
  (&gt;&gt;=) :: ReaderMaybe env a -&gt; (a -&gt; ReaderMaybe env b) -&gt; ReaderMaybe env b
  (ReaderMaybe ls) &gt;&gt;= f = ReaderMaybe $ do
    m &lt;- ls
    case m of
      Just x -&gt; runReaderMaybe $ f x
      Nothing -&gt; return Nothing
</code></pre>
<p>All of these methods are tedious to define, however are somewhat straightforward. In particular, it relies on <code>do</code> notation on <code>Reader</code>s to extract out the <code>Maybe</code> values, and performs the usual <code>Maybe</code> methods to compose them.</p>
<p>The result is that we can now make use of this <code>ReaderMaybe</code> monad in our <code>dfs</code> function:</p>
<pre><code class="language-haskell">dfs :: Node -&gt; Node -&gt; Graph -&gt; Maybe Int
dfs src dst = runReaderMaybe (aux src []) where
    aux :: Node -&gt; [Node] -&gt; ReaderMaybe Graph Int
    aux current visited 
      | arrived = return 0
      | alreadyVisited = ReaderMaybe $ return Nothing
      | otherwise  = do
          n &lt;- ReaderMaybe $ lookup current 
          (+1) &lt;$&gt; aux n (current : visited)
      where arrived = current == dst
            alreadyVisited = current `elem` visited
</code></pre>
<p>There are several points worthy of note in our new implementation:</p>
<ol>
<li>Most of this definition is the same as our original definition that works on the <code>Maybe</code> monad</li>
<li>Because the <code>aux</code> function returns a <code>ReaderMaybe</code> term which wraps the actual <code>Reader</code> function, we write <code>runReaderMaybe (aux src [])</code> to expose the actual <code>Reader Graph (Maybe Int)</code> function</li>
<li>In the <code>alreadyVisited</code> case, we cannot write <code>alreadyVisited = Nothing</code> since <code>Nothing</code> is not of the type <code>ReaderMaybe Graph Int</code>; we also cannot just write <code>return Nothing</code> since that has type <code>ReaderMaybe env (Maybe a)</code>. As such, we have to use <code>return @(Reader Graph) Nothing</code>, then wrap it in the <code>ReaderMaybe</code> constructor</li>
<li>Similar to (3), instead of <code>lookup current</code>, we have to wrap it around the <code>ReaderMaybe</code> constructor so that instead of having type <code>Reader Graph (Maybe Int)</code>, <code>ReaderMaybe $ lookup current</code> will have type <code>ReaderMaybe Graph Int</code>, which is the correct type to have.</li>
</ol>
<p>When converting the original implementation based on <code>Maybe</code> into the new implementation based on <code>ReaderMaybe Graph Int</code>, one tip is to leave the implementation the same and just change the type signature of the functions to use <code>ReaderMaybe Graph Int</code> instead of <code>Graph -&gt; Maybe Int</code>, then make use of typing information to correct the types in the program; in other words, "let the types guide your programming", like we have done in <a href="monads/../types/README.html">Chapter 2 (Types)</a>! Furthermore, we are generally assured that everything works as expected because monads behave in the <em>most obvious way</em>!</p>
<p>Just like that, we are able to compose the <code>Reader</code> monad with the <code>Maybe</code> monad! Running <code>dfs</code> works exactly as we'd expect:</p>
<pre><code class="language-haskell">ghci&gt; my_map = [(1, 2), (2, 3), (3, 1)]
ghci&gt; dfs 1 4 my_map
Nothing
ghci&gt; dfs 1 2 my_map
Just 1
ghci&gt; dfs 2 1 my_map
Just 2
</code></pre>
<p>Now, what if we wanted to enrich the <code>Maybe</code> monad with other notions of computation, such as <code>[]</code>, <code>IO</code> etc? Suppose we follow the same procedure of enriching <code>Maybe</code> with <code>Reader</code>, but instead by enriching it with <code>IO</code>, giving us a new monad <code>IOMaybe a</code> which represents <code>IO (Maybe a)</code>:</p>
<pre><code class="language-haskell">newtype IOMaybe a = IOMaybe { runIOMaybe :: IO (Maybe a) }

instance Functor IOMaybe where
  fmap :: (a -&gt; b) -&gt; IOMaybe a -&gt; IOMaybe b
  fmap f (IOMaybe io) = IOMaybe (fmap (fmap f) io)

instance Applicative IOMaybe where
  pure :: a -&gt; IOMaybe a
  pure = IOMaybe . pure . pure
  (&lt;*&gt;) :: IOMaybe (a -&gt; b) -&gt; IOMaybe a -&gt; IOMaybe b
  (IOMaybe f) &lt;*&gt; (IOMaybe x) = IOMaybe $ do
    maybe_f &lt;- f
    case maybe_f of 
      Nothing -&gt; return Nothing
      Just f' -&gt; do
        maybe_x &lt;- x
        case maybe_x of 
          Nothing -&gt; return Nothing
          Just x' -&gt; return $ Just (f' x')

instance Monad IOMaybe where
  return :: a -&gt; IOMaybe a
  return = pure
  (&gt;&gt;=) :: IOMaybe a -&gt; (a -&gt; IOMaybe b) -&gt; IOMaybe b
  (IOMaybe m) &gt;&gt;= f = IOMaybe $ do
    maybe_m &lt;- m
    case maybe_m of
      Just x -&gt; runIOMaybe $ f x
      Nothing -&gt; return Nothing
</code></pre>
<p>There are several things worth thinking about. Firstly, so far, it appears that we have to re-create new instances for <em>every</em> notion of computation we want to enrich <code>Maybe</code> with. Secondly, you might realise that absolutely nothing about the definition of the instances care about the enriching monad. All of the definitions in the methods for <code>ReaderMaybe</code> and <code>IOMaybe</code> do not mention any <code>Reader</code>-specific or <code>IO</code>-specific functions. Instead, they all rely on their respective monad binds! Therefore, we can abstract these into a <em>monad transformer</em>.</p>
<h2 id="monad-transformers-1"><a class="header" href="#monad-transformers-1">Monad Transformers</a></h2>
<p>A monad transformer <code>MonadT m a</code> enriches <code>Monad</code> with <code>m</code>. For example, the <code>MaybeT m a</code> monad transformer enriches <code>Maybe</code> with <code>m</code>. Therefore, our <code>ReaderMaybe</code> and <code>IOMaybe</code> monads can be represented exactly as <code>MaybeT (Reader env)</code> and <code>MaybeT IO</code>! The definition of <code>MaybeT</code> is virtually the exact same as the definitions of <code>ReaderMaybe</code> and <code>IOMaybe</code>, except that we do not refer to <code>Reader</code> or <code>IO</code>, and leave them as <code>m</code>:</p>
<pre><code class="language-haskell">newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }

instance (Functor m) =&gt; Functor (MaybeT m) where
    fmap f (MaybeT x) = MaybeT $ fmap (fmap f) x

instance (Functor m, Monad m) =&gt; Applicative (MaybeT m) where
    pure = MaybeT . return . Just
    mf &lt;*&gt; mx = MaybeT $ do
        mb_f &lt;- runMaybeT mf
        case mb_f of
            Nothing -&gt; return Nothing
            Just f  -&gt; do
                mb_x &lt;- runMaybeT mx
                case mb_x of
                    Nothing -&gt; return Nothing
                    Just x  -&gt; return (Just (f x))

instance (Monad m) =&gt; Monad (MaybeT m) where
    return = MaybeT . return . Just
    x &gt;&gt;= f = MaybeT $ do
        v &lt;- runMaybeT x
        case v of
            Nothing -&gt; return Nothing
            Just y  -&gt; runMaybeT (f y)
</code></pre>
<p>With this <code>Maybe</code> monad transformer, we can rewrite our definition of <code>dfs</code> by replacing <code>ReaderMaybe Graph Int</code> with <code>MaybeT (Reader Graph) Int</code>!</p>
<pre><code class="language-haskell">dfs :: Node -&gt; Node -&gt; Graph -&gt; Maybe Int
dfs src dst = runMaybeT (aux src []) where
    aux :: Node -&gt; [Node] -&gt; MaybeT (Reader Graph) Int
    aux current visited 
      | arrived = return 0
      | alreadyVisited = MaybeT $ return Nothing
      | otherwise  = do
          n &lt;- MaybeT $ lookup current 
          (+1) &lt;$&gt; aux n (current : visited)
      where arrived = current == dst
            alreadyVisited = current `elem` visited
</code></pre>
<p>And now with the <code>MaybeT</code> monad transformer, we can enrich the <code>Maybe</code> monad with any other monad we want without having to redefine new types and new type class instances for each of the monads we are enriching <code>Maybe</code> with!</p>
<h2 id="monad-transformer-library"><a class="header" href="#monad-transformer-library">Monad Transformer Library</a></h2>
<p>Because monads are so common in programming, the common monads already have their own monad transformers, and these are defined in the <a href="https://hackage.haskell.org/package/transformers"><code>transformers</code></a> and <a href="https://hackage.haskell.org/package/mtl"><code>mtl</code></a> libraries. If you want to use these commonly used monad transformers, just download the dependencies and <code>import</code> the libraries into your programs! But... how do we do that?</p>
<h3 id="build-tools-and-package-managers"><a class="header" href="#build-tools-and-package-managers">Build Tools and Package Managers</a></h3>
<p>Most production programming languages have a package manager and build tool, and Haskell is no different. In fact, Haskell has <em>several</em> package managers and build tools you can use. Two of the main competing ones are <a href="https://www.haskell.org/cabal/"><code>cabal</code></a> and <a href="https://docs.haskellstack.org/en/stable/"><code>stack</code></a>, both of which can be installed via <a href="https://www.haskell.org/ghcup/">GHCup</a>. For our purposes, we shall just use <code>cabal</code> since it is slightly simpler to use; most modern versions are generally fine, but for us, we shall use (at least) <code>cabal-3.10.3</code>.</p>
<h3 id="project-initialization"><a class="header" href="#project-initialization">Project Initialization</a></h3>
<p>Using <code>cabal</code> is very simple. First, to create a new Haskell project, create an empty directory and run <code>cabal init</code> (<code>&gt;</code> is the shell prompt of the terminal, do not enter <code>&gt;</code> as part of the command)</p>
<pre><code class="language-output info">&gt; mkdir my-project
&gt; cd my-project
&gt; cabal init
</code></pre>
<p>Then, <code>cabal</code> will take you through a series of questions to initialize the project. Some notable options are:</p>
<ul>
<li>Executables are programs that can be executed; libraries are code that other Haskell users can import. For us, choose to build an executable</li>
<li>The main module of the executable should be <code>Main.hs</code>. The <code>Main.lhs</code> option is for writing <a href="https://wiki.haskell.org/Literate_programming">literate Haskell</a> programs. You can use that as well, although for us, it is significantly easier to just use <code>Main.hs</code> and write plain Haskell programs.</li>
<li>The language for our executable should be GHC2021, giving us as many of the latest features as we can have without having to include them as language extensions.</li>
</ul>
<p>The result of running <code>cabal init</code> is that your project directory has been initialized with several parts:</p>
<ul>
<li>The <code>app</code> directory (or whatever name you have chosen) stores the source code of your program</li>
<li><code>my-project.cabal</code> is the specification of your project.</li>
</ul>
<h3 id="project-configuration"><a class="header" href="#project-configuration">Project Configuration</a></h3>
<p>Let us investigate what is in <code>my-project.cabal</code> (some comments and fields omitted for concision):</p>
<pre><code class="language-haskell">cabal-version:      3.0
-- ...
common warnings
    ghc-options: -Wall
executable my-project
    import:           warnings
    main-is:          Main.hs

    -- Modules included in this executable, other than Main.
    -- other-modules:

    -- LANGUAGE extensions used by modules in this package.
    -- other-extensions:

    -- Other library packages from which modules are imported.
    build-depends:    base ^&gt;=4.17.2.1

    -- Directories containing source files.
    hs-source-dirs:   app

    -- Base language which the package is written in.
    default-language: GHC2021
</code></pre>
<p>The <code>executable my-project</code> clause describes some of the specifications of our project. In particular, the <code>build-depends</code> field describes any external dependencies we wish to include. These dependencies can be automatically pulled from Hackage by <code>cabal</code>, as long as we specify the name, and optionally the version, of the package. For example, we want the <code>Control.Monad.Trans.Maybe</code> module in <code>transformers</code> library. Hence, to include the <code>transformers</code> library to have access to monad transformers, just include <code>transformers</code> in <code>build-depends</code>.</p>
<pre><code class="language-haskell">-- ...
executable my-project
    -- ...
    -- Other library packages from which modules are imported.
    build-depends:    base ^&gt;=4.17.2.1
                    , transformers
    -- ...
</code></pre>
<p>Then, run <code>cabal install</code> to install all our dependencies!</p>
<pre><code class="language-output">&gt; cabal install
/path/to/my-project-0.1.0.0.tar.gz
Resolving dependencies...
Symlinking 'my-project' to '/path/to/.local/bin/my-project'
</code></pre>
<p>And that's all! Just like that, we now have access to <code>transformers</code> functions, data types, classes and methods!</p>
<h3 id="writing-the-program"><a class="header" href="#writing-the-program">Writing the Program</a></h3>
<p>Let us try creating a simple executable program in our project. First, we create our simple graph library. Right now, our project directory looks like this:</p>
<pre><code class="language-output">my-project/
├─ my-project.cabal
├─ app/
│   └─ Main.hs
└─ ...
</code></pre>
<p>Let us create a simple graph library by creating a file <code>my-project/app/Data/Graph.hs</code>, therefore our directory structure becomes:</p>
<pre><code class="language-output">my-project/
├─ my-project.cabal
├─ app/
│   ├─ Main.hs
│   └─ Data/
│        └─ Graph.hs
└─ ...
</code></pre>
<p>This creates a new module called <code>Data.Graph</code>. We must include this in our <code>cabal</code> file so that <code>cabal</code> knows to compile it as well. Head back to <code>my-project.cabal</code>, and include <code>Data.Graph</code> in the <code>other-modules</code> field:</p>
<pre><code class="language-haskell">-- ...
executable my-project
    -- ...
    -- Modules included in this executable, other than Main.
    other-modules:    Data.Graph
    -- ...
</code></pre>
<p>Now, open <code>Graph.hs</code> and write some code! In particular:</p>
<ol>
<li>Declare the name of the module. In this case, the module is called <code>Data.Graph</code> because it is in the <code>Data</code> directory and the file name is <code>Graph.hs</code>.</li>
<li>Import the <code>Control.Monad.Trans.Maybe</code> module to have access to <code>MaybeT</code>, and the <code>Control.Monad.Trans.Reader</code> monad to have access to the <code>Reader</code> monad.</li>
<li>Define our <code>dfs</code> function.</li>
</ol>
<pre><code class="language-haskell">module Data.Graph where

import Control.Monad.Trans.Maybe
import Control.Monad.Trans.Reader

type Graph = [(Node, Node)]
type Node = Int

type GraphProcessor = MaybeT (Reader Graph) Int

dfs :: Node -&gt; Node -&gt; Graph -&gt; Maybe Int
dfs src dst = runReader $ runMaybeT (aux src []) where
    aux :: Node -&gt; [Node] -&gt; GraphProcessor
    aux current visited 
      | arrived = return 0
      | alreadyVisited = MaybeT $ return Nothing
      | otherwise  = do
          n &lt;- MaybeT $ reader $ lookup current 
          (+1) &lt;$&gt; aux n (current : visited)
      where arrived = current == dst
            alreadyVisited = current `elem` visited
</code></pre>
<p>Note that our <code>Reader</code> monad shown in the previous chapter is quite different to the one defined in <code>transformers</code>. In fact, <code>Reader env a</code> is actually defined as <code>ReaderT env Identity a</code>. This is because it is generally quite uncommon to use the <code>Reader</code> monad by itself, since what it represents is just a plain function. The <code>ReaderT</code> monad transformer is defined as such:</p>
<pre><code class="language-haskell">newtype ReaderT r m a = ReaderT { runReaderT :: r -&gt; m a }
type Reader env a = ReaderT env Identity a
</code></pre>
<p>And the <code>Identity</code> monad is completely uninteresting:</p>
<pre><code class="language-haskell">newtype Identity a = Identity { runIdentity :: a }
</code></pre>
<p>As such, the <code>transformers</code> library exposes some helper functions to make working with the plain <code>Reader</code> monad easier; for example, the <code>runReader</code> function extracts the enclosed function from a <code>ReaderT</code>, and the <code>reader</code> function transforms a function into a <code>ReaderT</code>.</p>
<p>We are done with our <code>Graph</code> library. Now, open <code>app/Main.hs</code> and write the following to see our <code>dfs</code> function in action (note that <code>print</code> is defined as <code>putStrLn . show</code>)!</p>
<pre><code class="language-haskell">module Main where

import Data.Graph

myGraph :: Graph
myGraph = [(1, 2), (2, 3), (3, 1), (4, 5)]

main :: IO ()
main = do
  print $ dfs 1 2 myGraph
  print $ dfs 1 5 myGraph
</code></pre>
<p>We are done with developing our simple application! Compiling and running our program is simple with the help of build tools like <code>cabal</code>. In the terminal, just enter <code>cabal run</code> to compile the program (if changes have been made) and execute it!</p>
<pre><code class="language-output info">&gt; cabal run
Just 1
Nothing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="monads-in-the-wild"><a class="header" href="#monads-in-the-wild">Monads in the Wild</a></h1>
<p>Monads are so ubiquitous in programming that most libraries (even in general-purpose programming languages) expose monads. For example, the ReactiveX library in Java, which provides facilities for reactive programming, exposes an <code>Observable</code> class, which is a monad. In addition, most stream processors in data streaming libraries (across many languages) are also monads. You will typically know when something is a monad if it has a method called <code>flatMap</code>, which is the same as <code>&gt;&gt;=</code> in Haskell.</p>
<p>Therefore, whenever you are defining your own libraries for your own needs, think about what behaviours your library should support:</p>
<ul>
<li>Does your library involve nondeterminism or streams/lists of data?</li>
<li>Does your library perform I/O?</li>
<li>Does your library produce potentially empty computation?</li>
<li>Does your library potentially fail?</li>
<li>Does your library read from an environment?</li>
<li>Does your library write to additional state?</li>
<li>Does your library process state?</li>
</ul>
<p>If the answer to one (or more) of the questions above is yes, chances are, your library should expose a monad! Furthermore, if you are writing Haskell code, your library functions can likely be described as the composition of some of the commonly used monads provided in Haskell's Prelude, the <code>transformers</code> library, or the <code>mtl</code> library.</p>
<p>Give this a try in the exercises and the assignment!</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>In software engineering, the need to perform multiple tasks simultaneously gives rise to two (not mutually exclusive) approaches: concurrency and parallelism. For example, game servers are not monolithic entities; rather, a game server comprises many components, each interacting with the external world. One component might be dedicated to managing user chats, while several others process players' inputs and relay state updates back to them. Meanwhile, yet another component might be tasked with the complex calculations of game physics. This phenomenon is widely known as <em>concurrency</em>. Importantly, the successful operation of such a concurrent program doesn’t necessarily rely on multiple processing cores, though their presence can certainly enhance performance and responsiveness.</p>
<p>On the other hand, <em>parallel</em> programs are typically centered around solving a single problem. For example, the act of summing the numbers in a large stream can be done sequentially; however, we prefer to split the large stream into smaller segments, and have one core dedicated to summing one segment, essentially allowing many cores to work in <em>parallel</em> to compute the main result. This is known as <em>parallelism</em>. Similarly, the functionality of a parallel program doesn’t inherently depend on the availability of multiple cores.</p>
<p>Another key distinction between concurrent and parallel programs is how they engage with the outside world. By their very nature, concurrent programs are in constant interaction with networking protocols, databases, and similar systems. In contrast, a typical parallel program tends to be more focused in its operation. It streams in data, processes it intensively for a period, and then outputs the results, with minimal further I/O during that time.</p>
<p>The lines between concurrency and parallelism can often be blurred, particularly in traditional programming languages that compel developers to utilize the same constructs for both approaches.</p>
<p>In this chapter, we will see how functional programming concepts can be applied to concurrency and parallelism. For our course, assume that all our concurrent and parallel programs operate within the confines of a single OS process. We will then briefly look at some pitfalls of traditional concurrent and parallel programming, and see how purely functional languages tackle these.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="concurrent-programming"><a class="header" href="#concurrent-programming">Concurrent Programming</a></h1>
<p>In a usual <em>sequential</em> program, we do one thing completely after another. For example, if there are two tasks to do, <code>A</code> and <code>B</code>, then we will do <code>A</code> until completion, then do <code>B</code> until completion:</p>
<pre><code>do A completely
do B completely
</code></pre>
<p>In a <em>concurrent</em> program, we do a little bit of either, arbitrarily:</p>
<pre><code>work on A for 2ms
work on B for 1ms
work on A for 3ms
work on B for 6ms
work on A for 1ms
...
</code></pre>
<p>One of the advantages of writing concurrent programs (even in the presence of only a single operating system process) is that it would appear to the user that both tasks are executed simultaneously, making the program feel more fluid and have lower latency.</p>
<p>Typically, most programming languages provide building blocks for writing concurrent programs in the form of independent <em>threads of control</em>. Haskell is no exception. In Haskell, a thread is an I/O action that executes independently of other threads. To create a thread, we import the <code>Control.Concurrent</code> module and use the <code>forkIO</code> function. In the following example, we have one I/O action that writes <code>Hello World!</code> to a new file called <code>it5100a-notes.md</code>, and use <code>forkIO</code> to independently execute that I/O action in a separate thread immediately.</p>
<pre><code class="language-haskell">ghci&gt; import Control.Concurrent
ghci&gt; :t forkIO
forkIO :: IO () -&gt; IO ThreadId
ghci&gt; import System.Directory
ghci&gt; forkIO (writeFile "it5100a-notes.md" "Hello World!") &gt;&gt; doesFileExist "it5100a-notes.md"
False
</code></pre>
<p>The Haskell runtime does not specify an order in which threads are executed. Thus, the file <code>it5100a-notes.md</code> created by the new thread may or may not have been created by the time the original thread checks for its existence. If we try this example once, and then remove <code>it5100a-notes.md</code> and try again, we may get a different result the second time. In general, concurrent programs are <em>nondeterministic</em>.</p>
<p>From earlier, we stated that concurrent programs can "hide" the latency of programs by executing multiple tasks concurrently. This makes applications more responsive. For example, a web browser needs to process user input (like button clicks etc.) and page loads or running JavaScript processes. If a web browser were programmed sequentially, then the page must load completely before the user can interact with the browser at all. In addition, JavaScript processes will usually be running in the background, and while it is doing so, the user cannot interact with the browser either. However, since web browsers are (almost always) concurrent, the user can continue to interact with them while background processes are running, even if the browser is only running on a single CPU core.</p>
<p>A toy example demonstrating this is as follows. We shall write a program that receives some user input and creates a large file with user specified contents:</p>
<pre><code class="language-haskell">import Data.List

writeContents :: String -&gt; String -&gt; IO ()
writeContents file_name contents = do
  let c = intercalate "\n" $ replicate 1000000 (intercalate "" $ replicate 100 contents)
  writeFile file_name c
  putStrLn $ file_name ++ " written"

main :: IO ()
main = do
  putStrLn "Enter filename:"
  x &lt;- getLine
  if x == "exit"
  then return ()
  else do putStrLn "Enter file contents:"
          y &lt;- getLine
          forkIO $ writeContents x y
          main
</code></pre>
<p>Observe the <code>main</code> I/O action. All <code>main</code> does is to read user input. The logic for writing the user input to a file is done by <code>writeContents</code>, which is done on a separate thread. This way, <code>main</code> can read user input immediately after <code>writeContents</code> is forked, and is ready to read more user input again, without having to wait for <code>writeContents</code> to complete its task first. If we hadn't used <code>forkIO</code>, <code>main</code> would perform the writing on the same thread completely, which may take a while, before being able to read user input again.</p>
<h2 id="communication-between-threads"><a class="header" href="#communication-between-threads">Communication Between Threads</a></h2>
<p>The simplest way to share information between two threads is to let them both use a variable. In our file generation, the main thread shares both the name of a file and its contents with the other thread. Because Haskell data is immutable by default, this poses no risks: neither thread can modify the other's view of the file's name or contents. However, we will often need to have threads actively communicating with each other. For example, GHC does not provide a way for one thread to emit data to another thread, or let another thread know that it is still executing or has terminated.</p>
<h3 id="mvars"><a class="header" href="#mvars"><code>MVar</code>s</a></h3>
<p>The way we do this in Haskell is to use a synchronizing variable called the <code>MVar</code>. An <code>MVar</code> is essentially a mutable variable holding a value. You can put something in a variable making it full, and take out the value from a full <code>MVar</code>, making it empty.</p>
<pre><code class="language-haskell">ghci&gt; import Control.Concurrent.MVar
ghci&gt; :t putMVar
putMVar :: MVar a -&gt; a -&gt; IO ()
ghci&gt; :t takeMVar
takeMVar :: MVar a -&gt; IO a
</code></pre>
<p>Importantly, using <code>putMVar</code> on a full <code>MVar</code> causes the thread to <em>block</em> until the <code>MVar</code> becomes empty; dually, using <code>takeMVar</code> on an empty <code>MVar</code> causes the thread to <em>block</em> until the <code>MVar</code> becomes full.</p>
<p>An example of using <code>MVar</code>s is as follows. We are going to use the same toy example from earlier, except we are going to ensure that only one thread can perform file writing. This is so that we do not hog computing resources from other parts of our system (which there aren't, but suppose there are):</p>
<pre><code class="language-haskell">import Data.List
import Control.Concurrent.MVar

writeContents :: String -&gt; String -&gt; MVar () -&gt; IO ()
writeContents file_name contents lock = do
  takeMVar lock 
  putStrLn $ "Write to " ++ file_name ++ " started"
  let !c = intercalate "\n" $ replicate 1000000 (intercalate "" $ replicate 500 contents)
  writeFile file_name c
  putStrLn $ file_name ++ " written"
  putMVar lock ()

mainLoop :: MVar () -&gt; IO ()
mainLoop lock = do
  putStrLn "Enter filename:"
  x &lt;- getLine
  if x == "exit"
  then do takeMVar lock
          return ()
  else do putStrLn "Enter file contents:"
          y &lt;- getLine
          forkIO $ writeContents x y lock
          mainLoop lock

main :: IO ()
main = do
  lock &lt;- newMVar ()
  mainLoop lock
</code></pre>
<p>Upon executing this program, the <code>main</code> I/O action initializes a single <code>MVar</code> which is then passed onto other parts of the program. The <code>mainLoop</code> action does the same as before, except that it receives the <code>lock</code> from <code>main</code>. Note the <code>then</code> branch in <code>mainLoop</code>—if the user enters <code>exit</code>, it waits for the <code>lock</code> to be filled with a value, signalling the completion of file writing, before exiting the program. Importantly, <code>takeMVar</code> wakes up in FIFO order. In other words, we are guaranteed that no more threads of <code>writeContents</code> will be waiting to be executed at this point, because <code>takeMVar</code> will only wake up the <code>mainLoop</code> thread once all earlier <code>writeContents</code> threads have been executed. The <code>writeContents</code> action performs the actual file writing as per usual; however, it first acquires the shared <code>lock</code> before executing the file writing operation, before putting back the <code>lock</code> value. This is so that only one thread can perform <code>writeContents</code> at any time.</p>
<h3 id="channels"><a class="header" href="#channels">Channels</a></h3>
<p>Aside from <code>MVar</code>s, we can also provide one-way communication channels via the <code>Chan</code> type. Threads can write to channels (without blocking), and can read from channels (blocking if the channel is empty):</p>
<pre><code class="language-haskell">ghci&gt; import Control.Concurrent.Chan
ghci&gt; :t writeChan
writeChan :: Chan a -&gt; a -&gt; IO ()
ghci&gt; :t readChan
readChan :: Chan a -&gt; IO a
</code></pre>
<p>An example is as follows:</p>
<pre><code class="language-haskell">import Data.List
import Control.Concurrent.Chan

writeContents :: Chan String -&gt; IO ()
writeContents chan = do
  file_name &lt;- readChan chan
  contents  &lt;- readChan chan
  putStrLn $ "Write to " ++ file_name ++ " started"
  let !c = intercalate "\n" $ replicate 1000000 (intercalate "" $ replicate 500 contents)
  writeFile file_name c
  putStrLn $ file_name ++ " written"
  writeContents chan

mainLoop :: Chan String -&gt; IO ()
mainLoop chan = do
  putStrLn "Enter filename:"
  x &lt;- getLine
  if x == "exit"
  then return ()
  else do putStrLn "Enter file contents:"
          y &lt;- getLine
          writeChan chan x
          writeChan chan y
          mainLoop chan

main :: IO ()
main = do
  chan &lt;- newChan :: IO (Chan String)
  forkIO $ writeContents chan
  mainLoop chan
</code></pre>
<p>In this example, only two threads are ever spawned: (1) the main thread which runs <code>main</code> and <code>mainLoop</code>, which, like before, only reads user input and passes the file name and contents to the other thread, which performs file writing. <code>main</code> initializes the channel and forks another thread to <code>writeContents</code>. <code>mainLoop</code> receives user input and passes them through the channel, which is read by <code>writeContents</code> for file writing.</p>
<h2 id="more-cores"><a class="header" href="#more-cores">More Cores!</a></h2>
<p>Thus far, we have only discussed how the Haskell runtime is able to spark new threads of control. As said before, this does not guarantee that the program is actually running on multiple cores. In fact, by default, the program only runs on a single core. We can inspect this by using the <code>numCapabilities</code> function:</p>
<pre><code class="language-haskell">import GHC.Conc
main :: IO ()
main = print numCapabilities
</code></pre>
<pre><code class="language-output info">&gt; ghc Main.hs
&gt; ./Main
1
</code></pre>
<p>There is in fact, a way to set the number of CPU cores being used by the Haskell runtime. This can be done using the <code>setNumCapabilities</code> function.</p>
<pre><code class="language-haskell">import Control.Concurrent
main :: IO ()
main = do setNumCapabilities 4
          print numCapabilities
</code></pre>
<p>However, compiling and running this program gives a warning:</p>
<pre><code class="language-output info">ghc Main.hs
./Main
Main: setNumCapabilities: not supported in the non-threaded RTS
1
</code></pre>
<p>The reason for this is because Haskell uses two runtime systems: (1) a non-threaded runtime, and (2) a threaded runtime. By default, compiling our program with <code>ghc</code> links the non-threaded runtime, which is not able to leverage multiple cores. Therefore, if we want to use multiple cores, we have to use the threaded runtime instead. This can be done by compiling the program with the <code>-threaded</code> option.</p>
<pre><code class="language-output info">ghc Main.hs -threaded
./Main
4
</code></pre>
<p>Another way to specify the number of cores being used is to provide the <code>+RTS -Nx</code> option, where <code>x</code> is the number of cores we would like to use.</p>
<p>If we are using <code>cabal</code> to build our project, we can provided <code>-threaded</code> as a GHC option via the <code>ghc-options</code> setting:</p>
<pre><code class="language-haskell">executable playground
    -- ...
    ghc-options: -threaded
</code></pre>
<p>And execute it with <code>cabal run -- +RTS -Nx</code>.</p>
<p>Let's give this a try!</p>
<pre><code class="language-haskell">import Data.List
import Control.Concurrent

writeContents :: String -&gt; String -&gt; Chan () -&gt; IO ()
writeContents file_name contents chan = do
  putStrLn $ "Write to " ++ file_name ++ " started"
  let !c = intercalate "\n" $ replicate 1000000 (intercalate "" $ replicate 500 contents)
  writeFile file_name c
  putStrLn $ file_name ++ " written"
  writeChan chan ()

main :: IO ()
main = do
  n &lt;- getNumCapabilities
  putStrLn $ "Number of cores: " ++ show n
  chan &lt;- newChan :: IO (Chan ())
  forkIO $ writeContents "abc" "def" chan
  forkIO $ writeContents "def" "ghi" chan
  _ &lt;- readChan chan
  _ &lt;- readChan chan
  return ()
</code></pre>
<p>This program is simple. The <code>main</code> I/O action creates a channel and passes them to two threads that perform file writing. Once each thread has completed writing the file, they will also write to the channel, signalling completion. The <code>main</code> I/O action will only terminate once both threads have completed.</p>
<p>Let's try timing our program with different runtime options. The first execution command runs our program with 4 cores, while the second one only uses 1. We use the <code>time</code> shell command to time the execution of each program:</p>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N4
Number of cores: 4
Write to abc started
Write to def started
abc written
def written

________________________________________________________
Executed in    6.44 secs    fish           external
   usr time   10.76 secs  379.00 micros   10.76 secs
   sys time    1.15 secs  137.00 micros    1.15 secs
</code></pre>
<pre><code class="language-output info">&gt; time cabal run
Number of cores: 1
Write to def started
Write to abc started
def written
abc written

________________________________________________________
Executed in   12.02 secs    fish           external
   usr time   10.78 secs    0.00 micros   10.78 secs
   sys time    0.84 secs  560.00 micros    0.84 secs
</code></pre>
<p>Notice that the <code>usr</code> and <code>sys</code> times for both are roughly similar. This is not surprising, because <code>usr</code> and <code>sys</code> times reflect CPU execution time; loosely, if the CPU spends 1s executing on one core and 1s executing on another core, then the total of <code>usr</code> and <code>sys</code> time reported with be 2s. This is to be expected, because the same amount of work needs to be done to write to our files. However, what we really want to profile is the <em>real</em> or <em>wall clock</em> time, i.e. how much time had elapsed on the clock. As you can see, the multicore execution ran roughly 2x faster than the single core execution, since we have two files we can write in parallel!</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="parallel-programming"><a class="header" href="#parallel-programming">Parallel Programming</a></h1>
<p>Let us now turn our focus to parallel programming. For many large problems, we could divide them into chunks and evaluate the solution for these chunks at the same time on multiple cores, before combining the results, just like a divide-and-conquer approach. However, doing so is traditionally seen as difficult, and we usually use the same libraries and language primitives that are used for concurrency to develop a parallel program. Writing parallel programs in general-purpose imperative languages can be complex and tedious.</p>
<p>While we could certainly use Haskell’s concurrency features like <code>forkIO</code>, <code>MVar</code> and <code>Chan</code> to develop parallel code, there is a much simpler approach available to us. All we need to do is to annotate some sub-expressions in our functions to make them evaluated in parallel.</p>
<h2 id="non-strict-evaluation"><a class="header" href="#non-strict-evaluation">Non-Strict Evaluation</a></h2>
<p>In the very beginning of this course, we described Haskell as a non-strict evaluation language. That is, Haskell decides the evaluation strategy for us, unlike other strict evaluation languages where things are evaluated in a deterministic and specific format. For example, in Python, a function call is evaluated by first fully evaluating its arguments, then executing each statement in the function from top down. Haskell generally only evaluates terms <em>by need</em>, giving rise to a notion of <em>lazy evaluation</em>.</p>
<p>The key idea of attaining <em>parallelism</em> in Haskell is by specifying <em>parallel evaluation strategies</em>.</p>
<h3 id="strict-evaluation"><a class="header" href="#strict-evaluation">Strict Evaluation</a></h3>
<p>Before we bgin describing how to evaluate terms in parallel, we must first describe how we can even force the evaluation of a term in the first place. For example, in the following program:</p>
<pre><code class="language-haskell">ghci&gt; x = [1..]
ghci&gt; y = sum x
</code></pre>
<p>virtually nothing is evaluated, and GHCI does not enter an infinite loop. This is because there is as yet no demand for the evaluation of <code>y</code>. Of course, if we attempt to evaluate <code>y</code>, we do arrive at an infinite loop, because evaluating the actual sum of <code>x</code> is required to determine what <code>y</code> is.</p>
<p>Therefore, whenever an expression is encountered, Haskell allocates a <em>thunk</em> as a uncomputed placeholder for the result of the expression evaluation. The thunk is only evaluated by need (usually as little as possible) to evaluate other parts of code.</p>
<p>For example:</p>
<pre><code class="language-haskell">ghci&gt; x = [1..]
ghci&gt; case x of { [] -&gt; 0; (x:xs) -&gt; x }
1
</code></pre>
<p>Notice that the <code>case</code> expression demands the evaluation of <code>x</code>. However, it does not demand the <em>complete</em> evaluation of <code>x</code>. Instead, it only demands to know the constructor of <code>x</code>. Therefore, when executing <code>x = [1..]</code>, Haskell puts a completely unevaluated thunk, for <code>x</code>, and the <code>case</code> expression then evaluates <code>x</code> to <em>head normal form</em> (HNF) (evaluating to the constructor but not its arguments)<sup class="footnote-reference"><a href="#1">1</a></sup> to perform the case analysis.</p>
<p>Another example of lazy evaluation is with <code>let</code> expressions:</p>
<pre><code class="language-haskell">ghci&gt; let x = [1..]; y = sum x in 1 + 2
3
</code></pre>
<p>Again, Haskell does not evaluate <code>y</code> at all since it is not demanded in the evaluation of <code>1 + 2</code>!</p>
<p>This may be a problem for concurrency and parallelism, because it is possible for <code>forkIO</code> to push an I/O action to a different thread, only for that thread to allocate an unevaluated thunk for it, and when its evaluation is demanded, the evaluation is done on the main thread!</p>
<pre><code class="language-haskell">expensive :: MVar String -&gt; IO ()
expensive var = do
    putMVar var expensivelyComputedString

main :: IO ()
main = do
    var &lt;- newEmptyMVar
    forkIO $ expensive var
    whatever
    result &lt;- takeMVar var
    print result
</code></pre>
<p>The program above gives the impression that the expensive computation is done on the forked thread. However, in reality, what could happen is that the thread running <code>expensive</code> only allocates a thunk for <code>expensivelyComputedString</code>, and returns. Then, when the <code>result</code> is demanded in the <code>main</code> I/O action running in the main thread, it is the main thread that computes the expensively computed string, thereby, achieving nothing from the concurrency.</p>
<p>It is for this reason that Haskell exposes primitives for deciding the evaluation of expressions. The one most used is <code>seq</code>, which introduces an artificial demand for an expression to be evaluated to head normal form:</p>
<pre><code class="language-haskell">ghci&gt; :t seq
seq :: a -&gt; b -&gt; b
</code></pre>
<p>The expression <code>x `seq` y</code> evaluates to <code>y</code>, but creates an artificial demand for the evaluation of <code>x</code> as well. Therefore, evaluating the following expression does not terminate:</p>
<pre><code class="language-haskell">ghci&gt; let x = [1..]; y = sum x in y `seq` 1 + 2
</code></pre>
<p>However, notice that the following <em>does</em> terminate:</p>
<pre><code class="language-haskell">ghci&gt; let x = [1..] in x `seq` 1 + 2
3
</code></pre>
<p>This is because <code>seq</code> only creates an artificial demand for <code>x</code> to be evaluated to <em>head normal form</em>, i.e. up to the evaluation of its constructor.</p>
<p>What we can do instead is to introduce a new <em>evaluation strategy</em> for forcing the full evaluation of a list:</p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| deepSeq :: [a] -&gt; b -&gt; b
ghci| deepSeq [] x = x
ghci| deepSeq (x:xs) y = x `seq` deepSeq xs y
ghci| :}
ghci&gt; x = [1..]
ghci&gt; x `seq` 1
1
ghci&gt; x `deepSeq` 1
</code></pre>
<p>Using <code>deepSeq</code> now forces the full evaluation of <code>x</code>, which obviously does not terminate because <code>x</code> is infinitely large! However, note that <code>deepSeq</code> only evaluates the <em>elements</em> to HNF—therefore, if <code>x</code> were a, for example, a two-dimensional list, the individual one-dimensional lists in <code>x</code> are only evaluated to HNF, i.e. only their constructors are evaluated.</p>
<h2 id="parallel-evaluation"><a class="header" href="#parallel-evaluation">Parallel Evaluation</a></h2>
<p>Since parallel programming is all about deciding what expressions to evaluate in parallel, all we need is some primitives that tell the compiler to evaluate an expression in parallel, just like <code>seq</code>! The <code>GHC.Conc</code> module exposes two evaluation primitives, <code>par</code> and <code>pseq</code> that allows us to do parallel programming easily:</p>
<pre><code class="language-haskell">ghci&gt; import GHC.Conc
ghci&gt; :t par
par :: a -&gt; b -&gt; b
ghci&gt; :t pseq
pseq :: a -&gt; b -&gt; b
</code></pre>
<p><code>par</code> is straightforward to understand: <code>x `par` y</code> is an expression stating that there is an artificial demand for <code>x</code> that <em>could</em> be evaluated to HNF in <em>parallel</em>. However, <code>par</code> does not <em>guarantee</em> the parallel evaluation of <code>x</code>. This is because <code>x</code> could be a cheap computation that does not need to be, and should not be, evaluated in parallel, or that there are not enough cores available for the parallel evaluation of <code>x</code>.</p>
<p>Then, what is <code>pseq</code> for? Notice this: in an expression <code>x `par` f x y</code>, we claim to want to evaluate <code>x</code> in parallel to HNF, <em>and then</em> combine it with <code>y</code> using <code>f</code> in the current thread. However, this requires a guarantee that <code>y</code> is evaluated on the current thread <em>before</em> the current thread attempts to evaluate <code>x</code>. Otherwise, it could be that <code>par</code> will queue a spark for the evaluation of <code>x</code>, and before a new thread can be sparked for that evaluation, the current thread evaluates <code>f x y</code>, which performs the evaluation of <code>x</code> first; therefore, no parallel evaluation of <code>x</code> happens, defeating of <code>par</code> in the first place.</p>
<p>Therefore, we need some primitive that performs the evaluation of an expression to HNF before another expression. <code>seq</code> does not do this; <code>x `seq` y</code> only claims to evaluate <code>x</code> to HNF, but does not enforce that to happen <em>before</em> <code>y</code>. In contrast, <code>pseq</code> does. <code>x `pseq` y</code> guarantees that the evaluation of <code>x</code> to HNF happens <em>before</em> the evaluation of <code>y</code>.</p>
<p>As such, <code>par</code> and <code>pseq</code> allow us to annotate computations with evaluation strategies to describe what computation happens in parallel, and what that computation is <em>in parallel with</em>. For example, the expression <code>x `par` (y `pseq` f x y)</code> states roughly that <code>x</code> happens in parallel with <code>y</code>, then the results are combined using <code>f</code>.</p>
<p>For example, let us try writing a parallel (but still exponential) fibonacci:</p>
<pre><code class="language-haskell">fib :: Int -&gt; Integer
fib 0 = 0
fib 1 = 1
fib n = n1 `par` (n2 `pseq` (n1 + n2))
  where n1 = fib (n - 1)
        n2 = fib (n - 2)
</code></pre>
<p>Aside from the usual base cases, the recursive case computes the \(n-1\) and \(n - 2\) fibonacci numbers in parallel, then combines them together with addition. Described in words, the recursive case computes <code>fib (n - 1)</code> in parallel with <code>fib (n - 2)</code> by queueing a spark for <code>fib (n - 1)</code> and evaluating <code>fib (n - 2)</code> in the current thread, then adds the results together with plain addition.</p>
<p>Computing <code>fib 45</code> shows that for large values, having more cores makes a big difference.</p>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N20
Number of cores: 20
1134903170

________________________________________________________
Executed in    3.29 secs    fish           external
   usr time   53.14 secs  319.00 micros   53.14 secs
   sys time    0.47 secs  129.00 micros    0.47 secs

</code></pre>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N1
Number of cores: 1
1134903170

________________________________________________________
Executed in   12.93 secs    fish           external
   usr time   12.61 secs  418.00 micros   12.61 secs
   sys time    0.08 secs  171.00 micros    0.08 secs
</code></pre>
<h2 id="when-should-we-parallelize"><a class="header" href="#when-should-we-parallelize">When Should We Parallelize?</a></h2>
<p>However, notice the <code>usr</code> time for the case of running our program on 20 cores. Clearly, the CPU does more than 4x more work than the single core case; it just so happens that leveraging more cores makes the speed-ups outweigh the additional overhead. Indeed, while <code>par</code> is cheap, it is not <em>free</em>. Although Haskell threads are lightweight, threads in general will always incur some additional overhead, and at some point, the benefits of computing something in parallel are outweighed by the overhead of spawning a new thread for its computation. For example, in the case of computing <code>fib 3</code>, it is frankly completely unnecessary to compute <code>fib 2</code> and <code>fib 1</code> in parallel, since both are such small computations that run incredibly quickly.</p>
<p>Let us amend our implementation to only use parallelism for larger values. Smaller values are computed sequentially:</p>
<pre><code class="language-haskell">fib :: Int -&gt; Integer
fib 0 = 0
fib 1 = 1
-- sequential for small n
fib n | n &lt;= 10 = fib (n - 1) + fib (n - 2)
-- parallel for large n
fib n = n1 `par` (n2 `pseq` (n1 + n2))
  where n1 = fib (n - 1)
        n2 = fib (n - 2)
</code></pre>
<p>The execution time shows a significant speed-up on both the single core and multicore runtimes!</p>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N20
Number of cores: 20
1134903170

________________________________________________________
Executed in  892.37 millis    fish           external
   usr time   13.01 secs    646.00 micros   13.00 secs
   sys time    0.18 secs      0.00 micros    0.18 secs


</code></pre>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N1
Number of cores: 1
1134903170

________________________________________________________
Executed in    6.81 secs    fish           external
   usr time    6.71 secs  453.00 micros    6.71 secs
   sys time    0.03 secs    0.00 micros    0.03 secs
</code></pre>
<p>Generally speaking, knowing when to parallelize is a matter of experimentation, trial-and-error and engineering experience. It highly depends on the computation you are trying to parallelize, the kind of computation you are doing, the usual inputs to the computation, and so on.</p>
<h2 id="parallel-strategies"><a class="header" href="#parallel-strategies">Parallel Strategies</a></h2>
<p>Let us try writing a parallel mergesort:</p>
<pre><code class="language-haskell">mergesort :: Ord a =&gt; [a] -&gt; [a]
mergesort [] = []
mergesort [x] = [x]
mergesort ls
  | n &lt; 100 = merge left' right'
  | otherwise = par left' $ pseq right' $ merge left' right'
    where n = length ls `div` 2
          merge [] ys = ys
          merge xs [] = xs
          merge (x:xs) (y:ys)
            | x &lt;= y = x : merge xs (y : ys)
            | otherwise = y : merge (x:xs) ys
          (left, right) = splitAt n ls
          left' = mergesort left
          right' = mergesort right
</code></pre>
<p>Our <code>mergesort</code> function does a typical merge sort, except from the fact that we are using an immutable list. Let us write a supporting <code>main</code> function to test our program:</p>
<pre><code class="language-haskell">main :: IO ()
main = do
  n &lt;- getNumCapabilities
  putStrLn $ "Number of cores: " ++ show n
  let ls :: [Int] = [10000000, 9999999..1]
      ls' = mergesort ls
  print $ length ls'
</code></pre>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N20
Number of cores: 20
10000000

________________________________________________________
Executed in    3.58 secs    fish           external
   usr time   16.02 secs  381.00 micros   16.02 secs
   sys time    1.39 secs  159.00 micros    1.39 secs
</code></pre>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N1
Number of cores: 1
10000000

________________________________________________________
Executed in    6.11 secs    fish           external
   usr time    5.62 secs    0.00 micros    5.62 secs
   sys time    0.43 secs  586.00 micros    0.43 secs
</code></pre>
<p>From before, recall that because Haskell is a lazy language, it may be the case that not all the supposedly parallel computation happens in the other thread. Since both <code>par</code> and <code>pseq</code> evaluate their first arguments only to HNF, it really only does evaluation up until it determines the constructor of the list after sorting, leaving the remainder of the list unevaluated. Then, in <code>main</code>, when we obtain the <code>length</code> of the list, the main thread may then have to evaluate the remainder of the list in the same thread. Let us extract some more performance out of our parallel evaluation by actually evaluating everything deeply in the parallel computation using <code>deepSeq</code> from before:</p>
<pre><code class="language-haskell">mergesort :: Ord a =&gt; [a] -&gt; [a]
mergesort [] = []
mergesort [x] = [x]
mergesort ls
  | n &lt; 100 = merge left' right'
  | otherwise = par (deepSeq left') $ pseq right' $ merge left' right'
    where n = length ls `div` 2
          merge [] ys = ys
          merge xs [] = xs
          merge (x:xs) (y:ys)
            | x &lt;= y = x : merge xs (y : ys)
            | otherwise = y : merge (x:xs) ys
          (left, right) = splitAt n ls
          left' = mergesort left
          right' = mergesort right

deepSeq :: [a] -&gt; ()
deepSeq [] = ()
deepSeq (x:xs) = x `seq` deepSeq xs
</code></pre>
<p>Now we should notice some more performance gains!</p>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N20
Number of cores: 20
10000000

________________________________________________________
Executed in    2.89 secs    fish           external
   usr time   18.04 secs  365.00 micros   18.04 secs
   sys time    0.68 secs  145.00 micros    0.67 secs
</code></pre>
<pre><code class="language-output info">&gt; time cabal run playground -- +RTS -N1
Number of cores: 1
10000000

________________________________________________________
Executed in    6.18 secs    fish           external
   usr time    5.59 secs  362.00 micros    5.59 secs
   sys time    0.46 secs  145.00 micros    0.46 secs
</code></pre>
<p>Some very smart people have also come up with nice and elegant ways to write parallel code. For example, using the <a href="https://hackage.haskell.org/package/parallel"><code>parallel</code></a> library, we can express parallel programs with <code>Strategy</code>'s in the <code>Eval</code> monad:</p>
<pre><code class="language-haskell">mergesort :: (Ord a, NFData a) =&gt; [a] -&gt; [a]
mergesort [] = []
mergesort [x] = [x]
mergesort ls
  | n &lt; 100 = merge left' right'
  | otherwise = runEval $ do
      l &lt;- rparWith rdeepseq left'
      r &lt;- rseq right'
      return $ merge l r
  where n = length ls `div` 2
        (left, right) = splitAt n ls
        left' = mergesort left
        right' = mergesort right
        merge [] ys = ys
        merge xs [] = xs
        merge (x:xs) (y:ys)
          | x &lt;= y = x : merge xs (y : ys)
          | otherwise = y : merge (x:xs) ys
</code></pre>
<p>Strategies also allow us to separate algorithm from evaluation. For example, we can write a parallel fibonacci like so:</p>
<pre><code class="language-haskell">fib :: Int -&gt; Integer
fib 0 = 0
fib 1 = 1
fib n | n &lt;= 10 = fib (n - 1) + fib (n - 2)
fib n = runEval $ do 
    n1 &lt;- rpar (fib (n - 1))
    n2 &lt;- rseq (fib (n - 2))
    return $ n1 + n2
</code></pre>
<p>Alternatively, we can make clear the distinction between the underlying algorithm and the evaluation strategy with <code>using</code>:</p>
<pre><code class="language-haskell">fib :: Int -&gt; Integer
fib 0 = 0
fib 1 = 1
fib n | n &lt;= 10   = n1 + n2
      | otherwise = (n1 + n2) `using` strat
  where n1 = fib (n - 1)
        n2 = fib (n - 2)
        strat v = do { rpar n1; rseq n2; return v }
</code></pre>
<p>We will leave it up to you to learn more about parallel Haskell with the <a href="https://hackage.haskell.org/package/parallel"><code>parallel</code></a> library. For more information, you may read the paper by <a href="concurrent/parallel.html#seqnomore">Marlow et al.; 2010</a> that describes it. We shall not cover these because they, along with <code>par</code> and <code>pseq</code>, are much more Haskell-specific and less applicable to code written in general-purpose languages. The only goal of this chapter, which we hope has been achieved, is to show how easy it is to introduce parallelism to regular sequential programs in a purely functional programming language.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Usually expressions are evaluated to <em>weak head normal form</em> (WHNF), although the distinction is not crucial for our understanding.</p>
</div>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<a id="seqnomore" class="cite">
Simon Marlow, Patrick Maier, Hans-Wolfgang Loidl, Mustafa K. Aswad, and Phil Trinder. 2010. <code>seq</code> No More: Better Strategies for Parallel Haskell. In <i>Proceedings of the third ACM Haskell symposium on Haskell (Haskell '10)</i>. Association for Computing Machinery, New York, NY, USA, 91–102. <a class="cite" href="https://doi.org/10.1145/1863523.1863535">https://doi.org/10.1145/1863523.1863535</a>.
</a>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="software-transactional-memory"><a class="header" href="#software-transactional-memory">Software Transactional Memory</a></h1>
<p>Concurrency and parallelism is, generally, <em>really hard</em>. This is because the ordering of concurrent and parallel evaluation is <em>nondeterministic</em>, and the traditional threaded model of concurrent programming with threads make working with concurrent operations and <em>composing</em> them is very difficult and error-prone. <code>MVar</code>s and Haskell's runtime make this slightly safer (if you have done concurrency in other languages like C before, you might be able to see why), but are still vulnerable to the same issues that plague concurrent and parallel programs.</p>
<p>To give you a toy example, suppose we have two threads, one which acquires two <code>MVar</code>s <code>a</code> and <code>b</code> and adds the value of <code>a</code> to <code>b</code>, and another which swaps their values. One possible implementation might be the following, with a deadly vulnerability hidden in plain sight:</p>
<pre><code class="language-haskell">swap :: MVar a -&gt; MVar a -&gt; Chan () -&gt; IO ()
swap a b chan = do
    x &lt;- takeMVar a
    y &lt;- takeMVar b
    putMVar a y
    putMVar b x
    writeChan chan () -- signal done

addToMVar :: Num a =&gt; MVar a -&gt; MVar a -&gt; Chan () -&gt; IO ()
addToMVar a b chan = do
    y &lt;- takeMVar b
    x &lt;- takeMVar a
    let z = x + y
    putMVar b z
    putMVar a x
    writeChan chan () -- signal done

main :: IO ()
main = do
    a &lt;- newMVar 1 :: IO (MVar Int)
    b &lt;- newMVar 2 :: IO (MVar Int)
    chan &lt;- newChan :: IO (Chan ())
    forkIO $ addToMVar a b chan
    forkIO $ swap a b chan
    _ &lt;- readChan chan
    _ &lt;- readChan chan
    x &lt;- takeMVar a
    y &lt;- takeMVar b
    print x
    print y
    return ()
</code></pre>
<p>In this program, several things could happen:</p>
<ul>
<li><code>swap</code> starts first, and is able to acquire the values from both <code>MVar</code>s <code>a</code> and <code>b</code>, thus executing completely and putting new values to <code>a</code> and <code>b</code> for <code>addToMVar</code> to use</li>
<li><code>addToMVar</code> starts first and is able to acquire the values from both <code>MVar</code>s <code>a</code> and <code>b</code>, thus executing completely and putting new values to <code>a</code> and <code>b</code> for <code>swap</code> to use</li>
<li><code>swap</code> starts first and acquires <code>a</code>, shortly thereafter <code>addToMVar</code> begins and acquires <code>b</code>. Now <code>swap</code> is waiting for <code>b</code>, and <code>addToMVar</code> is waiting for <code>a</code>.</li>
<li><code>addToMVar</code> starts first and acquires <code>b</code>, shortly thereafter <code>swap</code> begins and acquires <code>a</code>. Now <code>swap</code> is waiting for <code>b</code>, and <code>addToMVar</code> is waiting for <code>a</code>.</li>
</ul>
<p>The last two scenarios result in something known as a <em>deadlock</em> and causes all these threads to wait and to be unable to continue. In particular, this deadlock was caused by a <em>lock ordering inversion</em>, a very common mistake that is usually undetectable by the compiler, and only starts causing problems at runtime! Scenarios like these are known as <em>race conditions</em>, and yes, while there are tools to detect <em>race conditions</em>, detecting <em>all</em> race conditions is <em>undecidable</em>, and thus is an impossible problem to solve. Are there tools to help us reduce of likelihood of running into race conditions?</p>
<p>Haskell supports something known as <em>software transactional memory</em> (STM) <a href="concurrent/stm.html#stm">(Harris et al.; 2005)</a>, which is very similar to <em>transactions</em> in databases with ACID guarantees. Notice that this deadlock situation could go away if <code>swap</code> and <code>addToMVar</code> acquired both locks in one atomic operation, so that neither thread can interleave an <code>MVar</code> acquisition! STM provides such facilities to allow us to define, compose and work with atomic transactions. All we need to do is to install the <a href="https://hackage.haskell.org/package/stm"><code>stm</code></a> package!</p>
<h2 id="key-ideas"><a class="header" href="#key-ideas">Key Ideas</a></h2>
<p>Instead of working with the <code>IO</code> monad, STM constructs work within the <code>STM</code> monad. Under the hood, the <code>stm</code> implementation handles all the coordination, so as programmers, as long as we are working within the <code>STM</code> monad, we can regard these operations as atomic. In other words, an STM transaction appears to take place indivisibly. All transactional operations are within <code>STM</code>, and can only be escaped to <code>IO</code> using <code>atomically</code>:</p>
<pre><code class="language-haskell">ghci&gt; import Control.Concurrent.STM
ghci&gt; :t atomically
atomically :: STM a -&gt; IO a
</code></pre>
<p>An <code>atomically</code> block is treated as a single I/O operation, so the <code>STM</code> operations cannot interleave. In addition, the <code>atomically</code> block executes a transaction entirely, or not at all.</p>
<p>Now let us try using <code>STM</code> for communications between threads. We are going to create a transaction for atomically acquiring both <code>MVar</code>s. Of course, instead of <code>MVar</code>, which operates in the <code>IO</code> monad, the <code>Control.Concurrent.STM</code> module exposes a <code>TMVar</code>, sort of like a <em>transactional</em> <code>MVar</code> that lives in the <code>STM</code> monad. Let us write this transaction:</p>
<pre><code class="language-haskell">takeBothTMVars :: TMVar a -&gt; TMVar b -&gt; STM (a, b)
takeBothTMVars a b = do
  x &lt;- takeTMVar a
  y &lt;- takeTMVar b
  return (x, y)
</code></pre>
<p>As you can see, this looks just like an equivalent version written for <code>MVar</code>s:</p>
<pre><code class="language-haskell">takeBothMVars :: MVar a -&gt; MVar b -&gt; IO (a, b)
takeBothMVars a b = do
  x &lt;- takeMVar a
  y &lt;- takeMVar b
  return (x, y)
</code></pre>
<p>Now let us rewrite our original deadlocked program using <code>TMVar</code>s and <code>STM</code>, focusing temporarily on the <code>swap</code> function. Recall that we want to take both <code>TMVar</code>s as a single atomic operation, hence we defined an <code>STM</code> operation <code>takeBothTMVars</code> that does so. To actually perform this operation as a single I/O action, we have to use <code>atomically</code> which performs the transaction, atomically:</p>
<pre><code class="language-haskell">swap :: TMVar a -&gt; TMVar a -&gt; Chan () -&gt; IO ()
swap a b chan = do
    (x, y) &lt;- atomically $ takeBothTMVars a b
    -- ...
</code></pre>
<p>This way, the transaction is done in one fell swoop, and if either <code>TMVar</code>s are empty, the thread running <code>swap</code> will block until both become available. We can do the same for <code>addToMVar</code>, but this time, we are going to introduce lock-order inversion again by swapping the arguments to <code>takeBothTMVars</code>:</p>
<pre><code class="language-haskell">addToMVar :: Num a =&gt; TMVar a -&gt; TMVar a -&gt; Chan () -&gt; IO ()
addToMVar a b chan = do
    (y, x) &lt;- atomically $ takeBothTMVars b a
</code></pre>
<p>Although we swapped the arguments to <code>takeBothTMVars</code>, thereby introducing lock-order inversion, operationally, there is no difference, since <code>takeBothTMVars</code> is regarded as a single atomic operation anyway. We then continue defining the rest of the program which should be similar to before. Importantly, note that to create a new <code>TMVar</code> within <code>IO</code> for coordination, we use the <code>newTMVarIO</code> function;</p>
<pre><code class="language-haskell">import Control.Concurrent
import Control.Concurrent.Chan
import Control.Concurrent.STM

takeBothTMVars :: TMVar a -&gt; TMVar b -&gt; STM (a, b)
takeBothTMVars a b = do
  x &lt;- takeTMVar a
  y &lt;- takeTMVar b
  return (x, y)

putBothTMVars :: TMVar a -&gt; a -&gt; TMVar b -&gt; b -&gt; STM ()
putBothTMVars a x b y = do
  putTMVar a x
  putTMVar b y

swap :: TMVar a -&gt; TMVar a -&gt; Chan () -&gt; IO ()
swap a b chan = do
    (x, y) &lt;- atomically $ takeBothTMVars a b 
    atomically $ putBothTMVars a y b x
    writeChan chan ()

addToMVar :: Num a =&gt; TMVar a -&gt; TMVar a -&gt; Chan () -&gt; IO ()
addToMVar a b chan = do
    (y, x) &lt;- atomically $ takeBothTMVars b a
    let z = x + y
    atomically $ putBothTMVars a x b z
    writeChan chan ()

main :: IO ()
main = do
    a &lt;- newTMVarIO 1 :: IO (TMVar Int)
    b &lt;- newTMVarIO 2 :: IO (TMVar Int)
    chan &lt;- newChan :: IO (Chan ())
    forkIO $ addToMVar a b chan
    forkIO $ swap a b chan
    _ &lt;- readChan chan
    _ &lt;- readChan chan
    x &lt;- atomically $ takeTMVar a
    y &lt;- atomically $ takeTMVar b
    print x
    print y
</code></pre>
<p>We don't have to only use STM for coordination between threads (although that is certainly a great use case). As long as we want atomic memory transactions, it is highly likely that STM is applicable.</p>
<p>For example, suppose we have some in-memory shared state, such as a counter, and users (perhaps across the network) can modify this counter. Modifying the counter requires two things: (1) reading the existing counter, (2) modifying the read value, (3) updating the counter with the modified value. To prevent data races, we want all these operations to be done in one fell swoop (i.e. as a single transaction).</p>
<pre><code class="language-haskell">incVar :: TVar Int -&gt; STM Int
incVar v = do
  x &lt;- readTVar v
  let y = x + 1
  writeTVar v y
  return y
</code></pre>
<p>Now we're not afraid to compose <code>incVar</code> with other STM operations, even if they are done concurrently!</p>
<pre><code class="language-haskell">import Control.Concurrent
import Control.Concurrent.STM

-- Increments a 'TVar'
incVar :: TVar Int -&gt; STM Int
incVar v = do
  x &lt;- readTVar v
  let y = x + 1
  writeTVar v y
  return y

-- IO Action that increments a TVar five times
aIncVar :: TVar Int -&gt; IO ()
aIncVar v = aux 5 where
  aux :: Int -&gt; IO ()
  aux 0 = return ()
  aux n = do
    r &lt;- atomically $ incVar v
    print r
    aux (n - 1)

main :: IO ()
main = do
    n &lt;- getNumCapabilities
    putStrLn $ "Number of cores: " ++ show n
    -- Initialize the counter
    counter &lt;- newTVarIO 0 :: IO (TVar Int)
    -- For example, run four threads that increment the counter 5 times
    forkIO $ aIncVar counter
    forkIO $ aIncVar counter
    forkIO $ aIncVar counter
    forkIO $ aIncVar counter
    -- Sleep so we can wait for the other threads to complete
    threadDelay 1000000
</code></pre>
<p>When executing this program, you should notice that the counter is being incremented correctly, with a final value of <code>20</code>.</p>
<p>The <code>stm</code> library provides many other useful facilities for writing transactional programs. Refer to the library documentation or the original paper for more details.</p>
<h2 id="concurrent-and-parallel-programming-in-haskell"><a class="header" href="#concurrent-and-parallel-programming-in-haskell">Concurrent and Parallel Programming in Haskell</a></h2>
<p>In summary, concurrent and parallel programming in Haskell is, generally, not too dissimilar to that in other general-purpose languages. However, because Haskell is a purely functional and non-strict evaluation language, there are several neat things at our disposable. For one, it is relatively straightforward to fork an I/O action to be performed concurrently, and to use synchronizing variables like <code>MVar</code> for communication between threads. Importantly, the Haskell runtime ensures that <code>MVar</code>s are only taken from or put by one thread, so synchronization is inherent in its implementation. However, using <code>MVar</code>s alone can get cumbersome especially when dealing with multiple concurrent operations that do not compose well; hence, the introduction of STM for atomic transactions to reduce the likelihood of accidentally introducing race conditions and deadlocks. In addition, because Haskell has non-strict evaluation, parallelizing it is fairly straightforward, by simply annotating the functions with <code>par</code> and <code>pseq</code> function applications to describe what operation should be done in parallel with what else.</p>
<p>Most importantly, ideas like I/O actions, STM transactions and even parallel evaluation strategies are all exposed as monads, and programs that are written with these can make use of all the guarantees and conveniences that monads have to offer. As before, monads are some of the most powerful concepts in programming, and it helps dramatically to have programming languages that make working with them easy.</p>
<p>Lastly, concurrency and parallelism are huge topics in Computer Science in and of itself. Since many of what is described in this course are not as generally applicable to other general-purpose languages, many of the details are omitted. More information is readily available online and in the original papers describing the various systems like Concurrent and Parallel Haskell, and STM. This may be useful if you are interested in a pursuing a career involving Haskell development, or wish to learn, more deeply, about some of the ideas we have presented.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<a id="stm" class="cite">
Tim Harris, Simon Marlow, Simon Peyton-Jones, and Maurice Herlihy. 2005. Composable memory transactions. In <i>Proceedings of the tenth ACM SIGPLAN symposium on Principles and practice of parallel programming (PPoPP '05)</i>. Association for Computing Machinery, New York, NY, USA, 48–60. <a class="cite" href="https://doi.org/10.1145/1065944.1065952">https://doi.org/10.1145/1065944.1065952</a>.
</a>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>I highly recommend that you work through the exercises <em>before</em> looking at the worked solutions!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-introduction"><a class="header" href="#course-introduction">Course Introduction</a></h1>
<h2 id="question-1-4"><a class="header" href="#question-1-4">Question 1</a></h2>
<ol>
<li>
<p><code>17</code>. \((3\times 4) +5 = 12 + 5 = 17\).</p>
</li>
<li>
<p><code>23</code>. \(3 + (4 \times 5) = 3 + 20 = 23\). Note that <code>*</code> has higher precedence than <code>+</code>.</p>
</li>
<li>
<p><code>1</code>. Exponentiation has a higher precedence than modulo (non-operator functions like <code>mod</code> that are called in an infix manner can have a well-defined operator precedence level).</p>
</li>
<li>
<p><code>24.25</code>. Regular division of integers gives a <code>Fractional</code> type.</p>
</li>
<li>
<p><code>24</code>. The <code>div</code> function is similar to <code>//</code> in Python.</p>
</li>
<li>
<p><code>1</code>. First we evaluate the condition <code>let x = 3 in x + 3</code> evaluates to <code>3 + 3</code> which therefore is <code>6</code>. Clearly <code>6 /= 5</code> is true, so we need to also evaluate <code>3 &lt; 4</code>, which is also true. <code>&amp;&amp;</code> is the same as <code>and</code> in Python, so <code>True and True</code> is therefore <code>True</code>. Thus, the whole expression evaluates to the if branch, which is <code>1</code>.</p>
</li>
<li>
<p><code>False</code>. <code>otherwise</code> is actually just <code>True</code> by definition, so <code>not True</code> becomes <code>False</code>.</p>
</li>
<li>
<p>It actually causes a compile-time error since it is a type error. <code>fst</code> and <code>snd</code> receive pairs, so these functions do not work on triples.</p>
</li>
<li>
<p><code>1.5</code>. The <code>succ</code> function returns the successor of any enumerable type. For numbers, this would be one more than the number.</p>
</li>
<li>
<p><code>1.4142135623730951</code>. Straightforward. Notice that Haskell's Prelude (the built-in stuff) comes with many math functions.</p>
</li>
<li>
<p><code>True</code>. The <code>elem</code> function is similar to
<code>in</code> in Python.</p>
</li>
<li>
<p><code>4</code>. When writing <code>let</code> bindings in a single line, we can
separate multiple definitions with <code>;</code>. Therefore, we have defined
two functions <code>f</code> and <code>g</code> which add one and multiply by 2
respectively. The <code>.</code> operator is function composition, where
\((g\circ f)(x) = g(f(x))\), so <code>(g . f) 1</code> is the same as
<code>g (f 1)</code>, which evaluates to <code>4</code>.</p>
</li>
<li>
<p><code>[1, 2, 3, 4, 5, 6]</code>. This is straightforward, since
<code>++</code> concatenates two lists.</p>
</li>
<li>
<p><code>1</code>. <code>head</code> returns the first element of the
list.</p>
</li>
<li>
<p><code>[2, 3]</code>. <code>tail</code> returns the suffix of the list
without the first element.</p>
</li>
<li>
<p><code>[1, 2]</code>. <code>init</code> returns the list without the
last element.</p>
</li>
<li>
<p><code>1</code>. <code>!!</code> is indexing.</p>
</li>
<li>
<p><code>True</code>. <code>null</code> checks whether a list is empty.</p>
</li>
<li>
<p><code>3</code>. Obvious.</p>
</li>
<li>
<p><code>[3]</code>. <code>drop n</code> drops the first <code>n</code> elements of
a list.</p>
</li>
<li>
<p><code>[-1, 0, 1, 2, 3]</code>. <code>take n</code> takes the first <code>n</code>
elements of a list. The range <code>[-1..]</code> is an infinitely
long range from <code>-1</code> to infinity.</p>
</li>
<li>
<p><code>[5, 1, 2 ,3]</code>. <code>dropWhile f</code> will drop elements
from a list until <code>f</code> returns false for an element.</p>
</li>
<li>
<p><code>30</code>. The easiest way to see this is by converting this to
the equivalent Python expression:</p>
<pre><code class="language-python">&gt;&gt;&gt; sum([x[0] for x in 
            [(i, j) for i in range(1, 5)
                    for j in range(-1, 2)]])
</code></pre>
<p>Going back to Haskell land, let us evaluate the inner list first.
<code>[(i, j) | i &lt;- [1..4], j &lt;- [-1..1]]</code> gives
<code>[(1, -1), (1, 0), (1, 1), (2, -1), ..., (4, 1)]</code> then,
<code>[fst x | x &lt;- ...]</code> would therefore give
<code>[1,1,1,2,2,2,3,3,3,4,4,4]</code> which sums to 30.</p>
</li>
</ol>
<h3 id="question-2-4"><a class="header" href="#question-2-4">Question 2</a></h3>
<p>Idea: take the last elements of both lists, and check for
equality. For this, we can use the <code>last</code> function.</p>
<pre><code class="language-haskell">eqLast xs ys = last xs == last ys
</code></pre>
<h3 id="question-3-4"><a class="header" href="#question-3-4">Question 3</a></h3>
<p>Idea: reverse the string, and check if the string and its
reverse are equal. For this, we can use the <code>reverse</code>
function.</p>
<pre><code class="language-haskell">isPalindrome w = w == reverse w
</code></pre>
<h3 id="question-4-4"><a class="header" href="#question-4-4">Question 4</a></h3>
<pre><code class="language-haskell">taxiFare f r d = f + r * d
</code></pre>
<h3 id="question-5-3"><a class="header" href="#question-5-3">Question 5</a></h3>
<p>There are several ways to approach this problem. Let us
first define the <code>ingredientPrice</code> function which should be
straightforward to do.</p>
<pre><code class="language-haskell">ingredientPrice i 
  | i == 'B' = 0.5
  | i == 'C' = 0.8
  | i == 'P' = 1.5
  | i == 'V' = 0.7
  | i == 'O' = 0.4
  | i == 'M' = 0.9
</code></pre>
<p>Then we can define <code>burgerPrice</code> recursively. If the string is
empty then the price is 0. Otherwise, take the price of the first
ingredient and add that to the price of the remaining burger.</p>
<pre><code class="language-haskell">burgerPrice burger 
  | null burger = 0
  | otherwise = 
      let first = ingredientPrice (head burger)
          rest  = burgerPrice (tail burger)
      in  first + rest
</code></pre>
<p>Of course, we know that we can do the following in Python quite nicely:</p>
<pre><code class="language-python">def burger_price(burger):
    return sum(ingredient_price(i) for i in burger)
</code></pre>
<p>This can be done in Haskell too as follows:</p>
<pre><code class="language-haskell">burgerPrice burger = sum [ingredientPrice i | i &lt;- burger]
</code></pre>
<p>We can also replace the comprehension expression in Python using
<code>map</code>:</p>
<pre><code class="language-python">def burger_price(burger):
    return sum(map(ingredient_price, burger))
</code></pre>
<p>Haskell also has a <code>map</code> (or <code>fmap</code>) function that
does the same thing:</p>
<pre><code class="language-haskell">burgerPrice burger = sum $ map ingredientPrice burger
</code></pre>
<p>The <code>$</code> sign is just regular function application, except that <code>$</code> binds
very weakly. So <code>sum $ map ingredientPrice burger</code> is basically
<code>sum (map ingredientPrice burger)</code>.</p>
<p>Finally, notice that
<code>burgerPrice x = sum ((map ingredientPrice) x)</code>, so
effectively we can finally define our function this way:</p>
<pre><code class="language-haskell">burgerPrice = sum . map ingredientPrice
  where ingredientPrice i 
          | i == 'B' = 0.5
          | i == 'C' = 0.8
          | i == 'P' = 1.5
          | i == 'V' = 0.7
          | i == 'O' = 0.4
          | i == 'M' = 0.9
</code></pre>
<p>To see this, let \(b\) be <code>burgerPrice</code>, \(g\) be <code>sum</code> and \(f\) be
<code>map ingredientPrice</code>. We have shown that \[b(x) = g(f(x))\] By
definition, \[b = g\circ f\]</p>
<p>This style of writing functions is known as <em>point-free</em> style, where functions are expressed
as a <em>composition</em> of functions.</p>
<h3 id="question-6-3"><a class="header" href="#question-6-3">Question 6</a></h3>
<p>Again, there are several ways to solve this. To do so
numerically, we can define our function recursively:</p>
<p>\[s(n) = \begin{cases}
n &amp; \text{if } n &lt; 10\\
n \mod 10 + s(\lfloor n \div 10 \rfloor)  &amp; \text{otherwise}
\end{cases}\]</p>
<pre><code class="language-haskell">sumDigits n
  | n &lt; 10    = n
  | otherwise = n `mod` 10 + sumDigits (n `div` 10)
</code></pre>
<p>Alternatively, we may convert <code>n</code> into a string, convert each character
into integers, then obtain the sum. This might be expressed in Python
as:</p>
<pre><code class="language-python">def sum_digits(n):
    return sum(map(int, str(n)))
</code></pre>
<p>Converting <code>n</code> into a string can be done by <code>show</code>:</p>
<pre><code class="language-haskell">ghci&gt; show 123
"123"
</code></pre>
<p>Converting back into an integer can be done with <code>read</code> (you have to
explicitly state the output type of the <code>read</code> function since this can
be ambiguous):</p>
<pre><code class="language-haskell">ghci&gt; read "123" :: Int
123
</code></pre>
<p>However, we can't <code>read</code> from <strong>characters</strong> since the <code>read</code> function
receives strings. Good thing that strings are lists of characters, so by
putting the character in a list, we now obtain the ability to read a
digit (as a character) as an integer.</p>
<pre><code class="language-haskell">ghci&gt; read '1' :: Int
-- error!
ghci&gt; read ['1'] :: Int
1
</code></pre>
<p>To put things into lists, we can use the <code>return</code> function!</p>
<pre><code class="language-haskell">ghci&gt; return '1' :: String
"1"
ghci&gt; (read . return) '1' :: Int
1
</code></pre>
<p>Thus, the <code>read . return</code> function allows us to parse each character
into an integer. Combining this with what we had before, we can obtain
the list of the digits (as integers) from <code>n</code> using:</p>
<pre><code class="language-haskell">ghci&gt; [(read . return) digit | digit &lt;- show 123] :: [Int]
[1, 2, 3]
</code></pre>
<p>Again, we can use <code>map</code> instead of list comprehension.</p>
<pre><code class="language-haskell">ghci&gt; map (read . return) (show 123) :: [Int]
[1, 2, 3]
</code></pre>
<p>Obtaining the sum of this list gives us exactly what we want. Thus, our
<code>sumDigits</code> function is succinctly defined as follows:</p>
<pre><code class="language-haskell">sumDigits = sum . map (read . return) . show
</code></pre>
<h3 id="question-7-2"><a class="header" href="#question-7-2">Question 7</a></h3>
<p>Idea: drop the first <code>start</code> elements, then take the
<code>stop - start</code> elements after that.</p>
<pre><code class="language-haskell">ls @: (start, stop) = take (stop - start) (drop start ls)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="types-2"><a class="header" href="#types-2">Types</a></h1>
<h2 id="question-1-5"><a class="header" href="#question-1-5">Question 1</a></h2>
<ol>
<li><code>Int</code>.</li>
<li><code>String</code>. <code>x</code> has type <code>Int</code>, so <code>show x</code> has
type <code>String</code>.</li>
<li><code>String</code>. Recall that <code>String</code> is an alias for
<code>[Char]</code>. Although the expression evaluates to
<code>[]</code> which has type <code>forall a. [a]</code>, because
both branches of the conditional expression must have the same type,
the type of the expression is thus specialized into
<code>[Char]</code>.</li>
<li><code>[a] -&gt; [a]</code>. <code>(++)</code> has type
<code>forall a. [a] -&gt; [a] -&gt; [a]</code>, since <code>[]</code> is
also polymorphic with type <code>forall a. [a]</code>, there is no
need to specialize the resulting function call expression. This
makes sense because any list can be concatenated with the empty
list.</li>
<li><code>[Int] -&gt; [Int]</code>. The <code>map</code> function has type
<code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>. Since we have supplied a
function <code>Int -&gt; Int</code>, we are thus specializing <code>a</code> and
<code>b</code> to <code>Int</code>.</li>
<li><code>(a -&gt; [Int]) -&gt; a -&gt; String</code>. Recall that <code>(.)</code> has type
<code>forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>. The
function <code>\(x :: Int) -&gt; show x</code> has type
<code>Int -&gt; String</code>. Thus, substituting <code>b</code> and <code>c</code> for
<code>Int</code> and <code>String</code> respectively, we get our
answer.</li>
<li><code>(String -&gt; a) -&gt; Int -&gt; a</code>. Note that <code>(+3)</code> is
<code>\x -&gt; x + 3</code>, while <code>(3+)</code> is
<code>\x -&gt; 3 + x</code>. As such, the answer here follows the same
reasoning except that the argument to <code>(.)</code> is at the second
position.</li>
<li><code>(a, b) -&gt; c -&gt; (a, c)</code>. Note that <code>(,)</code> is the tuple
(pair) constructor which has type
<code>forall a, b. a -&gt; b -&gt; (a, b)</code>.</li>
<li><code>(a -&gt; Bool) -&gt; [a] -&gt; [a]</code>. As we know,
<code>filter</code> receives a function that tests each element, and
returns the list with only the elements that pass the test.</li>
</ol>
<h2 id="question-2-5"><a class="header" href="#question-2-5">Question 2</a></h2>
<ol>
<li><code>eqLast</code>: <code>Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code>. This function can
be polymorphic but requires that <code>a</code> is amenable to equality
comparisons, so we add the <code>Eq</code> constraint to it. We will discuss
more on typeclasses next week.</li>
<li><code>isPalindrome</code>: <code>Eq a =&gt; [a] -&gt; [a] -&gt; Bool</code>. The reason
for the <code>Eq</code> constraint is because we need to compare the two lists
for equality, which means that the elements of both lists must be
amenable to equality comparisons!</li>
<li><code>burgerPrice</code>: <code>Fractional a =&gt; String -&gt; a</code>. Notice once
again that we have another typeclass constraint in this function
signature. Typeclasses are incredibly common, and hopefully this
might motivate you to understand these in the subsequent lectures.
Nonetheless, if you had answered <code>String -&gt; Double</code>, that
is fair as well.</li>
<li><code>@:</code>: <code>[a] -&gt; (Int, Int) -&gt; [a]</code>. The function receives a
list, a pair of two integers, and produces a slice of the list of
the same type.</li>
</ol>
<h2 id="question-3-5"><a class="header" href="#question-3-5">Question 3</a></h2>
<p>Let us first define a type that describes
valid ingredients and a function on this type that gives their prices:</p>
<pre><code class="language-haskell">data Ingredient = B | C | P | V | O | M
price :: Ingredient -&gt; Rational
price B = 0.5
price C = 0.8
price P = 1.5
price V = 0.7
price O = 0.4
price M = 0.9
</code></pre>
<p>Then, we can define a valid burger being a list of ingredients. For
this, we can define a <em>type alias</em> like so:</p>
<pre><code class="language-haskell">type Burger = [Ingredient]
</code></pre>
<p>Type aliases are nothing special; more or less, they are <em>nicknames</em> for
types. There is no difference between the <code>Burger</code> and
<code>[Ingredient]</code> types, just like how there is no difference
between <code>String</code> and <code>[Char]</code>. Then, we can define
our <code>burgerPrice</code> function with pattern matching in a very standard way:</p>
<pre><code class="language-haskell">burgerPrice :: Burger -&gt; Rational
burgerPrice [] = 0
burgerPrice (i : is) = price i + burgerPrice is
</code></pre>
<p>Let us take this a step further by observing the following function in
Haskell's prelude:</p>
<pre><code class="language-haskell">foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr f n [] = n
foldr f n (x : xs) = 
  let r = foldr f n xs
  in  f x r
</code></pre>
<p>In practice, this does something very familiar:
\[\textit{foldr}(f, n, [a_1,\dots,a_n]) = f(a_1,f(a_2,\dots f(a_{n-1}, f(a_n, n))\dots ))\]</p>
<p>This looks like the right-associative equivalent of <code>reduce</code> in Python!
(The equivalent of <code>reduce</code> in Haskell is the <code>foldl</code> function).
\[\textit{reduce}(f, n, [a_1,\dots,a_n]) = f(f(\dots f(n, a_1), a_2), \dots, a_n)\]
This hints to us that in the definition of <code>foldr</code>, <code>f</code> is the combiner
function and <code>n</code> is the initial value. This corresponds very nicely to
<code>burgerPrice</code>. Let us try rewriting our <code>burgerPrice</code> function to see
this:</p>
<pre><code class="language-haskell">burgerPrice [] = 0
burgerPrice (x : xs) = 
  let r = burgerPrice xs
      f a b = price a + b
      -- alternatively, 
      -- f = (+) . price
  in  f x r
</code></pre>
<p>As you can see, if we let <code>f</code> be <code>(+) . price</code> and <code>n</code> be <code>0</code>, we can
define <code>burgerPrice</code> based on <code>foldr</code>:</p>
<pre><code class="language-haskell">burgerPrice = foldr ((+) . price) 0
</code></pre>
<h2 id="question-4-5"><a class="header" href="#question-4-5">Question 4</a></h2>
<p>Solutions are self-explanatory.</p>
<pre><code class="language-haskell">dropConsecutiveDuplicates :: Eq a =&gt; [a] -&gt; [a]
dropConsecutiveDuplicates [] = []
dropConsecutiveDuplicates [x] = [x]
dropConsecutiveDuplicates (x : xx : xs) 
  | x == xx   = dropConsecutiveDuplicates (x : xs)
  | otherwise = x : dropConsecutiveDuplicates (xx : xs)
</code></pre>
<h2 id="question-5-4"><a class="header" href="#question-5-4">Question 5</a></h2>
<p>As hinted by the example runs, a zipper is a tuple of two
lists. The idea is to model a zipper as two stacks. This is great
because singly-linked lists (with head pointers), as we know, can model
stacks.</p>
<pre><code class="language-haskell">type ListZipper a = ([a], [a])
mkZipper :: [a] -&gt; ListZipper a
mkZipper ls = ([], ls)
</code></pre>
<p>Functions for traversing and replacing the elements of the zipper should
be straightforward to define. Note that the <code>@</code> symbol binds the entire
pattern on the right to the name on the left.</p>
<pre><code class="language-haskell">l, r :: ListZipper a -&gt; ListZipper a

l x@([], _) = x
l (x : xs, ys) = (xs, x : ys)

r x@(_,[]) = x
r (xs, y : ys) = (y : xs, ys)

setElement :: a -&gt; ListZipper a -&gt; ListZipper a
setElement x (xs,[]) = (xs, [x])
setElement x (xs, _ : ys) = (xs, x : ys)
</code></pre>
<h2 id="question-6-4"><a class="header" href="#question-6-4">Question 6</a></h2>
<p>To start, we define a binary tree. This is very similar to the
tree examples that we have given, except that we allow the tree to be
empty. Note that you might be tempted to put the <code>Ord</code>
constraint at the data type declaration itself. This is deprecated, and
also not recommended.</p>
<pre><code class="language-haskell">data SortedSet a = Empty | Node (SortedSet a) a (SortedSet a)
</code></pre>
<p>Let us start with the function to add elements to the sorted set. This
should be straightforward if you remember how BST algorithms are
defined.</p>
<pre><code class="language-haskell">(@+) :: Ord a =&gt; SortedSet a -&gt; a -&gt; SortedSet a
Empty @+ x = Node Empty x Empty
t@(Node left a right) @+ x
    | x == a     = t
    | x &lt; a      = Node (left @+ x) a right
    | otherwise  = Node left a (right @+ x)
</code></pre>
<p>Given a BST, to get the list of elements in sorted order, perform an
inorder traversal.</p>
<pre><code class="language-haskell">setToList :: SortedSet a -&gt; [a]
setToList Empty = []
setToList (Node left a right) = setToList left ++ (a : setToList right)
</code></pre>
<p>Converting a list into a sorted set can be done by repeated applications
of <code>@+</code> over the elements of the list. This should hint to us that we
can use a fold over the list. Note that the <code>flip</code> function flips the
arguments of a function: i.e. <code>flip f x y = f y x</code>.</p>
<pre><code class="language-haskell">sortedSet :: Ord a =&gt; [a] -&gt; SortedSet a 
sortedSet = foldr (flip (@+)) Empty
</code></pre>
<p>Finally, determining if an element is a member of the sorted set is a
matter of binary search.</p>
<pre><code class="language-haskell">in' :: Ord a =&gt; a -&gt; SortedSet a -&gt; Bool
in' _ Empty = False
in' x (Node left a right)
  | x == a    = True
  | x &lt; a     = in' x left
  | otherwise = in' x right
</code></pre>
<p>An alternative to this implementation is to use AVL trees instead of
plain BSTs. We provide an implementation of AVL trees at the end of this chapter.</p>
<h2 id="question-7-3"><a class="header" href="#question-7-3">Question 7</a></h2>
<p>We start with the base definition which should
be self-explanatory.</p>
<pre><code class="language-haskell">-- Haskell
data Shape = Circle Double | Rectangle Double Double

area :: Shape -&gt; Double
area (Circle r) = pi * r ^ 2
area (Rectangle w h) = w * h
</code></pre>
<pre><code class="language-python">from abc import ABC, abstractmethod
from dataclasses import dataclass
from math import pi

class Shape(ABC):
    @abstractmethod
    def area(self) -&gt; float:
        pass

@dataclass
class Circle(Shape):
    radius: float
    def area(self) -&gt; float:
        return pi * self.radius ** 2

@dataclass
class Rectangle(Shape):
    width: float
    height: float
    def area(self) -&gt; float:
        return self.width * self.height
</code></pre>
<p>We start with the first extension of our problem by creating a new shape
called <code>Triangle</code>. Notice that to add representations of our types in
our Haskell implementation, we must have access to edit whatever we've
written before. This is unlike our OO implementation in Python, where by
adding a new shape, we can just define a completely separate subclass
and define the <code>area</code> method for that class.</p>
<pre><code class="language-haskell">data Shape = Circle Double 
           | Rectangle Double Double
           | Triangle Double Double

area :: Shape -&gt; Double
area (Circle r) = pi * r ^ 2
area (Rectangle w h) = w * h
area (Triangle w h) = w * h / 2
</code></pre>
<pre><code class="language-python">@dataclass
class Triangle(Shape):
    width: float
    height: float
    def area(self) -&gt; float:
        return self.width * self.height / 2
</code></pre>
<p>However, proceeding with the second extension, we see that the opposite
is true: adding a new function does not require edit access in our
Haskell implementation since we can just define a separate function, but
it is required for our Python implementation since we have to add this
method to all the classes we have defined!</p>
<pre><code class="language-haskell">scale :: Double -&gt; Shape -&gt; Shape
scale n (Circle r) = Circle (r * n)
scale n (Rectangle w h) = Rectangle (w * n) (h * n)
scale n (Triangle w h) = Triangle (w * n) (h * n)
</code></pre>
<pre><code class="language-python">class Shape(ABC):
    @abstractmethod
    def area(self) -&gt; float:
        pass
    @abstractmethod
    def scale(self, n: float) -&gt; 'Shape':
        pass

@dataclass
class Circle(Shape):
    radius: float
    def area(self) -&gt; float:
        return pi * self.radius ** 2
    def scale(self, n: float) -&gt; Shape:
        return Circle(n * self.radius)

@dataclass
class Rectangle(Shape):
    width: float
    height: float
    def area(self) -&gt; float:
        return self.width * self.height
    def scale(self, n: float) -&gt; Shape:
        return Rectangle(self.width * n, self.height * n)

@dataclass
class Triangle(Shape):
    width: float
    height: float
    def area(self) -&gt; float:
        return self.width * self.height / 2
    def scale(self, n: float) -&gt; Shape:
        return Triangle(self.width * n, self.height * n)
</code></pre>
<h2 id="question-8-1"><a class="header" href="#question-8-1">Question 8</a></h2>
<p>Defining additional constructors for our expressions GADT is
relatively straightforward, and so is extending our <code>eval</code>
function. We write the entire implementation here.</p>
<pre><code class="language-haskell">{-# LANGUAGE GADTs #-}
data Expr α where
  LitNumExpr  :: Int -&gt; Expr Int
  AddExpr     :: Expr Int -&gt; Expr Int -&gt; Expr Int
  EqExpr      :: Eq α =&gt; Expr α -&gt; Expr α -&gt; Expr Bool
  CondExpr    :: Expr Bool -&gt; Expr α -&gt; Expr α -&gt; Expr α
  LitBoolExpr :: Bool -&gt; Expr Bool
  AndExpr     :: Expr Bool -&gt; Expr Bool -&gt; Expr Bool
  OrExpr      :: Expr Bool -&gt; Expr Bool -&gt; Expr Bool
  FuncExpr    :: (α -&gt; β) -&gt; Expr (α -&gt; β)
  FuncCall    :: Expr (α -&gt; β) -&gt; Expr α -&gt; Expr β

eval :: Expr α -&gt; α
eval (LitNumExpr n)   = n
eval (AddExpr a b)    = eval a + eval b
eval (EqExpr a b)     = eval a == eval b
eval (CondExpr a b c) = if eval a then eval b else eval c
eval (LitBoolExpr b)  = b
eval (AndExpr a b)    = eval a &amp;&amp; eval b
eval (OrExpr a b)     = eval a || eval b
eval (FuncExpr f)     = f
eval (FuncCall f x)   = (eval f) (eval x)
</code></pre>
<h2 id="question-9-1"><a class="header" href="#question-9-1">Question 9</a></h2>
<h3 id="bank-accounts-1"><a class="header" href="#bank-accounts-1">Bank Accounts</a></h3>
<h4 id="bank-account-adt-1"><a class="header" href="#bank-account-adt-1">Bank Account ADT</a></h4>
<p>As in the lecture notes, simulating ADTs in Python can be done either
with an (abstract) class, or a type alias. In our case, we shall use the
latter.</p>
<p>First, we create the type:</p>
<pre><code class="language-python">type BankAccount = NormalAccount | MinimalAccount
</code></pre>
<p>Then, we create the <code>NormalAccount</code> and
<code>MinimalAccount</code> classes:</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass(frozen=True)
class NormalAccount:
    account_id: str
    balance: float
    interest_rate: float

@dataclass(frozen=True)
class MinimalAccount:
    account_id: str
    balance: float
    interest_rate: float
</code></pre>
<h4 id="basic-features-1"><a class="header" href="#basic-features-1">Basic Features</a></h4>
<p>For our two basic features, we shall employ a simple helper function
that sets the amount of a bank account. Notice once again that we do not
mutate any data structure in our program!</p>
<pre><code class="language-python">def _set_balance(amt: float, b: BankAccount) -&gt; BankAccount:
    match b:
        case NormalAccount(id, _, i):
            return NormalAccount(id, amt, i)
        case MinimalAccount(id, _, i):
            return MinimalAccount(id, amt, i)
</code></pre>
<p>Then, the basic features can be defined in terms of our
<code>_set_balance</code> helper function.</p>
<pre><code class="language-python">def deposit(amt: float, b: BankAccount) -&gt; BankAccount:
    return _set_balance(b.balance + amt, b)

def deduct(amt: float, b: BankAccount) -&gt; tuple[bool, BankAccount]:
    if amt &gt; b.balance:
        return (False, b)
    return (True, _set_balance(b.balance - amt, b))
</code></pre>
<h4 id="advanced-features-1"><a class="header" href="#advanced-features-1">Advanced Features</a></h4>
<p>At this point, implementing the advanced features should not be too
difficult.</p>
<pre><code class="language-python">def _cmpd(p: float, r: float) -&gt; float:
    return p * (1 + r)

def compound(b: BankAccount) -&gt; BankAccount:
    match b:
        case NormalAccount(id, bal, i):
            return NormalAccount(id, _cmpd(bal, i), i)
        case MinimalAccount(id, bal, i):
            new_bal: float = max(bal - 20, 0) if bal &lt; 1000 else bal
            return MinimalAccount(id, _cmpd(new_bal, i), i)

def transfer(amt: float, from_: BankAccount, to: BankAccount) -&gt; tuple[bool, BankAccount, BankAccount]:
    success: bool
    from_deducted: BankAccount
    success, from_deducted = deduct(amt, from_)
    if not success:
        return (False, from_, to)
    return (True, from_deducted, deposit(amt, to))
</code></pre>
<h3 id="operating-on-bank-accounts-1"><a class="header" href="#operating-on-bank-accounts-1">Operating on Bank Accounts</a></h3>
<h4 id="operations-adt-1"><a class="header" href="#operations-adt-1">Operations ADT</a></h4>
<p>The ADT definition is pretty straightforward:</p>
<pre><code class="language-python">type Op = Transfer | Compound

@dataclass
class Transfer:
    amount: float
    from_: str
    to: str

@dataclass
class Compound:
    pass 
</code></pre>
<h4 id="processing-one-operation-1"><a class="header" href="#processing-one-operation-1">Processing One Operation</a></h4>
<p>It's easier to write the functions that perform each individual
operation first, especially since they are more involved with dictionary
lookups etc. Take note of the fact that all of the data structures are
unchanged!</p>
<pre><code class="language-python"># Type alias for convenience
type BankAccounts = dict[str, BankAccount]

def _compound_all(mp: BankAccounts) -&gt; BankAccounts:
    return {k : compound(v) for k, v in mp.items()}

def _transfer(amt: float, from_: str, to: str, mp: BankAccounts) -&gt; tuple[bool, BankAccounts]:
    if from_ not in mp or to not in mp:
        return (False, mp)
    success: bool
    new_from: BankAccount
    new_to: BankAccount
    success, new_from, new_to = transfer(amt, mp[from_], mp[to])
    if not success:
        return (False, mp)
    new_mp: BankAccounts = mp | { from_: new_from, to: new_to }
    return (True, new_mp)
</code></pre>
<p>Then, the <code>process_one</code> function is easy to define since we can
just invoke our helper functions:</p>
<pre><code class="language-python">def process_one(op: Op, mp: BankAccounts) -&gt; tuple[bool, BankAccounts]:
    match op:
        case Transfer(amt, from_, to):
            return _transfer(amt, from_, to, mp)
        case Compound():
            return (True, _compound_all(mp))
</code></pre>
<h4 id="process-all-operations"><a class="header" href="#process-all-operations">Process All Operations</a></h4>
<p>Given the <code>process_one</code> function, the <code>process_all</code>
function should be straightforward. Note once again that none of the
data structures are being mutated and we use recursion. The last
<code>case</code> statement is only used to suppress <code>pyright</code> warnings.</p>
<pre><code class="language-python">def process_all(ops: list[Op], mp: BankAccounts) -&gt; tuple[list[bool], BankAccounts]:
    match ops:
        case []:
            return [], mp
        case x, *xs:
            op_r, mp1 = process_one(x, mp)
            rs, mp2 = process_all(xs, mp1)
            return [op_r] + rs, mp2
        case _: raise
</code></pre>
<h4 id="polymorphic-processing-1"><a class="header" href="#polymorphic-processing-1">Polymorphic Processing</a></h4>
<p>Notice that if we had received the <code>process_one</code> function as an
argument then we would now have a higher-order function:</p>
<pre><code class="language-python">from typing import Callable
# For brevity
type P = Callable[[Op, BankAccounts], tuple[bool, BankAccounts]]
def process_all(process_one: P, ops: list[Op], mp: BankAccounts) -&gt; tuple[list[bool], BankAccounts]:
    match ops:
        case []:
            return [], mp
        case x, *xs:
            op_r, mp1 = process_one(x, mp)
            rs, mp2 = process_all(process_one, xs, mp1)
            return [op_r] + rs, mp2
        case _: raise
</code></pre>
<p>Now notice that <code>process_all</code>'s implementation does not depend
on <code>Op</code>, <code>bool</code> or <code>BankAccounts</code>. Let us
make this function polymorphic by replacing <code>Op</code> with <code>A</code>,
<code>BankAccounts</code> with <code>B</code> and <code>bool</code> with <code>C</code>!</p>
<pre><code class="language-python">def process[A, B, C](f: Callable[[A, B], tuple[C, B]], ops: list[A], mp: B) -&gt; tuple[list[C], B]:
    match ops:
        case []:
            return [], mp
        case x, *xs:
            op_r, mp1 = f(x, mp)
            rs, mp2 = process(f, xs, mp1)
            return [op_r] + rs, mp2
        case _: raise
</code></pre>
<h2 id="avl-trees"><a class="header" href="#avl-trees">AVL Trees</a></h2>
<p>Here we show an example of using AVL trees as sorted sets. Notice our
AVL tree has nice pretty printing, pretty cool huh! We will learn how to
define the string representation of a type in subsequent lectures.</p>
<pre><code>ghci&gt; x = fromList [1,1,1,2,2,2,8,5,4,3,5,9,0,10,0,7,8,3]
ghci&gt; x
            7
      ┏━━━━━┻━━━┓
      3         9
  ┏━━━┻━━━┓   ┏━┻━┓
  1       5   8   10
┏━┻━┓   ┏━┛
0   2   4
ghci&gt; x @+ 6 @+ 11 @+ 14 @+ 12 @+ 15
              7
      ┏━━━━━━━┻━━━━━━━━┓
      3                11
  ┏━━━┻━━━┓       ┏━━━━┻━━━━━┓
  1       5       9          14
┏━┻━┓   ┏━┻━┓   ┏━┻━┓     ┏━━┻━━┓
0   2   4   6   8   10    12    15
</code></pre>
<p>We first start with some declarations and imports.</p>
<pre><code class="language-haskell">module Avl ( AVL(Empty), in', toList, fromList, (@+)) where

import Data.List (intercalate)

data AVL a = Empty | Node (AVL a) a (AVL a) 
  deriving Eq

in'      :: Ord a =&gt; a -&gt; AVL a -&gt; Bool
toList   :: AVL a -&gt; [a]
fromList :: Ord a =&gt; [a] -&gt; AVL a
(@+)     :: Ord a =&gt; AVL a -&gt; a -&gt; AVL a
infixl 7 @+
</code></pre>
<p>Next, we provide implementations of these declarations. Many of these
are identical to that of our sorted set implementation using BSTs; the
only difference is in <code>@+</code> where AVL trees have to perform height
balancing if the balance factor exceeds the range \([-1, 1]\).</p>
<pre><code class="language-haskell">in' _ Empty = False
in' x (Node left a right)
  | x == a    = True
  | x &lt; a     = in' x left
  | otherwise = in' x right

toList Empty = []
toList (Node left a right) = toList left ++ (a : toList right)

fromList = foldr (flip (@+)) Empty

Empty @+ x = Node Empty x Empty
o@(Node left a right) @+ x 
  | x &lt; a = 
      let newLeft = left @+ x
          newTree = Node newLeft a right
      in  if bf newTree &gt; -2 then newTree
          else 
            let t 
                  | bf newLeft &gt; 0 = Node (rotateLeft newLeft) a right 
                  | otherwise      = newTree
            in rotateRight t
  | x &gt; a =
      let newRight = right @+ x
          newTree = Node left a newRight
      in  if bf newTree &lt; 2 then newTree
          else let t
                    | bf newRight &lt; 0 = Node left a (rotateRight newRight)
                    | otherwise       = newTree
               in rotateLeft t
  | otherwise = o
</code></pre>
<p>The implementation of these functions involve some additional helper
functions for obtaining balance factors and rotations, which we declare
and define here:</p>
<pre><code class="language-haskell">-- Implementation helpers
height :: AVL a -&gt; Int
height Empty = 0
height (Node left _ right) = 1 + max (height left) (height right)

rotateLeft :: AVL a -&gt; AVL a
rotateLeft Empty = Empty
rotateLeft t@(Node _ _ Empty) = t
rotateLeft (Node left a (Node ll b right)) = Node (Node left a ll) b right

rotateRight :: AVL a -&gt; AVL a
rotateRight Empty = Empty
rotateRight t@(Node Empty _ _) = t
rotateRight (Node (Node left b rr) a right) = Node left b (Node rr a right)

bf :: AVL a -&gt; Int -- balance factor
bf Empty = 0
bf (Node l _ r) = height r - height l
</code></pre>
<p>Finally, we write functions to support pretty printing.</p>
<pre><code class="language-haskell">-- Pretty printing
strWidth :: Show a =&gt; AVL a -&gt; Int
strWidth Empty = 0
strWidth (Node left a right) = 
  let leftWidth = strWidth left
      l = if leftWidth &gt; 0 then leftWidth + 1 else 0
      centerWidth = length $ show a
      rightWidth = strWidth right
      r = if rightWidth &gt; 0 then rightWidth + 1 else 0
  in  l + centerWidth + r

leftPad :: Int -&gt; String -&gt; String
leftPad 0 s = s
leftPad n s = leftPad (n - 1) (' ' : s)

rightArm, leftArm :: Int -&gt; String

rightArm n = aux n where
  aux n' 
    | n' == n   = '┗' : aux (n' - 1)
    | n' &gt; 0    = '━' : aux (n' - 1)
    | otherwise = "┓"

leftArm n = aux n where
  aux n'
    | n' == n = '┏' : aux (n' - 1)
    | n' &gt; 0  = '━' : aux (n' - 1)
    | otherwise = "┛"

bothArm :: Int -&gt; Int -&gt; String
bothArm mid right = aux 0 where
  aux n'
    | n' == 0 = '┏' : aux 1
    | n' /= mid &amp;&amp; n' &lt; right = '━' : aux (n' + 1)
    | n' == mid = '┻' : aux (n' + 1)
    | otherwise = "┓"

toRowList :: Show a =&gt; AVL a -&gt; [String]
toRowList Empty = []
toRowList (Node Empty a Empty) = [show a]
toRowList (Node Empty a right) =
  let x = toRowList right
      nodeLength = length $ show a
      y = map (leftPad (nodeLength + 1)) x
      rroot = rootAt right + nodeLength + 1
  in show a : rightArm rroot : y
toRowList (Node left a Empty) = 
  let x = toRowList left
      lroot = rootAt left
      nodeAt = strWidth left + 1
  in leftPad nodeAt (show a) : leftPad lroot (leftArm (nodeAt - lroot)) : x
toRowList (Node left a right) = 
  let l = toRowList left
      r = toRowList right
      lw = strWidth left
      rpadding = lw + 2 + length (show a)
      rr = zipStringTree rpadding l r
      lroot = rootAt left
      rroot = rootAt right
      nodeAt = lw + 1
      f = leftPad (lw + 1) (show a)
      s = leftPad lroot (bothArm (nodeAt - lroot) (rroot - lroot + rpadding))
  in  f : s : rr


rightPadTo :: Int -&gt; String -&gt; String
rightPadTo n s
  | ls &gt;= n   = s
  | otherwise = let n' = n - ls
                    s' = leftPad n' []
                in  s ++ s'
  where ls = length s

rootAt :: Show a =&gt; AVL a -&gt; Int
rootAt Empty = 0
rootAt (Node Empty _ _) = 0
rootAt (Node left _ _) = strWidth left + 1

zipStringTree :: Int -&gt; [String] -&gt; [String] -&gt; [String]
zipStringTree _ [] [] = []
zipStringTree _ l [] = l
zipStringTree n [] r = map (leftPad n) r
zipStringTree n (l : ls) (r : rs) = 
  let res = zipStringTree n ls rs
      c   = rightPadTo n l ++ r
  in  c : res

instance Show a =&gt; Show (AVL a) where
  show Empty = ""
  show t = intercalate "\n" $ toRowList t
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="typeclasses"><a class="header" href="#typeclasses">Typeclasses</a></h1>
<h3 id="question-1-6"><a class="header" href="#question-1-6">Question 1</a></h3>
<ol>
<li><code>Num a =&gt; a</code>. Because all of <code>1</code>, <code>2</code> and <code>3</code> can be interpreted as any number, the entire expression can likewise be interpreted as any number.</li>
<li><code>Show b =&gt; (a -&gt; b) -&gt; a -&gt; String</code>. The type of <code>show</code> is <code>Show a =&gt; a -&gt; String</code>, in other words, any type that implements the <code>Show</code> typeclass can be converted into a <code>String</code>. Therefore, <code>(show .)</code> can receive any function <code>a -&gt; b</code> where <code>b</code> implements <code>Show</code>, so that the result is a function that receives <code>a</code> and produces <code>String</code></li>
<li><code>Show a =&gt; (String -&gt; b) -&gt; a -&gt; b</code>. Similar to the above.</li>
<li><code>Eq a =&gt; (a, a) -&gt; Bool</code>. The elements of the tuple must be amenable to equality comparisons, and therefore must be of the same type <code>a</code> where <code>a</code> implements <code>Eq</code>.</li>
</ol>
<h3 id="question-2-6"><a class="header" href="#question-2-6">Question 2</a></h3>
<p>The idea is to create a protocol that describes classes that
have a <code>to_list</code> function. In the following solution, the
protocol is called <code>ToList</code>.</p>
<pre><code class="language-python">from typing import Any

type Tree[a] = Empty | TreeNode[a]
type List[a] = Empty | ListNode[a]

@dataclass
class Empty:
    def to_list(self) -&gt; list[Any]:
        return []

@dataclass
class ListNode[a]:
    head: a
    tail: List[a]
    def to_list(self) -&gt; list[a]:
        return [self.head] + self.tail.to_list()

@dataclass
class TreeNode[a]:
    l: Tree[a]
    v: a
    r: Tree[a]
    def to_list(self) -&gt; list[a]:
        return self.l.to_list() + [self.v] + self.r.to_list()

class ToList[a](Protocol):
    def to_list(self) -&gt; list[a]:
        raise

def flatten[a](ls: list[ToList[a]]) -&gt; list[a]:
    if not ls: return []
    return ls[0].to_list() + flatten(ls[1:])

ls: list[ToList[int]] = [ListNode(1, Empty()), TreeNode(Empty(), 2, Empty())]
ls2: list[int] = flatten(ls)
</code></pre>
<h3 id="question-3-6"><a class="header" href="#question-3-6">Question 3</a></h3>
<p>The <code>smallest</code> function can be implemented directly with the <code>minBound</code> method of the <code>Bounded</code> typeclass:</p>
<pre><code class="language-haskell">smallest :: Bounded a =&gt; a 
smallest = minBound
</code></pre>
<p>The <code>descending</code> function can also be implemented directly with the <code>Bounded</code> and <code>Enum</code> methods. The idea is to construct a range (which requires <code>Enum</code>) starting from <code>maxBound</code> and enumerating all the way to <code>minBound</code>. You can either construct a range starting from <code>minBound</code> to <code>maxBound</code> and then reverse the list, or you can start from <code>maxBound</code>, followed by <code>pred maxBound</code> (<code>pred</code> comes from <code>Enum</code>), and end at <code>minBound</code>.</p>
<pre><code class="language-haskell">descending :: (Bounded a, Enum a) =&gt; [a]
descending = [maxBound,pred maxBound..minBound]
</code></pre>
<p>The <code>average</code> function can be implemented by converting the two terms to integers using <code>fromEnum</code>, then take the average, and use <code>toEnum</code> to bring it back to the desired term.</p>
<pre><code class="language-haskell">average :: Enum a =&gt; a -&gt; a -&gt; a
average x y = toEnum $ (fromEnum x + fromEnum y) `div` 2
</code></pre>
<h3 id="question-4-6"><a class="header" href="#question-4-6">Question 4</a></h3>
<p>Any list of elements that can be ordered, i.e. any list over a type implementing <code>Ord</code> can be sorted!</p>
<pre><code class="language-haskell">import Data.List (splitAt)
mergesort :: Ord a =&gt; [a] -&gt; [a]
mergesort ls 
  | len &lt;= 1 = ls
  | otherwise = let (l, r) = splitAt (len `div` 2) ls
                    l'     = mergesort l
                    r'     = mergesort r
                in  merge l' r'
  where len :: Int
        len = length ls
        merge :: Ord a =&gt; [a] -&gt; [a] -&gt; [a]
        merge [] x = x
        merge x [] = x
        merge l@(x : xs) r@(y : ys)
          | x &lt;= y = x : merge xs r
          | otherwise = y : merge l ys
</code></pre>
<h3 id="question-5-5"><a class="header" href="#question-5-5">Question 5</a></h3>
<p>Before we even begin, it will be helpful to decide what
our typeclass will look like. The typeclass should be abstracted over
the type of expression and the type from evaluating it. Therefore, it
should be something like <code>Expr e a</code>, where
<code>eval :: e -&gt; a</code>. However, we know that <code>e</code> uniquely
characterizes <code>a</code>, therefore we should add this as a
functional dependency of our typeclass.</p>
<pre><code class="language-haskell">class Expr e a | e -&gt; a
  eval :: e -&gt; a

-- for clarity
type IntExpr e = Expr e Int
type BoolExpr e = Expr e Bool
</code></pre>
<p>Then, our types will all contain types that implement the
<code>Expr</code> typeclass.</p>
<p>First, to start we have numeric literals, which is straightforward.</p>
<pre><code class="language-haskell">data LitNumExpr = LitNumExpr Int

instance Expr LitNumExpr Int where
  eval :: LitNumExpr -&gt; Int
  eval (LitNumExpr x) = x
</code></pre>
<p><code>AddExpr</code> is more interesting. We require that the component
expressions must be evaluated to an <code>Int</code>. As such, we
constrain the component addends with <code>IntExpr</code> as follows:</p>
<pre><code class="language-haskell">data AddExpr where
  AddExpr :: (IntExpr e, IntExpr e') =&gt; e -&gt; e' -&gt; AddExpr

instance Expr AddExpr Int where
  eval :: AddExpr -&gt; Int
  eval (AddExpr e1 e2) = eval e1 + eval e2
</code></pre>
<p>To define <code>EqExpr</code>, we have to allow expressions of any type
that evaluates to any type that is amenable to equality comparisons:</p>
<pre><code class="language-haskell">data EqExpr where
  EqExpr :: (Eq a, Expr e a, Expr e' a) =&gt; e -&gt; e' -&gt; EqExpr

instance Expr EqExpr Bool where
  eval :: EqExpr -&gt; Bool
  eval (EqExpr e1 e2) = eval e1 == eval e2
</code></pre>
<p>Finally, to define a <code>CondExpr</code> we must allow it to evaluate
to any type, and thus should be parameterized.</p>
<pre><code class="language-haskell">data CondExpr a where
  CondExpr :: (BoolExpr c, Expr e a, Expr e' a) 
           =&gt; c -&gt; e -&gt; e' -&gt; CondExpr a

instance Expr (CondExpr a) a where
  eval :: CondExpr a -&gt; a
  eval (CondExpr c e1 e2) = if eval c then eval e1 else eval e2
</code></pre>
<h3 id="question-6-5"><a class="header" href="#question-6-5">Question 6</a></h3>
<p>As per usual, we are going to define a typeclass <code>Sequence</code> that defines the methods <code>@</code>, <code>len</code> and <code>prepend</code>. The type parameters of <code>Sequence</code> is tricky. One possibility is for <code>Sequence</code> to be higher-kinded:</p>
<pre><code class="language-haskell">class Sequence e s where
    (@) :: s e -&gt; Int -&gt; e
    len :: s e -&gt; Int
    prepend :: s e -&gt; e -&gt; s e

instance Sequence [] a where
    -- ...
</code></pre>
<p>However, this will not work when having <code>Int</code>s as sequences because <code>Int</code> is not a type constructor. Therefore, we will just let <code>s</code> be the full sequence type, and introduce a functional dependency <code>s -&gt; e</code> so that the sequence type <code>s</code> <em>uniquely characterizes</em> the type of the elements of that sequence:</p>
<pre><code class="language-haskell">class Sequence e s | s -&gt; e where
    (@) :: s -&gt; Int -&gt; e
    len :: s -&gt; Int
    prepend :: s -&gt; e -&gt; s
</code></pre>
<p>In which case, the <code>Sequence</code> instances for <code>[a]</code> and <code>Int</code> becomes quite straightforward:</p>
<pre><code class="language-haskell">instance Sequence a [a] where
  (@) :: [a] -&gt; Int -&gt; a
  (@) = (!!)

  len :: [a] -&gt; Int
  len = length

  prepend :: [a] -&gt; a -&gt; [a]
  prepend = flip (:)

instance Sequence () Int where
  (@) :: Int -&gt; Int -&gt; ()
  i @ j 
    | j &lt; 0 || j &gt;= i = undefined
    | otherwise       = ()

  len :: Int -&gt; Int
  len = id

  prepend :: Int -&gt; () -&gt; Int
  prepend = const . (+1)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h3 id="question-1-7"><a class="header" href="#question-1-7">Question 1</a></h3>
<p>To implement these classes and methods, just "convert" the Haskell definitions to Python code. Note that <code>Validation</code> is <em>not</em> a monad.</p>
<pre><code class="language-python">from typing import Any
from dataclasses import dataclass

class List:
    @staticmethod
    def pure(x): return Node(x, Empty())

    # Convenience method for Question 3
    @staticmethod
    def from_list(ls):
        match ls:
            case []: return Empty()
            case x, *xs: return Node(x, List.from_list(xs))

@dataclass
class Node(List):
    head: object
    tail: List

    def map(self, f):
        return Node(f(self.head), self.tail.map(f))

    def ap(self, x):
        tails = self.tail.ap(x)
        heads = Node._ap(self.head, x) 
        return heads.concat(tails)

    # helper method
    @staticmethod
    def _ap(f, xs):
        match xs:
            case Empty(): return Empty()
            case Node(l, r): return Node(f(l), Node._ap(f, r))

    def concat(self, xs):
        return Node(self.head, self.tail.concat(xs))

    def flatMap(self, f):
        return f(self.head).concat(self.tail.flatMap(f))

@dataclass
class Empty(List):
    def map(self, f): return self
    def concat(self, xs): return xs
    def ap(self, x): return self
    def flatMap(self, f): return self

class Maybe:
    @staticmethod
    def pure(x): return Just(x)

@dataclass
class Just(Maybe):
    val: object

    def map(self, f): return Just(f(self.val))

    def ap(self, x): 
        match x:
            case Just(y): return Just(self.val(y))
            case Nothing(): return x

    def flatMap(self, f): return f(self.val)

@dataclass
class Nothing:
    def map(self, f): return self
    def ap(self, x): return self
    def flatMap(self, f): return self

class Either:
    @staticmethod
    def pure(x): return Right(x)

@dataclass
class Left(Either):
    inl: object
    def map(self, f): return self
    def ap(self, f): return self
    def flatMap(self, f): return self

@dataclass
class Right(Either):
    inr: object

    def map(self, f): return Right(f(self.inr))

    def ap(self, f): 
        match f:
            case Left(e): return f
            case Right(x): return Right(self.inr(x))

    def flatMap(self, f): return f(self.inr)

class Validation:
    @staticmethod
    def pure(x): return Success(x)

@dataclass
class Success:
    val: object

    def map(self, f): return Success(f(self.val))

    def ap(self, f): 
        match f:
            case Failure(e): return f
            case Success(x): return Success(self.val(x))


@dataclass
class Failure:
    err: list[str]

    def map(self, f): return self

    def ap(self, f):
        match f:
            case Failure(err): return Failure(self.err + err)
            case Success(x): return self
</code></pre>
<h3 id="question-2-7"><a class="header" href="#question-2-7">Question 2</a></h3>
<h4 id="question-21-unsafe-sum-1"><a class="header" href="#question-21-unsafe-sum-1">Question 2.1: Unsafe Sum</a></h4>
<p>The Python implementation of <code>sum_digits</code> can be a Haskell rewrite of your <code>sumDigits</code> solution for Question 6 in <a href="solutions/../course_introduction/sections/exercises.html">Chapter 1.4 (Course Introduction#Exercises)</a>:</p>
<pre><code class="language-python">def sum_digits(n):
    return n if n &lt; 10 else \
           n % 10 + sum_digits(n // 10)
</code></pre>
<h4 id="question-22-safe-sum-1"><a class="header" href="#question-22-safe-sum-1">Question 2.2: Safe Sum</a></h4>
<p>The idea is to have <code>sum_digits</code> return a <code>Maybe</code> object. In particular, the function should return <code>Nothing</code> if <code>n</code> is negative, and <code>Just x</code> when <code>n</code> is positive and produces result <code>x</code>.</p>
<pre><code class="language-python">def sum_digits(n):
    return Nothing() if n &lt; 0 else \
           Just(n)   if n &lt; 10 else \
           sum_digits(n // 10).map(lambda x: x + n % 10)
</code></pre>
<pre><code class="language-haskell">sumDigits :: Int -&gt; Maybe Int
sumDigits n
  | n &lt; 0 = Nothing
  | n &lt; 10 = Just n
  | otherwise = (n `mod` 10 +) &lt;$&gt; sumDigits (n `div` 10)
</code></pre>
<h4 id="question-23-final-sum-1"><a class="header" href="#question-23-final-sum-1">Question 2.3: Final Sum</a></h4>
<p>The result of <code>sum_digits</code> is a <code>Maybe[int]</code>, and <code>sum_digits</code> itself has type <code>int -&gt; Maybe[int]</code>. To compose <code>sum_digits</code> with itself we can use <code>flatMap</code> or <code>&gt;&gt;=</code>.</p>
<pre><code class="language-python">def final_sum(n):
    n = sum_digits(n)
    return n.flatMap(lambda n2: n2 if n2 &lt; 10 else final_sum(n2))
</code></pre>
<pre><code class="language-haskell">finalSum :: Int -&gt; Maybe Int
finalSum n = do
  n' &lt;- sumDigits n
  if n' &lt; 10 
  then Just n'
  else finalSum n'
</code></pre>
<h3 id="question-3-7"><a class="header" href="#question-3-7">Question 3</a></h3>
<h4 id="question-31-splitting-strings-1"><a class="header" href="#question-31-splitting-strings-1">Question 3.1: Splitting Strings</a></h4>
<p><code>split</code> in Python can be implemented with the <code>str.split</code> method. The <code>split</code> function for Haskell is shown in <a href="solutions/../railway_pattern/validation.html">Chapter 4.4 (Railway Pattern#Validation)</a>.</p>
<pre><code class="language-python"># Uses the convenience method from_list in the List class
def split(char, s):
    return List.from_list(s.split(char))
</code></pre>
<h4 id="question-32-csv-parsing-1"><a class="header" href="#question-32-csv-parsing-1">Question 3.2: CSV Parsing</a></h4>
<p>Split the string over <code>\n</code>, then split each string in that list over <code>,</code> using <code>map</code>:</p>
<pre><code class="language-python">def csv(s):
    return split('\n', s)
                .map(lambda x: split(',', x))
</code></pre>
<pre><code class="language-haskell">csv :: String -&gt; [[String]]
csv s = split ',' &lt;$&gt; (split '\n' s)
</code></pre>
<h3 id="question-4-7"><a class="header" href="#question-4-7">Question 4</a></h3>
<h4 id="question-41-factorial-1"><a class="header" href="#question-41-factorial-1">Question 4.1: Factorial</a></h4>
<p>Should be boring at this point.</p>
<pre><code class="language-python">def factorial(n):
    return 1 if n &lt;= 1 else \
           n * factorial(n - 1)
</code></pre>
<pre><code class="language-haskell">factorial :: Int -&gt; Int
factorial 0 = 1
factorial n = n * factorial (n - 1)
</code></pre>
<h4 id="question-42-safe-factorial-1"><a class="header" href="#question-42-safe-factorial-1">Question 4.2: Safe Factorial</a></h4>
<p>The idea is to return a <code>Left</code> if <code>n</code> is negative, <code>Right</code> with the desired result otherwise. Typically, <code>Right</code> is the happy path.</p>
<pre><code class="language-python">def factorial(n, name):
    if n &lt; 0: 
        return Left(name + ' cannot be negative!')
    if n &lt;= 1:
        return Right(1)
    return factorial(n - 1, name).map(lambda x: x * n)
</code></pre>
<pre><code class="language-haskell">factorial :: Int -&gt; String -&gt; Either String Int
factorial n name
  | n &lt; 0 = Left $ name ++ " cannot be negative!"
  | n &lt;= 1 = Right 1
  | otherwise = (n*) &lt;$&gt; factorial (n - 1) name
</code></pre>
<h4 id="question-43-safe-n-choose-k-1"><a class="header" href="#question-43-safe-n-choose-k-1">Question 4.3: Safe n choose k</a></h4>
<p>Idea: Compute \(n!\), \(k!\) and \((n - k)!\) in "parallel", combine with <code>ap</code>:</p>
<pre><code class="language-python">def choose(n, k):
    nf = factorial(n, 'n')
    kf = factorial(k, 'k')
    nmkf = factorial(n - k, 'n - k')
    div = lambda x: lambda y: lambda z: x // y // z
    return nf.map(div).ap(kf).ap(nmkf)    
</code></pre>
<pre><code class="language-haskell">choose :: Int -&gt; Int -&gt; Either String Int
choose n k 
    = let nf   = factorial n "n"
          kf   = factorial k "k"
          nmkf = factorial (n - k) "n - k"
          f x y z = x `div` y `div` z
      in f &lt;$&gt; nf &lt;*&gt; kf &lt;*&gt; nmkf
</code></pre>
<p>With the <code>ApplicativeDo</code> language extension enabled, you can just use <code>do</code> notation:</p>
<pre><code class="language-haskell">{-# LANGUAGE ApplicativeDo #-}
choose :: Int -&gt; Int -&gt; Either String Int
choose n k = do
  nf &lt;- factorial n "n"
  kf &lt;- factorial k "k"
  nmkf &lt;- factorial (n - k) "n - k"
  return $ nf `div` kf `div` nmkf 
</code></pre>
<h4 id="question-44"><a class="header" href="#question-44">Question 4.4</a></h4>
<p>Redefine <code>factorial</code> to use <code>Validation</code> instead of <code>Either</code>:</p>
<pre><code class="language-python">def factorial(n, name):
    if n &lt; 0:
        return Failure([f'{name} cannot be negative!'])
    if n &lt;= 1:
        return Success(1)
    else:
        return factorial(n - 1, name).map(lambda x: n * x)

</code></pre>
<pre><code class="language-haskell">factorial :: Int -&gt; String -&gt; Validation [String] Int
factorial n name
  | n &lt; 0 = Failure [name ++ " cannot be negative!"]
  | n &lt;= 1 = Success 1
  | otherwise = (n*) &lt;$&gt; factorial (n - 1) name
</code></pre>
<p>Finally, update the type signature of <code>choose</code> (we do not need to do so in Python).</p>
<pre><code class="language-haskell">choose :: Int -&gt; Int -&gt; Validation [String] Int
choose n k = do
  nf &lt;- factorial n "n"
  kf &lt;- factorial k "k"
  nmkf &lt;- factorial (n - k) "n - k"
  return $ nf `div` kf `div` nmkf 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<p>In this chapter we will do a brief recap of some of the basic concepts you <em>might</em> have learnt in IT5001. If you haven't, fret not. The recap should provide enough context for you to read the rest of these notes.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="recursion-1"><a class="header" href="#recursion-1">Recursion</a></h1>
<p>Something is recursive if it is defined using itself. A simple (albeit
hardly useful and contrived) example is the following function:</p>
<pre><code class="language-python">def f(n):
    return f(n + 1)
</code></pre>
<p>As defined, the body of function <code>f</code> invokes itself. In other
words, it is <em>defined using itself</em>. Readers who are unconvinced that
<code>f</code> is not a recursive definition may see that it is analogous
to the following mathematical definition, which is clearly recursive:
$$f(n) = f(n + 1) = f(n + 2) = f(n + 3) = \dots$$</p>
<p>Data types can also be defined recursively:</p>
<pre><code class="language-python">from abc import ABC
from dataclasses import dataclass

class SinglyLinkedList(ABC):
    pass

class Empty(SinglyLinkedList):
    pass

@dataclass
class Node(SinglyLinkedList):
    head: object
    tail: SinglyLinkedList
</code></pre>
<p>Likewise, you can see that the <code>SinglyLinkedList</code> class has a subclass
<code>Node</code> which itself holds another <code>SinglyLinkedList</code>. This makes
<code>SinglyLinkedList</code> a recursive data structure.</p>
<p>The core idea we present in this section is that we can write recursive
functions by thinking <em>structural-inductively</em>.</p>
<h2 id="induction"><a class="header" href="#induction">Induction</a></h2>
<p>We shall begin by describing a <em>proof by induction</em> for a statement over
the natural numbers. The principle of a proof by induction is as
follows: given a <em>predicate</em> \(P(n)\) over the natural numbers, if we can
show:</p>
<ol>
<li>\(P(0)\) is true</li>
<li>\(\forall n \in \mathbb{N}.~P(n)\to P(n + 1)\) (for all natural
numbers \(n\), \(P(n)\) implies \(P(n + 1)\))</li>
</ol>
<p>Then \(P(n)\) is true for all natural numbers \(n\). This works because of
<em>modus ponens</em>.</p>
<p>\[\frac{p~~~~~~~~p\to q}{q} \text{Modus Ponens}\]</p>
<p><em>Modus Ponens</em> codifies the following idea: if a proposition \(p\) is
true, and if \(p\) implies \(q\), then \(q\) is true. To show how this allows
proofs by induction, we see that we have a proof of \(P(0)\). Since we
also know that \(P(0)\) implies \(P(0 + 1) = P(1)\), by <em>modus ponens</em>,
\(P(1)\) is true. We also know that \(P(1)\) implies \(P(2)\), and since from
earlier \(P(1)\) is true, by <em>modus ponens</em>, \(P(2)\) is also true, and so
on.</p>
<p>\[\frac{P(0)~~~~~~~~\forall k \in \mathbb{N}. P(k)\to P(k + 1)}{\forall n \in \mathbb{N}. P(n)} \text{Induction}\]
Let us attempt to write a proof by induction. We start with an
implementation of the factorial function, then prove that it is correct:</p>
<pre><code class="language-python">def factorial(n):
    return 1 if not n else \
           n * factorial(n - 1)
</code></pre>
<blockquote>
<p><em>Proposition</em>. Let \(P(n)\) be the proposition that <code>factorial(n)</code> returns \(n!\).
Then, for all natural numbers \(n\), \(P(n)\) is true.</p>
</blockquote>
<p><em>Proof.</em> We prove \(P(0)\) and \(\forall n\in\mathbb{N}.~P(n)\to P(n + 1)\)
separately.</p>
<p><strong>Basis</strong>. Trivial. \(0! = 1\). Furthermore, by definition,
<code>factorial(0)</code> returns <code>1</code>. In other words, \(P(0)\) is
true.</p>
<p><strong>Inductive</strong>. Suppose for some natural number \(k\),
<code>factorial(k)</code> returns
\(k! = k \times (k - 1) \times \dots \times 1\).</p>
<ul>
<li>By definition of <code>factorial</code>, <code>factorial(k + 1)</code> returns <code>(k + 1) * factorial(k)</code>.</li>
<li>By our supposition, this evaluates to \((k + 1) \times k!\), which is, by definition, \((k + 1)!\).</li>
</ul>
<p>Thus, if for some \(k\), <code>factorial(k)</code> returns \(k!\), then
<code>factorial(k + 1)</code> returns \((k + 1)!\). In other words,
\(\forall k\in\mathbb{N}.~P(k) \to P(k + 1)\).</p>
<p>As such, since we have proven \(P(0)\) and
\(\forall k\in\mathbb{N}.~P(k)\to P(k+1)\), we have proven
\(\forall n\in\mathbb{N}.~P(n)\) by induction. ◻</p>
<h2 id="recursion-via-inductive-reasoning"><a class="header" href="#recursion-via-inductive-reasoning">Recursion via Inductive Reasoning</a></h2>
<p>Naturally (haha), the next question to ask would be, "how do we make use
of induction to write recursive functions?" As above, the recipe for a
proof by induction involves (broadly) two steps:</p>
<ol>
<li>Proof of the basis, e.g. \(P(0)\)</li>
<li>The inductive proof, e.g. \(P(k)\to P(k + 1)\). Typically, the
inductive step is completed by <strong>supposing</strong> \(P(k)\) for some \(k\),
and showing \(P(k + 1)\).</li>
</ol>
<p>We can write recursive functions similarly by providing:</p>
<ol>
<li>Non-recursive computation for the result of the base-case, e.g.
\(f(0)\);</li>
<li>Recursive computation of \(f(k + 1)\) based on the result of \(f(k)\)
<strong>assuming</strong> that \(f(k)\) gives the correct result.</li>
</ol>
<p>Let us start with a simple description of the natural numbers:
$$\begin{aligned}
0 &amp;\in \mathbb{N} &amp;&amp;\triangleright~0\text{ is a natural number}\\
n \in \mathbb{N} &amp;\to S(n) \in \mathbb{N} &amp;&amp; \triangleright~\text{if }n \text{ is a natural number then it has a successor that is also a natural number}
\end{aligned}$$</p>
<p>In our usual understanding of the natural numbers,
\(S(n) = n + 1\).</p>
<p>A formulation of the natural numbers in Python might be the following:</p>
<pre><code class="language-python">class Nat: pass

@dataclass
class Zero(Nat): pass

@dataclass
class Succ(Nat):
    pred: Nat
</code></pre>
<p>In which case, the number 3 can be written as follows:</p>
<pre><code class="language-python">three = Succ(Succ(Succ(Zero())))
</code></pre>
<p>Let us attempt to define addition over the natural numbers as we have
formulated above, recursively:</p>
<pre><code class="language-python">&gt;&gt;&gt; three = Succ(Succ(Succ(Zero())))
&gt;&gt;&gt; two = Succ(Succ(Zero()))
&gt;&gt;&gt; add(three, two)
Succ(pred=Succ(pred=Succ(pred=Succ(pred=Succ(pred=Zero())))))
</code></pre>
<p>We might decide to perform recursion on the first addend (doing so on
the second addend is fine as well). In computing \(m + n\) there are two
possibilities for what \(m\) could be:</p>
<ul>
<li>\(0\), or</li>
<li>the successor of some natural number \(k\).</li>
</ul>
<p>The first case is straightforward since \(0\) itself is non-recursive (see the definition of <code>Zero</code> above), and \(0 + n\) is
just \(n\). In the other case of \(m + n\) where \(m = S(k)= k + 1\) for some
\(k\), assuming (via our inductive hypothesis) that <code>add(k, n)</code>
correctly gives \(k + n\), then \(m + n\) is \((k + n) + 1\) which can be done
by <code>Succ(add(k, n))</code>.</p>
<p>Therefore, we arrive at the following
solution:</p>
<pre><code class="language-python">def add(m, n):
    return n if m == Zero() else \
           Succ(add(m.pred, n))
</code></pre>
<p>Using <em>structural pattern matching</em> which we present in
<a href="recap/sections/../../types/sections/pattern_matching.html">Chapter 2.4 (Pattern Matching)</a>, we may also write the following definition which
might be more intuitive:</p>
<pre><code class="language-python">def add(m, n):
    match m:
        case Zero(): return n
        case Succ(k): return Succ(add(k, n))
</code></pre>
<p>At this point you might be wondering why we had given such an odd
formulation of the natural numbers in Python, when we could have used
the <code>int</code> type instead (we totally could). One core idea we
would like to make apparent in this formulation, is that recursion via
inductive reasoning can be done over the <em>structure</em> of data. Our
formulation shows that natural numbers are recursive data structures,
where the successor of a natural number has a predecessor who is also,
likewise, a natural number. This should make writing recursive functions
over other kinds of recursive data structures not too great of a leap from
writing recursive functions over natural numbers. To show this, consult
our <code>SinglyLinkedList</code> data structure from above before we proceed to
write recursive functions over them using inductive reasoning.</p>
<p>First, we shall write a function that appends an element to the end of a
singly-linked list.</p>
<pre><code class="language-python">&gt;&gt;&gt; append(1, Empty())
Node(head=1,tail=Empty())
&gt;&gt;&gt; append(2, append(1, Empty()))
Node(head=1,tail=Node(head=2,tail=Empty()))
</code></pre>
<p>We can perform recursion over the structure of the list. There are two
possible structures of the list:</p>
<ol>
<li>The empty list</li>
<li>A node of a head element and a tail list</li>
</ol>
<p>In the former, we append to an empty list, which should give the singleton. Note once
again that because the empty list is non-recursive, our solution for
appending to the empty list likewise requires no recursion. For the
second case of \([e_1, e_2,\dots,e_n]\) (shorthand for
\(\mathtt{Node}(e_1, [e_2,\dots,e_n])\)), assume that our solution is
correct for the substructure of the <code>Node</code>, i.e.
\(\mathtt{append}(x, [e_2,\dots,e_n]) = [e_2,\dots,e_n, x]\). Our goal is
to have
$$\mathtt{append}(x, \mathtt{Node}(e_1, [e_2,\dots,e_n])) = \mathtt{Node}(e_1, [e_2,\dots,e_n,x])$$</p>
<p>Observe that:</p>
<p>$$\begin{aligned}
\mathtt{append}(x, \mathtt{Node}(e_1, [e_2,\dots,e_n])) &amp;= \mathtt{Node}(e_1, [e_2,\dots,e_n,x])\\
&amp;= \mathtt{Node}(e_1, \mathtt{append}(x, [e_2,\dots,e_n]))
\end{aligned}$$</p>
<p>Therefore, we can write:</p>
<pre><code class="language-python">def append(x, ls):
    if ls == Empty():
        return Node(x, Empty())
    return Node(ls.head, append(x, ls.tail))

# Using structural pattern matching:
def append2(x, ls):
    match ls:
        case Empty():
            return Node(x, Empty())
        case Node(e1, xs):
            return Node(e1, append2(x, xs))
</code></pre>
<p>We shall give another example by writing list reversals recursively,
going straight into our derivation. Reversing the empty list gives the
empty list. For nonempty lists our goal is to have
\(\mathtt{reverse}([e_1,\dots,e_n])=[e_n,\dots,e_1]\). Assuming that
\(\mathtt{reverse}([e_2,\dots,e_n])=[e_n,\dots,e_2]\), we can see that
\([e_n,\dots,e_1] = \mathtt{append}(e_1, [e_n,\dots,e_2])\), giving us the
following formulation:</p>
<pre><code class="language-python">def reverse(ls):
    if ls == Empty():
        return Empty()
    return append(ls.head, reverse(ls.tail))

# Using structural pattern matching:
def reverse2(ls):
    match ls:
        case Empty(): return Empty()
        case Node(e1, xs): return append(e1, reverse2(xs))
</code></pre>
<p>By this point you should be able to see that recursion can be done via
the following based on the structure of the data:</p>
<ol>
<li>If the structure of the data is non-recursive, provide a non-recursive computation
that computes the result directly</li>
<li>If the structure of the data is recursive, recursively solve the problem on the
substructure(s) of the data (e.g. <code>pred</code> or <code>tail</code> of the natural
number or list), and include its result in your main result</li>
</ol>
<p>You should be well aware that data structures may be more complex. For
example, solving a problem for a structure may require more than one
recursive calls, one non-recursive call and one recursive call, etc. To
make this apparent, let us look at a formulation of a binary tree of
integers:</p>
<pre><code class="language-python">class Tree: pass

@dataclass
class EmptyTree(Tree): pass

@dataclass
class TreeNode(Tree):
    left: Tree
    val: int
    right: Tree
</code></pre>
<p>Now let us attempt to write a function that sums all integers in the
tree. Again there are two possible structures a tree can have: the first
being the empty tree, which has sum 0. For tree nodes, we have two
subtrees, <code>left</code> and <code>right</code>, from whom we may recursively obtain their
sums using our function. Then, the sum of the entire tree is just the
total of the value at the node, the sum of the left subtree and the sum
of the right subtree:</p>
<pre><code class="language-python">def sum_tree(t):
    if t == EmptyTree():
        return 0
    return t.val + sum_tree(t.left) + sum_tree(t.right)

# Structural pattern matching
def sum_tree(t):
    match t:
        case EmptyTree(): return 0
        case TreeNode(l, v, r):
            return sum_tree(l) + v + sum_tree(r)
</code></pre>
<p>In summary, our formulation of the natural numbers reveals that numbers are also structurally recursive, and therefore, are amenable to recursive computations. We can extend this idea to all recursive structures, which as you will see in these notes, is very common.</p>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="first-class-functions-1"><a class="header" href="#first-class-functions-1">First-Class Functions</a></h1>
<p>When we say that a language has first-class functions, what we mean is that functions are just regular terms or objects just like other terms and objects that you frequently encounter. Therefore, they can be <em>assigned to variables</em>, <em>passed in as arguments</em> and <em>returned from functions</em>. A language like Python (and of course, functional programming languages like Haskell and Lean) has first-class functions, making the following program completely valid:</p>
<pre><code class="language-python">def foo():
    return 1
x = foo
y = x() # 1
</code></pre>
<p>Although this program seems extremely weird, especially for those who are familiar with languages like C and Java, it totally works. The idea is, at least in Python, that functions are also <em>objects</em>, and therefore the <code>foo</code> <em>name</em> or <em>variable</em> actually stores a reference to the function that always returns <code>1</code>. This reference can be assigned to any other variable like <code>x</code> because <code>foo</code> is also a reference to an object! Then, when we invoke <code>x</code>, the Python runtime looks-up the reference stored in <code>x</code> which points to the <code>foo</code> function, and thus evaluates to <code>1</code>.</p>
<p>Then, a function that receives functions as arguments or returns functions is known as a <em>higher-order function</em>. Let us look at the following examples:</p>
<pre><code class="language-python">def add(x):
    def add_x(y):
        return x + y
    return add_x
</code></pre>
<p>Invoking this function is slightly weird, although still behaves more-or-less as expected:</p>
<pre><code class="language-python">&gt;&gt;&gt; add(1)(2)
3
</code></pre>
<p>As you can see, <code>add</code> defines a local function <code>add_x</code> that receives <code>y</code> and returns <code>x + y</code>, for whatever <code>x</code> was passed into <code>add</code>. Then, <code>add</code> returns the <code>add_x</code> function itself! Therefore, <code>add(1)</code> actually evaluates to the <em>function</em> <code>add_x</code> where <code>x</code> is <code>1</code>, and when <em>that</em> is invoked, it evaluates to <code>1 + 2</code> which is <code>3</code>! This is an example of a function that <em>returns</em> a function, making it a higher-order function.</p>
<p>Another example is as follows:</p>
<pre><code class="language-python">def map(f, it):
    return (f(i) for i in it)
</code></pre>
<p>This function <em>invokes</em> the argument <code>f</code>, passing each <code>i</code> from <code>it</code>. Therefore, <code>f</code> is a function! An example of using <code>map</code> is as follows:</p>
<pre><code class="language-python">&gt;&gt;&gt; def add_1(x): return x + 1
&gt;&gt;&gt; list(map(add_1, [1, 2, 3]))
[2, 3, 4]
</code></pre>
<p>As you can see, <code>map</code> applies <code>add_1</code> to every single element of <code>[1, 2, 3]</code> and yields them into the resulting list, thereby giving us <code>[2, 3, 4]</code>! Again, since <code>map</code> <em>receives</em> functions like <code>add_1</code>, it is also a higher-order function.</p>
<p>Having to write simple functions like <code>add_1</code> is incredibly cumbersome. As such, languages like Python and Java make it easy to define <em>anonymous functions</em>, usually named <em>lambda expressions</em><sup class="footnote-reference"><a href="#1">1</a></sup>. A lambda expression in Python looks like this:</p>
<pre><code class="language-python">&gt;&gt;&gt; list(map(lambda x: x + 1, [1, 2, 3]))
[2, 3, 4]
</code></pre>
<p>The idea is simple: the variable names to the left of <code>:</code> are the function's parameters, and the expression to the right of <code>:</code> is its return value. Obviously, this makes <code>lambda</code> expressions more restrictive since we cannot express multi-statement functions, but that is not the point. It provides a convenient syntax for defining short functions, which comes in handy very frequently.</p>
<h2 id="nested-functions-and-closures"><a class="header" href="#nested-functions-and-closures">Nested Functions and Closures</a></h2>
<p>You have likely been introduced to the idea of a <em>nested function</em>, i.e. it is a function that is defined locally within another function. And example is as follows:</p>
<pre><code class="language-python">def f(x):
    def g(y):
        return x + y
    return g
</code></pre>
<p><code>f</code> defines a nested local function <code>g</code>. In a sense, a nested function is just a function defined within a function. However, recall that local variables and definitions are typically erased from the <em>call stack</em> once the function has returned. Therefore, when an expression like <code>f(2)</code> is evaluated, the Python runtime should allocate a stack frame for <code>f</code>, which, internally defines <code>g</code> and has the local binding for <code>x = 2</code>. The function returns the reference stored in <code>g</code>. As the function is returned, all the local variables should have been torn down, such as the local variable <code>g</code> (however, the heap reference stored in <code>g</code> (which points to the local function definition) is returned to the caller of <code>f</code>, so it remains in memory and is accessible). However, <code>x</code>, containing the reference to the value <code>2</code> should also be cleaned up since <code>x</code> is a local variable! In this case, how does <code>f(2)(3)</code> become <code>5</code> if the local variable <code>x</code> has been cleaned and the binding has been forgotten?</p>
<p>It turns out that languages that have first-class functions frequently support <em>closures</em>, that is, an environment that <em>remembers</em> the bindings of local variables. Therefore, when <code>f(2)</code> is invoked, it does not return <code>g</code> as-is, with a reference to some local <code>x</code> with no binding. Instead, it returns <code>g</code> with an environment containing the binding <code>x = 2</code>. As such, when we then invoke <em>that</em> function passing in <code>3</code> (i.e. <code>f(2)(3)</code>), it returns <code>x + y</code> where <code>y</code> is obviously <code>3</code>, but is also able to look up the environment <code>x = 2</code>, thereby evaluating to <code>5</code>.</p>
<h3 id="currying"><a class="header" href="#currying">Currying</a></h3>
<p>Nested functions and closures thereby support the phenomenon known as <em>currying</em>, which is to have a multi-parameter function being converted to successive single-parameter functions. Without loss of generality, suppose we have a function <code>f(x, y, z)</code>. <em>Currying</em> this function gives us a function <code>f(x)</code>, which returns a function <code>g</code>, defined as <code>g(y)</code>, that function returns another function <code>h</code> defined as <code>h(z)</code>, and <code>h</code> does whatever computation <code>f(x, y, z)</code> does. We offer the following simple example:</p>
<pre><code class="language-python">def add(x, y, z):
    return x + y + z

# Curried
def add_(x):
    def g(y):
        def h(z):
            return x + y + z
        return h
    return g

# Simpler definition with lambda expressions
def add__(x):
    return lambda y: lambda z: x + y + z
    # the scope of lambda expressions extend as far to the right
    # as possible, and therefore should be read as
    # lambda y: (lambda z: (x + y + z))
</code></pre>
<p>Currying supports <em>partial function application</em>, which supports code re-use. You will see <em>many</em> instances of currying used throughout these notes, and hopefully this will become second-nature to you.</p>
<h2 id="parameterizing-behaviour"><a class="header" href="#parameterizing-behaviour">Parameterizing Behaviour</a></h2>
<p>Consider the following functions:</p>
<pre><code class="language-python">def sum_naturals(n):
    return sum(i for i in range(1, n + 1))
def sum_cubes(n):
    return sum(i ** 3 for i in range(1, n + 1))
</code></pre>
<p>Clearly, the only difference between these two functions are the terms to sum. However, the difference in <code>i</code> and <code>i ** 3</code> cannot be abstracted into a single term. Instead, what we have to do is to abstract these as a function <code>f</code> on <code>i</code>! As such, what we want is to have a function that <em>parameterizes behaviour</em>, instead of just parameterizing values.</p>
<p>Since Python supports first-class functions, doing so is straightforward.</p>
<pre><code class="language-python">def sum_terms(n, f):
    return sum(f(i) for i in range(1, n + 1))
</code></pre>
<p>Then, we can use our newly defined <code>sum_terms</code> function to re-define <code>sum_naturals</code> and <code>sum_cubes</code> easily:</p>
<pre><code class="language-python">sum_naturals = lambda n: sum_terms(n, lambda i: i)
sum_cubes = lambda n: sum_terms(n, lambda i: i ** 3)
</code></pre>
<p>The process of abstracting over behaviour is no different when defining functions to abstract over data/values. Just <em>retain similarities and parameterize differences</em>! As another example, suppose we have two functions:</p>
<pre><code class="language-python">def scale(n, seq):
    return (i * n for i in seq)
def square(seq):
    return (i ** 2 for i in seq)
</code></pre>
<p>Again, we can retain the similarities (most of the code is similar), and parameterize the behaviour of either scaling each <code>i</code> or squaring each <code>i</code>. This can be written as a function <code>transform</code>, which we can use to re-define <code>scale</code> and <code>square</code>:</p>
<pre><code class="language-python"># If you notice carefully, this is more-or-less the implementation of map
def transform(f, seq):
    return (f(i) for i in seq)
scale = lambda n, s: transform(lambda i: i * n, s)
square = lambda s: transform(lambda i: i ** 2, s)
</code></pre>
<p>In fact, we can use the <code>transform</code> function to transform any iterable in whatever way we want!</p>
<h2 id="manipulating-functions"><a class="header" href="#manipulating-functions">Manipulating Functions</a></h2>
<p>On top of partial function application and parameterizing behaviour, we can use functions to manipulate/transform functions! Doing so typically requires us to define functions that <em>receive</em> and <em>return</em> functions. For example, if we want to create a function that receives a function <code>f</code> and returns a new function that applies <code>f</code> twice, we can write:</p>
<pre><code class="language-python">def twice(f):
    return lambda x: f(f(x))

mult_four = twice(lambda x: x * 2)

print(mult_four(3)) # 12
</code></pre>
<p>As you can see, <code>twice</code> receives a function and returns a new function that applies the input function twice. In fact, we can take this further by generalizing <code>twice</code>, i.e. defining a function <code>compose</code> that performs function composition:
\[(g\circ f)(x) = g(f(x))\]</p>
<pre><code class="language-python">def compose(g, f):
    return lambda x: g(f(x))

mult_four = compose(lambda x: x * 2, lambda x: x * 2)
plus_three_mult_two = compose(lambda x: x * 2, lambda x: x + 3)

print(mult_four(3)) # 12
print(plus_three_mult_two(5)) # 16
</code></pre>
<p>This is a really powerful idea and you will see this phenomenon frequently in this course.</p>
<p>Specific to Python, we can use single-parameter function-manipulating functions like <code>twice</code> as decorators:</p>
<pre><code class="language-python">@twice
def mult_four(x):
    return x * 2

print(mult_four(3)) # 12
</code></pre>
<p>Although the definition of <code>mult_four</code> actually only multiplies the argument by <code>2</code>, the <code>twice</code> decorator transforms it to be applied twice, therefore multiplying the argument by <code>4</code>! While decorators are useful, Haskell does not have decorators similar to this, although, frankly, this is not a required feature in Haskell since it has features much more ergonomic than this.</p>
<h2 id="map-filter-reduce-and-flatmap"><a class="header" href="#map-filter-reduce-and-flatmap">Map, Filter, Reduce and FlatMap</a></h2>
<p>There are several higher-order functions that are frequently used in programming. One of these functions is <code>map</code>, and is more-or-less defined as such:</p>
<pre><code class="language-python">def map(f, ls):
    return (f(i) for i in ls)
</code></pre>
<p>This is exactly what you've seen earlier in <code>transform</code>! The idea is that <code>map</code> receives a function that maps each element of the iterable <code>ls</code>, and produces an iterable containing those transformed elements. Using it is incredibly straightforward:</p>
<pre><code class="language-python">&gt;&gt;&gt; list(map(lambda i: i + 1, [1, 2, 3]))
[2, 3, 4]
&gt;&gt;&gt; list(map(lambda i: i * 2, [1, 2, 3]))
[2, 4, 6]
</code></pre>
<p>As you can see, <code>map</code> allows us to transform every element of an input iterable using a function. Another function, <code>filter</code>, filters out elements that do not meet a <em>predicate</em>:</p>
<pre><code class="language-python">def filter(f, ls):
    return (i for i in ls if f(i))
</code></pre>
<pre><code class="language-python">&gt;&gt;&gt; list(filter(lambda x: x &gt;= 0, [-2, -1, 0, 1]))
[0, 1]
</code></pre>
<p><code>map</code> and <code>filter</code> are powerful tools for transforming an iterable/sequence. However, what about aggregations? For this, we have the <code>reduce</code> function:</p>
<pre><code class="language-python">def reduce(f, it, init):
    for e in it:
        init = f(init, e)
    return init
</code></pre>
<p>As you can see, <code>reduce</code> receives three arguments: (1) a binary operation <code>f</code> that combines two elements (the left element is initially the <code>init</code> term, and also holds every successive application of <code>f</code>, i.e. it is the <em>accumulator</em>), (2) the iterable <code>it</code>, and (3) the initial value <code>init</code>. It essentially abstracts over the <em>accumulator</em> pattern that you have frequently seen, such as a function that sums over numbers or reverses a list:</p>
<pre><code class="language-python">def sum(ls):
    acc = 0
    for i in ls:
        acc = acc + i
    return acc

def reverse(ls):
    acc = []
    for i in ls:
        acc = [i] + acc
    return acc
</code></pre>
<p>In summary, <code>0</code> in <code>sum</code> and <code>[]</code> in <code>reverse</code> acts as <code>init</code> in <code>reduce</code>; <code>ls</code> in both functions act as <code>it</code> in <code>reduce</code>; <code>lambda acc, i: acc + i</code> and <code>lambda acc, i: [i] + acc</code> acts as <code>f</code> in <code>reduce</code>. We can therefore rewrite both of these functions using <code>reduce</code> as such:</p>
<pre><code class="language-python">&gt;&gt;&gt; sum = lambda ls: reduce(lambda x, y: x + y, ls, 0)
&gt;&gt;&gt; reverse = lambda ls: reduce(lambda x, y: [y] + x, ls, [])
&gt;&gt;&gt; sum([1, 2, 3, 4])
10
&gt;&gt;&gt; reverse([1, 2, 3, 4])
[4, 3, 2, 1]
</code></pre>
<p>Another way to view <code>reduce</code> is as a <em>left-associative fold</em>. To give you an example, suppose we are calling <code>reduce</code> with arguments <code>f</code>, <code>[1, 2, 3, 4]</code> and <code>i</code> as the initial value. Then, <code>reduce(f, [1, 2, 3, 4], i)</code> would be equivalent to:</p>
<pre><code>reduce(f, [1, 2, 3, 4], i) ==&gt; f(f(f(f(i, 1), 2), 3), 4)
</code></pre>
<p>One last function that should be unfamiliar to Python developers is a <code>flatMap</code> function, which performs <code>map</code>, but also does a one-layer flattening of the result. This function is available in other languages like Java, JavaScript and many other languages due to its connection to <em>monads</em>, but we shall give a quick view of what it might look like in Python:</p>
<pre><code class="language-python">def flat_map(f, it):
    for i in it:
        for j in f(i):
            yield j
</code></pre>
<p>The idea is that <code>f</code> receives an element of <code>it</code> and returns an <em>iterable</em>, and we loop through the elements of that iterable and yield them individually. Take for example a function that turns integers into lists of their digits:</p>
<pre><code class="language-python">&gt;&gt;&gt; to_digits = lambda n: list(map(int, str(n)))
&gt;&gt;&gt; to_digits(1, 2, 3, 4)
[1, 2, 3, 4]
</code></pre>
<p>If we had used <code>map</code> over a list of integers, we get a two-dimensional list of integers, where each component list is the list of digits of the corresponding integer:</p>
<pre><code class="language-python">&gt;&gt;&gt; list(map(to_digits, [11, 22, 33]))
[[1, 1], [2, 2], [3, 3]]
</code></pre>
<p>If we had used <code>flat_map</code> instead, we would get the same mapping of integers into lists of digits; however, the list is flattened into a list of digits of all the integers:</p>
<pre><code class="language-python">&gt;&gt;&gt; list(flat_map(to_digits, [11, 22, 33]))
[1, 1, 2, 2, 3, 3]
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The term <em>lambda expression</em> is inspired from the \(\lambda\)-calculus.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><p><img src="https://img.shields.io/badge/LAST%20UPDATED-26%20OCT%202024-57ffd8?style=for-the-badge" alt="Updated" /></p>
<h1 id="lambda-calculus"><a class="header" href="#lambda-calculus">Lambda Calculus</a></h1>
<p>The \(\lambda\) calculus, invented by Alonzo Church, is, essentially, one of the simplest formal "programming" languages. It has a simple <em>syntax</em> and <em>semantics</em> for how programs are evaluated.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Let us first consider the <em>untyped</em> \(\lambda\) <em>calculus</em> containing variables, atoms<sup class="footnote-reference"><a href="#1">1</a></sup>, abstractions and applications. The syntax of \(\lambda\) terms <code>e</code> in the the untyped \(\lambda\) calculus is shown here:</p>
<pre><code>e ::= v      &gt; variables like x, y and z
   |  a      &gt; atoms like 1, 2, True, +, *
   |  λv.e   &gt; function abstraction, such as def f(v): return e
   |  e e'   &gt; function call a.k.a function application such as e(e')
</code></pre>
<p>Part of the motivation for this new language is for expressing higher-order functions. For example, if we wanted to define a function like:</p>
<pre><code class="language-python">def add(x):
    def g(y):
        return x + y
    return g
</code></pre>
<p>Doing so mathematically might be a little clumsy. Instead, with the \(\lambda\) calculus, we can write it like so:</p>
<p>\[\textit{add} = \lambda x.\lambda y. x + y\]</p>
<p>Just like in Python, the scope of a \(\lambda\) abstraction extends as far to the right as possible, so the function above should be read as:</p>
<p>\[\textit{add} = \lambda x.(\lambda y. (x + y))\]</p>
<p>We show the correspondence between terms in the \(\lambda\) calculus with lambda expressions in Python:</p>
<div class="table-wrapper"><table><thead><tr><th>\(\lambda\) term</th><th>Python Expression</th></tr></thead><tbody>
<tr><td>\(\lambda x. x + 1\)</td><td><code>lambda x: x + 1</code></td></tr>
<tr><td>\(\lambda x. \lambda y. x~y\)</td><td><code>lambda x: lambda y: x(y)</code></td></tr>
<tr><td>\((\lambda x. 2 \times x)~y\)</td><td><code>(lambda x: 2 * x)(y)</code></td></tr>
</tbody></table>
</div>
<p>Function applications are left-associative, therefore \(e1~e2~e3\) should be read as \((e1 ~ e2) ~ e3\), and in Python, <code>e1(e2)(e3)</code> should be read as <code>(e1(e2))(e3)</code>.</p>
<h2 id="semantics"><a class="header" href="#semantics">Semantics</a></h2>
<p>To begin describing how \(\lambda\) calculus executes a program (which is really just a \(\lambda\) term), we first distinguish between <em>free</em> and <em>bound</em> variables in a \(\lambda\) term.</p>
<blockquote>
<p>Definition 1 (Free Variables). A variable \(x\) in a \(\lambda\) term \(e\) is</p>
<ul>
<li><em>bound</em> if it is in the scope of a \(\lambda x\) in \(e\)</li>
<li><em>free</em> otherwise</li>
</ul>
</blockquote>
<p>Then, the functions \(BV\) and \(FV\) produce the bound and free variables of a \(\lambda\) term respectively. For example, \(FV(\lambda x. \lambda y. x ~ y ~ z) = \{z\}\).</p>
<p>Now we want to be able to perform <em>substitutions</em> of variables with terms. For example, when we have an application of the form \((\lambda x. e_1) ~ e_2\), what we want is for \(e_2\) to be substituted with \(x\) in \(e_1\), just like the following function in Python:</p>
<pre><code class="language-python">def f(x): return x + 1
f(2) # becomes 2 + 1 which is 3, because we substituted x with 2
</code></pre>
<p>However, this is not straightforward because we may introduce name clashes. For example, if we had \((\lambda x. \lambda y. x ~ y) y\), performing a function call with naive substitution gives us \(\lambda y. y ~ y\) which is wrong, because now the free variable \(x\) is substituted with the <em>bound</em> variable \(y\), so the meaning is not preserved. As such, we define <em>substitutions</em> on \(\lambda\) terms keeping this in mind.</p>
<blockquote>
<p>Definition 2 (Substitution). \(e_1[x := e_2]\) is the substitution of all <em>free</em> occurrences of \(x\) in \(e_1\) with \(e_2\), changing the names of bound variables to avoid name clashes. Substitution is defined by the following rules:</p>
<ol>
<li>\(x[x := e] \equiv e\)</li>
<li>\(a[x := e] \equiv a\) where \(a\) is an atom</li>
<li>\((e_1 ~ e_2)[x := e_3] \equiv (e_1[x := e_3])(e_2[x := e_3])\)</li>
<li>\((\lambda x.e_1)[x := e_2] \equiv \lambda x.e_1\) since \(x\) is not free</li>
<li>\((\lambda y.e_1)[x := e_2] \equiv \lambda y.e_1\) if \(x \notin FV(e_1)\)</li>
<li>\((\lambda y.e_1)[x := e_2] \equiv \lambda y.(e_1[x:=e_2])\) if \(x \in FV(e_1)\) and \(y\notin FV(e_2)\)</li>
<li>\((\lambda y.e_1)[x := e_2] \equiv \lambda z.(e_1[y:=z][x := e_2])\) if \(x \in FV(e_1)\) and \(y\in FV(e_2)\)</li>
</ol>
</blockquote>
<p>We give some example applications of each rule:</p>
<ol>
<li>\(x[x := \lambda x. x] \equiv \lambda x. x \)</li>
<li>\(1[x := \lambda x. x] \equiv 1 \)</li>
<li>\((x ~ y)[x := z] \equiv z ~ y\)</li>
<li>\((\lambda x. x+1)[x := y] \equiv \lambda x. x + 1\)</li>
<li>\((\lambda y. \lambda x. x+y)[x := z] \equiv \lambda y. \lambda x. x+y\)</li>
<li>\((\lambda y. x+y)[x := z] \equiv \lambda y. z+y\)</li>
<li>\((\lambda y. x+y)[x := y] \equiv \lambda z. y+z\) (rename \(y\) to \(z\) before performing substitution)</li>
</ol>
<p>The last rule where variables are renamed to avoid name clashes introduces a form of equivalence known as \(\alpha\) congruence. It captures the idea that renaming parameters in functions does not change its meaning. For example, the two functions below are, in operation, identical:</p>
<pre><code class="language-python">def f(x):
    return x + 1
def f(y):
    return y + 1
</code></pre>
<p>In other words, if two terms differ only in the name of the bound variables, they are said to be \(\alpha\) congruent.</p>
<p>Finally, we get to the actual semantics of \(\lambda\) calculus, which is described by \(\beta\) reduction. Essentially it is as we have briefly described earlier—a function application <code>(lambda x: e1)(e2)</code>, evaluates to <code>e1</code> where <code>x</code> is substituted with <code>e2</code>:</p>
<p>\[(\lambda x. e) ~ y \triangleright_\beta e[x := y]\]</p>
<p>For example:</p>
<p>\[\begin{align*}
(\lambda x.\lambda y. x ~ y)(\lambda x. x + 1)(2) &amp;\triangleright_\beta (\lambda y. x ~ y)[x := \lambda x. x + 1] (2)\\
&amp; \equiv (\lambda y. (\lambda x. x + 1) ~ y)(2)\\
&amp; \triangleright_\beta ((\lambda x. x + 1) ~ y)[y := 2]\\
&amp; \equiv (\lambda x. x + 1)(2)\\
&amp; \triangleright_\beta (x + 1)[x := 2]\\
&amp; \equiv 2 + 1 \\
&amp; \equiv 3
\end{align*}
\]</p>
<p>This is more-or-less how Python evaluates function calls:</p>
<pre><code class="language-python">&gt;&gt;&gt; (lambda x: lambda y: x(y))(lambda x: x + 1)(2)
3
</code></pre>
<h2 id="typed-variants"><a class="header" href="#typed-variants">Typed Variants</a></h2>
<p>Python has types, which describes the class from which an object was instantiated:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; type(1)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(1.0)
&lt;class 'float'&gt;
</code></pre>
<p>We will describe more on types in <a href="recap/sections/../../types/README.html">Chapter 2 (Types)</a>. But for now, know that we can also assign types to terms in the \(\lambda\) calculus, giving us new forms of \(\lambda\) calculi. The simplest type system we can add to the \(\lambda\) calculus is, well, simple types, forming the <em>simply-typed</em> \(\lambda\) <em>calculus</em>.</p>
<p>For now, we shall restrict types to be the base types to only include <code>int</code>, giving us a new language for the calculus:</p>
<pre><code>Terms
e ::= v         &gt; variables like x, y and z
   |  a         &gt; atoms like 1, 2, +, *
   |  λv: t.e   &gt; function abstraction, such as def f(v: t): return e
   |  e e'      &gt; function call a.k.a function application such as e(e')

Types
t ::= int         &gt; base type constants, only including integers
   |  t -&gt; t'     &gt; type of functions; -&gt; is right-associative
</code></pre>
<p>The introduction of types to the calculus now adds the notion of <em>well-typedness</em> to the language. Specifically, not all terms in the untyped \(\lambda\) calculus are well-typed in the simply typed \(\lambda\) calculus. To formalize this notion of well-typedness, we define <em>typing rules</em> that dictate when a term is well-typed, and what type a term has.</p>
<p>First we have <em>typing environments</em> \(\Gamma,\Delta,\dots,\) which are sets (or sometimes lists) of <em>typing assumptions</em> of the form \(x:\tau\), stating that we are assuming that \(x\) has type \(\tau\). Then, the <em>typing relation</em> \(\Gamma\vdash e: \tau\) states that in the context \(\Gamma\), the term \(e\) has type \(\tau\). The reason we need typing environments is so that the types of in-scope bound variables in \(\lambda\) terms are captured and can be used in the derivation of the types of terms. Instances of typing relations are known as <em>typing judgements</em>.</p>
<p>The validity of a typing judgement is shown by providing a <em>typing derivation</em> that is constructed using <em>typing rules</em>, which are inference rules:</p>
<p>\[\frac{A_1 ~ A_2 ~ \dots ~ A_n}{B}\]</p>
<p>Which basically states that if all the statements \(A_i\) are valid, then the statement \(B\) is also valid.</p>
<p>Then, the simply-typed \(\lambda\) calculus uses the following rules.</p>
<ol>
<li>If a variable \(x\) has type \(\tau\) in \(\Gamma\) then in the context \(\Gamma\), \(x\) has type \(\tau\)
\[
\frac{x:\tau \in \Gamma}{\Gamma \vdash x : \tau}
\]</li>
<li>If an atom \(a\) has type \(\tau\) then we can also judge the type of \(a\) accordingly
\[
\frac{a\text{ is an atom of type }\tau}{\Gamma \vdash a: \tau}
\]</li>
<li>Abstraction: If in a certain context we can assume that \(x\) has type \(\tau_1\) to conclude \(e\) has type \(\tau_2\), then the same context without this assumption shows that \(\lambda x:\tau_1.e\) has type \(\tau_1\to\tau_2\)
\[
\frac{\Gamma,x:\tau_1\vdash e:\tau_2}{\Gamma \vdash (\lambda x:\tau_1.e) : \tau_1 \to \tau_2}
\]</li>
<li>Application: If in a certain context \(e_1\) has type \(\tau_1\to\tau_2\) and \(e_2\) has type \(\tau_1\), then \(e_1 ~ e_2\) has type \(\tau_2\)
\[
\frac{\Gamma \vdash e_1: \tau_1\to\tau_2 ~~~~~~ \Gamma \vdash e_2: \tau_1}{\Gamma \vdash (e_1 ~ e_2) :\tau_2}
\]</li>
</ol>
<p>These rules can be used to perform <em>type checking</em> (the procedure of checking the well-typedness of a term) or <em>type reconstruction</em> (the procedure of finding the types of terms where their typing information is not present, as is the case in the untyped \(\lambda\) calculus).</p>
<p>For example, in our calculus we can show that \(\lambda x: \mathtt{int}\to\mathtt{int}. \lambda y:\mathtt{int}.x ~ y\) has type \((\mathtt{int}\to\mathtt{int})\to\mathtt{int}\to\mathtt{int}\) and is therefore a well-typed term:</p>
<p>\[
\frac{x:\mathtt{int}\to\mathtt{int} \in \Gamma,x:\mathtt{int}\to\mathtt{int},y:\mathtt{int}}{\Gamma, x: \mathtt{int}\to\mathtt{int}, y:\mathtt{int}\vdash x:\mathtt{int}\to\mathtt{int}}
\]</p>
<p>\[
\frac{y:\mathtt{int}\in \Gamma,x:\mathtt{int}\to\mathtt{int},y:\mathtt{int}}{\Gamma, x: \mathtt{int}\to\mathtt{int}, y:\mathtt{int}\vdash y:\mathtt{int}}
\]</p>
<p>\[
\frac{\Gamma,x:\mathtt{int}\to\mathtt{int},y:\mathtt{int}\vdash x: \mathtt{int}\to\mathtt{int}~~~~~~~ \Gamma,x:\mathtt{int}\to\mathtt{int},y:\mathtt{int}\vdash y: \mathtt{int}}{\Gamma, x: \mathtt{int}\to\mathtt{int}, y:\mathtt{int}\vdash (x ~ y):\mathtt{int}}
\]</p>
<p>\[
\frac{\Gamma, x: \mathtt{int}\to\mathtt{int}, y:\mathtt{int}\vdash (x ~ y):\mathtt{int}}{\Gamma, x: \mathtt{int} \to \mathtt{int} \vdash (\lambda y: \mathtt{int}. x ~ y) : \mathtt{int}\to\mathtt{int}}
\]</p>
<p>\[
\frac{\Gamma, x: \mathtt{int} \to \mathtt{int} \vdash (\lambda y: \mathtt{int}. x ~ y) : \mathtt{int}\to\mathtt{int}}{\Gamma\vdash (\lambda x: \mathtt{int} \to \mathtt{int}.\lambda y: \mathtt{int}. x ~ y) : (\mathtt{int}\to\mathtt{int})\to\mathtt{int}\to\mathtt{int}}
\]</p>
<p>That means the following lambda expression in Python (assuming only <code>int</code> exists as a base type) will have the same type:</p>
<pre><code class="language-python">&gt;&gt;&gt; f = lambda x: lambda y: x(y) # (int -&gt; int) -&gt; int -&gt; int
&gt;&gt;&gt; my_fn = lambda x: x + 1 # int -&gt; int
# f(my_fn): int -&gt; int
# f(my_fn)(3): int
&gt;&gt;&gt; f(my_fn)(3) # int
4
&gt;&gt;&gt; type(f(my_fn)(3))
class &lt;'int'&gt;
</code></pre>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The actual untyped \(\lambda\) calculus does not have atoms like numbers, booleans etc. However, for simplicity's sake we shall include them in the language. The version we present is frequently termed the <em>applied</em> \(\lambda\) <em>calculus</em>, in contrast with usual presentations known as the <em>pure</em> \(\lambda\) <em>calculus</em> which omits atoms.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
