<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Algebraic Data Types - Typed Functional Programming</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../about.html">About IT5100A</a></li><li class="chapter-item expanded affix "><li class="part-title">Typed Functional Programming</li><li class="chapter-item expanded "><a href="../../course_introduction/index.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../course_introduction/sections/course_admin.html"><strong aria-hidden="true">1.1.</strong> Course Administration</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/functional_programming.html"><strong aria-hidden="true">1.2.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/haskell.html"><strong aria-hidden="true">1.3.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/exercises.html"><strong aria-hidden="true">1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/sections/type_systems.html"><strong aria-hidden="true">2.1.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../../types/sections/polymorphism.html"><strong aria-hidden="true">2.2.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../../types/sections/algebraic_data_types.html" class="active"><strong aria-hidden="true">2.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="../../types/sections/pattern_matching.html"><strong aria-hidden="true">2.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="../../types/sections/exercises.html"><strong aria-hidden="true">2.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../typeclasses/index.html"><strong aria-hidden="true">3.</strong> Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../typeclasses/sections/ad-hoc-polymorphism.html"><strong aria-hidden="true">3.1.</strong> Ad-Hoc Polymorphism</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/typeclasses.html"><strong aria-hidden="true">3.2.</strong> Typeclasses</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/commonly-used-typeclasses.html"><strong aria-hidden="true">3.3.</strong> Commonly-Used Typeclasses</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/functional-dependencies.html"><strong aria-hidden="true">3.4.</strong> Functional Dependencies</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/exercises.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Railway Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Concurrent and Parallel Programming</div></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Solutions to Exercises</div></li><li class="chapter-item expanded "><a href="../../recap/index.html"><strong aria-hidden="true">8.</strong> Recap of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../recap/sections/recursion.html"><strong aria-hidden="true">8.1.</strong> Recursion</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> First-Class Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Lambda Calculus</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typed Functional Programming</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<p>We have just seen different data types in Haskell, and introduced the
concept of polymorphic types as demonstrated by examples in Python. Yet,
we have not discussed how we can create our own (polymorphic) data types
in Haskell!</p>
<p>Haskell is a purely functional language, so do not expect classes here.
In OOP, objects have both data (attributes) and behaviour (methods),
whereas this is not necessarily a principle in FP (you can have data
types with functions as fields). We already know how to create
functions, so now we must investigate how we can create data types in a
purely functional language.</p>
<p>If we think about it carefully, we might notice that data types are a
mix of the following:</p>
<ul>
<li>
<p>A type <strong>and</strong> another type <strong>and</strong>...<strong>and</strong> yet another type</p>
</li>
<li>
<p>A type <strong>or</strong> another type <strong>or</strong>...<strong>or</strong> yet another type</p>
</li>
</ul>
<p>::: example
We can express the following types using <strong>and</strong> and <strong>or</strong> over other
types:</p>
<ul>
<li>
<p>A <code>Fraction</code> consists of a numerator (<code>Int</code>) <strong>and</strong> a denominator
(<code>Int</code>)</p>
</li>
<li>
<p>A <code>Student</code> consists of a name (<code>String</code>) and an ID (<code>Int</code>)</p>
</li>
<li>
<p>A <code>Bool</code> is either <code>True</code> <strong>or</strong> <code>False</code></p>
</li>
<li>
<p>A <code>String</code> is either an empty string <strong>or</strong> (a head character
(<code>Char</code>) <strong>and</strong> a tail list (<code>String</code>))</p>
</li>
<li>
<p>A polymorphic <code>Tree</code> is either (a leaf with a value of type <code>a</code>)
<strong>or</strong> (a node with a value (<code>a</code>) <strong>and</strong> a left subtree (<code>Tree a</code>)
<strong>and</strong> a right subtree (<code>Tree a</code>))
:::</p>
</li>
</ul>
<p>This formulation of data types as products (<strong>and</strong>) and/or sums
(<strong>sum</strong>) is what is known as Algebraic Data Types (not to be confused
with Abstract Data Types). In Haskell, types are <strong>sums</strong> of one or more
<strong>constructors</strong>; constructors are <strong>products</strong> of zero or more types.</p>
<p>::: example
To create a new data type in Haskell, we can use the <code>data</code>{.haskell}
keyword. Let us create a fraction type based on our algebraic
specification above:</p>
<pre><code class="language-haskell">data Fraction = Fraction Int Int

half :: Fraction
half = Fraction 1 2
</code></pre>
<p>On the left hand side we have the declaration of the type, and on the
right hand side, a list of constructors that help us create the type.
Note that the <code>Fraction</code>{.haskell} on the right hand side is the name of
the constructor of the type; it in fact can be distinct from the name of
the type itself (which is very helpful when you have more than one
constructor). As you can see, to construct a <code>Fraction</code>{.haskell}, the
<code>Fraction</code>{.haskell} constructor receives two <code>Int</code>{.haskell}s, one
numerator, and one denominator.<br />
Then, defining the student type from our algebraic formulation above
should also be straightforward:</p>
<pre><code class="language-haskell">data Student = S String Int

bob :: Student
bob = S "Bob" 123
</code></pre>
<p>Let us define the <code>Bool</code> type, which should have two constructors, each
constructor not having any fields:</p>
<pre><code class="language-haskell">data Bool = True | False

true, false :: Bool
true = True
false = False
</code></pre>
<p>To construct a <code>Bool</code>{.haskell} we can use either the <code>True</code>{.haskell}
constructor or the <code>False</code>{.haskell} constructor. Neither of these
constructors receive any other fields.<br />
We can also have multiple constructors, each being products of more than
zero types, as we shall see in the algebraic formulation of a
<code>String</code>{.haskell}:</p>
<pre><code class="language-haskell">data String = EmptyString | Node Char String

hello, empty :: String
hello = Node 'h' (Node 'e' (Node 'l' (Node 'l' (Node 'o' EmptyString))))
empty = EmptyString
</code></pre>
<p>:::</p>
<h3 id="polymorphic-algebraic-data-types"><a class="header" href="#polymorphic-algebraic-data-types">Polymorphic Algebraic Data Types</a></h3>
<p>Now we show examples of creating our own polymorphic data types. The way
we would do so is similar to how we defined generic/polymorphic classes
in Python.</p>
<p>::: example
Let us start from the bottom again by creating specialized versions of a
box type, this time in Haskell. We start by assuming that a box contains
an <code>Int</code>{.haskell}:</p>
<pre><code class="language-haskell">data IntBox = IB Int
b :: IntBox
b = IB 1
</code></pre>
<p>Then define a box that contains a <code>String</code>{.haskell}:</p>
<pre><code class="language-haskell">data StrBox = SB String
b :: StrBox
b = SB "123"
</code></pre>
<p>Again, they look more or less the same, except for the type of the
field. As such, we should allow <code>Box</code>{.haskell} to be polymorphic by
introducing a type parameter:</p>
<pre><code class="language-haskell">data Box a = B a
x :: Box Int
x = B 1
y :: Box String
y = B "123"
</code></pre>
<p>Perfect! Let us try more complex polymorphic algebraic data types like
linked lists and trees:</p>
<pre><code class="language-haskell">data LinkedList a = EmptyList | Node a (LinkedList a)
cat :: LinkedList Char
cat = Node 'c' (Node 'a' (Node 't' EmptyList))

data Tree a = Leaf a | TreeNode (Tree a) a (Tree a)
tree :: Tree Int
tree = TreeNode (Leaf 1) 2 (Leaf 3)
</code></pre>
<p>:::</p>
<p>Constructors are actually functions!</p>
<pre><code class="language-haskell">ghci&gt; data Fraction = F Int Int
ghci&gt; :t F
F :: Int -&gt; Int -&gt; Fraction
ghci&gt; :t F 1
F 1 :: Int -&gt; Fraction
ghci&gt; :t F 1 2
F 1 2 :: Fraction
</code></pre>
<p>We now have the facilities to define and construct data types and their
terms, but so far we are not able to <em>access</em> the fields of a data type
in Haskell. Unlike Python, we are not able to do something like
<code>x.numerator</code> to obtain the numerator of a fraction <code>x</code>, for example.
There are ways to define functions that do so and we will show them to
you in later sections, but for now, Haskell has <em>record syntax</em> that
automatically defines these accessor functions for us.</p>
<p>::: example
Let us re-create the <code>Student</code>{.haskell} type, this time using record
syntax to automatically derive functions that obtain their names and
IDs:</p>
<pre><code class="language-haskell">data Student = S { name :: String, id :: Int }
</code></pre>
<p>With this, we no longer need to define our own functions that access
these fields for us. Record syntax is great for giving names to fields!
Importantly, record syntax is nothing special, and we can continue to
create terms of those types by way of usual constructor application.</p>
<pre><code class="language-haskell">x, y :: Student
x = S { name = "Alice", id = 123 }
y = S "Bob" 456
</code></pre>
<p>Let's try loading this into GHCI and see the accessor functions in
action:</p>
<pre><code class="language-haskell">ghci&gt; name x
"Alice"
ghci&gt; id y
456
</code></pre>
<p>:::</p>
<p>We can even mix and match these different forms of constructor
definitions, or create large data structures!</p>
<pre><code class="language-haskell">data Department = D {name' :: String, courses :: [Course]}
data Course = C { code :: String, 
                  credits :: Int,
                  students :: [Student] }
data Student = UG { homeFac :: String,
                    name :: String,
                    id :: Int }
             | PG [String] String Int

alice   = UG "SoC" "Alice" 123
bob     = PG ["SoC", "YLLSoM"] "Bob" 456
it5100a = C "IT5100A" 2 [alice]
it5100b = C "IT5100B" 2 [alice, bob]
cs      = D "Computer Science" [it5100a, it5100b]
</code></pre>
<h3 id="more-on-polymorphism"><a class="header" href="#more-on-polymorphism">More on Polymorphism</a></h3>
<p>Now that we have shown how to create our own algebraic data types in
Haskell (and polymorphic ones), we step aside and give a mental model
for understanding polymorphism. Recall that we have described
polymorphic functions and types as functions/types that
quantifies/parameterizes types; in other words, they receive a type as a
parameter.</p>
<p>Recall in the lambda calculus $\lambda$ creates a function over a
parameter. Assuming the parameter has type $S$ and the returned value
has type $T$, we get: $$\lambda x.e: S \to T$$ and when we call or apply
this function, we are substituting the parameter for the argument of the
function application: $$(\lambda x.e_1)e_2 \equiv_\beta e_1[x:=e_2]$$</p>
<p>::: example
$$\begin{aligned}
(\lambda x: \mathtt{Int}.x + 4)3 &amp;\equiv_\beta (x + 4)[x := 3]\
&amp;\equiv_\beta (3 + 4)\
&amp; \equiv_\beta 7
\end{aligned}$$ In Haskell (the expression in parentheses is a lambda
expression):</p>
<pre><code class="language-haskell">ghci&gt; (\x -&gt; x + 4) 3
7
</code></pre>
<p>:::</p>
<p>A typed variant of the lambda calculus known as System $F$ has
polymorphic functions, which are functions that also receive a type
parameter. We can then apply this function onto a type <em>argument</em> to get
a specialized version of that function. Such type parameters are bound
by $\Lambda$. As an example, if we have a term $e$ of type $T$, we get:
$$\Lambda \alpha.e: \forall\alpha.T$$ Calling or applying this function
with a type argument, once again, substitutes the type parameter with
the type argument:
$$(\Lambda\alpha.e).\tau\equiv_\beta e[\alpha := \tau]$$
$$(\Lambda\alpha.e).\tau : T[\alpha := \tau]$$</p>
<p>::: example
$$\begin{aligned}
(\Lambda \alpha.\lambda x:\alpha.[x]) \mathtt{Int} &amp;\equiv_\beta (\lambda x:\alpha.[x])[\alpha := \mathtt{Int}]\
&amp; \equiv_\beta \lambda x:\mathtt{Int}.[x]
\end{aligned}$$</p>
<p>We can show this with an example in Haskell. Explicit type arguments
must be enabled with a language extension and the type arguments must be
prefixed by <code>@</code>:</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications -fprint-explicit-foralls
ghci&gt; :{
ghci| f :: forall a. a -&gt; [a]
ghci| f x = [x]
ghci| :}

ghci&gt; :t f
f :: forall a. a -&gt; [a]

ghci&gt; :t f @Int
f @Int :: Int -&gt; [Int]

ghci&gt; f @Int 1
[1]
</code></pre>
<p>:::</p>
<p>On the other hand, polymorphic types can be seen as <em>functions at the
type-level</em>. These are "functions" that receive types and return types!
For example, we can define a <code>Pair</code>{.haskell} type that is polymorphic
in its component types. Thus, the <code>Pair</code>{.haskell} type itself (not its
constructor!) receives two types, and returns the resulting
<code>Pair</code>{.haskell} type specialized to those component types. This makes
<code>Pair</code>{.haskell} what is known as a <em>type constructor</em>.</p>
<p>To observe this fact, know that types are to terms as <em>kinds</em> are to
types: they describe what <em>kind</em> of type a type is. The usual types that
we encounter <code>Int</code>{.haskell}, <code>[[Char]]</code>{.haskell} etc. have kind
<code>*</code>{.haskell}, and type constructors or "type-level functions" have
kind <code>* -&gt; *</code>{.haskell} for example. Below, we show that
<code>Pair</code>{.haskell} is a type constructor of kind <code>* -&gt; * -&gt; *</code>{.haskell},
which makes sense since it receives two types and returns the
specialized type of the <code>Pair</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; data Pair a b = P a b
ghci&gt; :k Pair
Pair :: * -&gt; * -&gt; *
ghci&gt; :k Pair Int
Pair Int :: * -&gt; *
ghci&gt; :k Pair Int String
Pair Int String :: *
</code></pre>
<p>We know that we can have higher-order functions, for example, the type
of <code>map</code>{.haskell} might be something like
<code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>{.haskell}. Can we have higher-order type
constructors? Yes! These are known as <em>higher kinds</em> or <em>higher-kinded
types</em>. These types receive <em>type constructors</em> as type arguments. Let
us construct a higher-kinded type that receives a type constructor and
applies it onto a type:</p>
<pre><code class="language-haskell">ghci&gt; data Crazy f a = C (f a)
</code></pre>
<p>Upon visual inspection we can see that <code>f</code> must be a type constructor,
because the constructor <code>C</code>{.haskell} receives a term of type <code>f a</code>!
What's crazier is, when inspecting the kind of <code>Crazy</code>{.haskell}, we see
that it exhibits <em>kind polymorphism</em>:</p>
<pre><code class="language-haskell">ghci&gt; :set -fprint-explicit-foralls
ghci&gt; :k Crazy
Crazy :: forall {k}. (k -&gt; *) -&gt; k -&gt; *
</code></pre>
<p>To give you an example of how this might work, because we know we can
construct lists of any type, <code>[]</code>{.haskell} (the type, not the empty
list) must be a type constructor. We can thus pass the <code>[]</code>{.haskell}
type constructor into <code>Crazy</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; :k Crazy []
Crazy [] :: * -&gt; *
ghci&gt; :k Crazy [] Int
Crazy [] Int :: *
</code></pre>
<p>How might this work? We see that <code>Crazy [] Int</code>{.haskell} has kind <code>*</code>,
so we should be able to construct a term of this type. We can do so by
using the <code>C</code>{.haskell} constructor defined above! To be clear, let's
see the specialized version of the constructor with the type arguments
entered:</p>
<pre><code class="language-haskell">ghci&gt; :t C @[] @Int
C @[] @Int :: [Int] -&gt; Crazy [] Int
</code></pre>
<p>As we can see, to construct a term of this type, we just need to pass in
a list of integers to <code>C</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; x :: Crazy [] Int = C [1]
</code></pre>
<p>We can in fact instantiate other crazy types with different type
constructors:</p>
<pre><code class="language-haskell">ghci&gt; data Box a = B a
ghci&gt; y :: Crazy Box Int = C (B 2)
</code></pre>
<p>The utility of higher-kinded types may not be apparent to you now; later
on we might see some of them in action!</p>
<p>Although this might confuse you so far, what we have demonstrated merely
serves to demonstrate the idea that parametric polymorphism can be
thought of the phenomenon where something (type or term) can receive a
type and give you a type or term, just as we have stated at the
beginning of
<a href="#sec:polymorphism">[sec:polymorphism]</a>{reference-type="autoref"
reference="sec:polymorphism"}.</p>
<h3 id="other-polymorphisms"><a class="header" href="#other-polymorphisms">Other Polymorphisms</a></h3>
<p>At the start of
<a href="#sec:polymorphism">[sec:polymorphism]</a>{reference-type="autoref"
reference="sec:polymorphism"} we introduced three questions, two of
which have been answered. Let us restate the final question and pose one
more:</p>
<ol>
<li>
<p>Can types depend on terms?</p>
</li>
<li>
<p>Are there other kinds of polymorphism?</p>
</li>
</ol>
<p>The answers to both questions is yes. Types that depend on terms are
known as <em>dependent types</em>, which we shall not cover in this course.
There are also other kinds of polymorphisms, some of which you have
already dealt with. Subtype polymorphism is used frequently in OOP,
since subclasses are types that are <em>subtypes</em> of their superclasses. An
umbrella term <em>ad-hoc polymorphism</em> generally refers to <em>overloading</em>,
which we shall discuss in the future. There are also more kinds of
polymorphisms, but we shall not discuss them in this course.</p>
<p>Python (and several other mainstream languages) is quite special, being
a multi-paradigm language means that several forms of polymorphism are
applicable to it. In particular, we have seen that Python supports
parametric polymorphism, and since Python supports OOP, it also has
subtype polymorphism. Despite Python not having algebraic data types
(yet), we may also formulate our types to behave similarly to Algebraic
Data Types. Two formulations we may attempt are: 1) with types as unions
and constructors as classes, 2) with types as classes and constructors
as their subclasses. Below we present both formulations for the linked
list type:</p>
<pre><code class="language-python"># (1)
type List[a] = Node[a] | Empty

@dataclass
class Empty:
    pass

@dataclass
class Node[a]:
    head: a
    tail: List[a]

x: List[int] = Node(1, Node(2, Empty()))
</code></pre>
<pre><code class="language-python"># (2)
from typing import Any
@dataclass
class List[a]:
    pass

@dataclass
class Empty(List[Any]):
    pass

@dataclass
class Node[a](List[a]):
    head: a
    tail: List[a]

x: List[int] = Node(1, Node(2, Empty()))
</code></pre>
<p>There are some differences between the two formulations, and between
these with Haskell's Algebraic Data Types. Most importantly, in Haskell,
data types are types, but constructors are not. This is unlike Python,
where all classes are types. That means a variable of type
<code>Node[int]</code>{.python} is valid in Python, but a variable of type
<code>Node Int</code>{.haskell} is not in Haskell.</p>
<h3 id="sec:gadt"><a class="header" href="#sec:gadt">Generalized Algebraic Data Types</a></h3>
<p>However, something interesting is going on here. In the second
formulation, a <code>Node[a]</code>{.python} is a <code>List[a]</code>, which makes sense. On
the other hand, an <code>Empty</code> can be typed as <code>List[Any]</code>, because an empty
list fits all kinds of lists. An interesting observation you might see
is that the supertype of our "constructors" need not strictly be
<code>List[a]</code>, it could be any kind of list!</p>
<p>Consider the following example of defining simple expressions in a
polymorphic manner using OOP.</p>
<pre><code class="language-python">class Expr[a]:
    def eval(self) -&gt; a:
        raise Exception
</code></pre>
<p>The <code>Expr</code> class is parameterized by the type of its evaluation. From
this class we may now create subclasses of <code>Expr</code>. For example, some
simple numeric expressions.</p>
<pre><code class="language-python">@dataclass
class LitNumExpr(Expr[int]):
    n: int
    def eval(self) -&gt; int:
        return self.n

@dataclass
class AddExpr(Expr[int]):
    lhs: Expr[int]
    rhs: Expr[int]
    def eval(self) -&gt; int:
        return self.lhs.eval() + self.rhs.eval()
</code></pre>
<p>We can then create other kinds of expressions. For example, an equality
expression that returns booleans:</p>
<pre><code class="language-python">@dataclass
class EqExpr[a](Expr[bool]):
    lhs: Expr[a]
    rhs: Expr[a]
    def eval(self) -&gt; bool:
        return self.lhs.eval() == self.rhs.eval()
</code></pre>
<p>Or even a conditional expression whose evaluated type is parameterized:</p>
<pre><code class="language-python">@dataclass
class CondExpr[a](Expr[a]):
    cond: Expr[bool]
    true: Expr[a]
    false: Expr[a]
    def eval(self) -&gt; a:
        return self.true.eval() if self.cond.eval() else self.false.eval()
</code></pre>
<p>Let's try this out! Suppose we would like to evaluate the following
expression:</p>
<p>::: center
<code>if 1 == 2 then 1 + 1 else 0</code>
:::</p>
<p>Let's write this in the program using our classes and evaluate it!</p>
<pre><code class="language-python">zero: Expr[int] = LitNumExpr(0)
one: Expr[int] = LitNumExpr(1)
two: Expr[int] = LitNumExpr(2)
one_plus_one: Expr[int] = AddExpr(one, one)
one_eq_two: Expr[bool] = EqExpr(one, two)
cond: Expr[int] = CondExpr(one_eq_two, one_plus_one, zero)
print(cond.eval()) # 0
</code></pre>
<p>How do we create such an algebraic data type in Haskell? For this, we
have to use <em>Generalized Algebraic Data Types</em> (GADTs). Loosely, these
are algebraic data types like before, except that each constructor can
decide what type it returns!</p>
<p>First, let us formulate our original algebraic data types using GADT
syntax.</p>
<pre><code class="language-haskell">data LinkedList a where
    EmptyList :: LinkedList a -- this is a different a!
    Node :: b -&gt; LinkedList b -&gt; LinkedList b
</code></pre>
<p>Now let us take it a step further, and truly customize the constructors
of an <code>Expr</code>{.haskell} GADT:</p>
<pre><code class="language-haskell">data Expr a where
    LitNumExpr :: Int -&gt; Expr Int
    AddExpr    :: Expr Int -&gt; Expr Int -&gt; Expr Int
    EqExpr     :: Expr a -&gt; Expr a -&gt; Expr Bool
    CondExpr   :: Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Pretty neat huh! There are many uses of GADTs, and we might see them in
the future. In the next section, we will show you how we can write
functions against algebraic data types and GADTs, including how we can
implement the <code>eval</code>{.haskell} function.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../types/sections/polymorphism.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../types/sections/pattern_matching.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../types/sections/polymorphism.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../types/sections/pattern_matching.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
