<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Exercises - Typed Functional Programming</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../about.html">About IT5100A</a></li><li class="chapter-item expanded affix "><li class="part-title">Typed Functional Programming</li><li class="chapter-item expanded "><a href="../../course_introduction/index.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../course_introduction/sections/course_admin.html"><strong aria-hidden="true">1.1.</strong> Course Administration</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/functional_programming.html"><strong aria-hidden="true">1.2.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/haskell.html"><strong aria-hidden="true">1.3.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/exercises.html"><strong aria-hidden="true">1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/sections/type_systems.html"><strong aria-hidden="true">2.1.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../../types/sections/polymorphism.html"><strong aria-hidden="true">2.2.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../../types/sections/algebraic_data_types.html"><strong aria-hidden="true">2.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="../../types/sections/pattern_matching.html"><strong aria-hidden="true">2.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="../../types/sections/exercises.html" class="active"><strong aria-hidden="true">2.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../typeclasses/index.html"><strong aria-hidden="true">3.</strong> Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../typeclasses/sections/ad-hoc-polymorphism.html"><strong aria-hidden="true">3.1.</strong> Ad-Hoc Polymorphism</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/typeclasses.html"><strong aria-hidden="true">3.2.</strong> Typeclasses</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/commonly-used-typeclasses.html"><strong aria-hidden="true">3.3.</strong> Commonly-Used Typeclasses</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/functional-dependencies.html"><strong aria-hidden="true">3.4.</strong> Functional Dependencies</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/exercises.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Railway Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Concurrent and Parallel Programming</div></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Solutions to Exercises</div></li><li class="chapter-item expanded "><a href="../../recap/index.html"><strong aria-hidden="true">8.</strong> Recap of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../recap/sections/recursion.html"><strong aria-hidden="true">8.1.</strong> Recursion</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> First-Class Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Lambda Calculus</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typed Functional Programming</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<p>::: exercise
[]{#q:whatarethetypes label="q:whatarethetypes"} Without using GHCI,
determine the types of the following expressions:</p>
<ol>
<li>
<p><code>(1 :: Int) + 2 * 3</code>{.haskell}</p>
</li>
<li>
<p><code>let x = 2 + 3 in show x</code>{.haskell}</p>
</li>
<li>
<p><code>if "ab" == "abc" then "a" else []</code>{.haskell}</p>
</li>
<li>
<p><code>(++ [])</code>{.haskell}</p>
</li>
<li>
<p><code>map (\(x :: Int) -&gt; x * 2)</code>{.haskell}</p>
</li>
<li>
<p><code>((\(x :: [Int]) -&gt; show x) . )</code>{.haskell}</p>
</li>
<li>
<p><code>( . (\(x :: [Int]) -&gt; show x))</code>{.haskell}</p>
</li>
<li>
<p><code>(,) . fst</code>{.haskell}</p>
</li>
<li>
<p><code>filter</code>{.haskell}
:::</p>
</li>
</ol>
<p>::: exercise
[]{#q:whatarethetypesoffunctions label="q:whatarethetypesoffunctions"}
Without the help of GHCI, describe the types of the functions that we
defined in <a href="#q:eqLast">[q:eqLast]</a>{reference-type="autoref"
reference="q:eqLast"},
<a href="#q:palindrome">[q:palindrome]</a>{reference-type="autoref"
reference="q:palindrome"},
<a href="#q:burgerPrice">[q:burgerPrice]</a>{reference-type="autoref"
reference="q:burgerPrice"} and
<a href="#q:slice">[q:slice]</a>{reference-type="autoref" reference="q:slice"}
(<code>eqLast</code>, <code>isPalindrome</code>, <code>burgerPrice</code>, <code>@:</code>).
:::</p>
<p>::: exercise
[]{#q:burgerPricePatternMatching label="q:burgerPricePatternMatching"}
Recall the following solution to
<a href="#q:burgerPrice">[q:burgerPrice]</a>{reference-type="autoref"
reference="q:burgerPrice"}:</p>
<pre><code class="language-haskell">burgerPrice burger 
  | null burger = 0
  | otherwise   =
      let first = ingredientPrice (head burger)
          rest  = burgerPrice (tail burger)
      in  first + rest
  where ingredientPrice i
          | i == 'B' = 0.5
          | i == 'C' = 0.8
          | i == 'P' = 1.5
          | i == 'V' = 0.7
          | i == 'O' = 0.4
          | i == 'M' = 0.9
</code></pre>
<p>There are several problems with this. First of all, writing
<code>burgerPrice</code>{.haskell} with guards does not allow us to rely on
compiler exhaustiveness checks, and may give us some additional warnings
about <code>head</code> and <code>tail</code> being <em>partial</em>, despite their use being
perfectly fine. The second problem is that we have allowed our burger to
be any string, even though we should only allow strings that are
composed of valid ingredientsthe compiler will not reject invocations of
<code>burgerPrice</code>{.haskell} with bogus arguments like <code>"AbcDEF"</code>{.haskell}.<br />
Define a new type that represents valid burgers, and re-define
<code>burgerPrice</code>{.haskell} against that type using pattern matching.
Additionally, provide a type declaration for this function. Note that
you may use the <code>Rational</code>{.haskell} type to describe rational numbers
like <code>0.8</code>{.haskell} etc, instead of <code>Double</code>{.haskell} which may have
precision issues. You might see that the output of your
<code>burgerPrice</code>{.haskell} function is of the form <code>x % y</code> which means
$x/y$.
:::</p>
<p>::: exercise
[]{#q:dropConsecutiveDuplicates label="q:dropConsecutiveDuplicates"}
Define a function <code>dropConsecutiveDuplicates</code>{.haskell} that receives a
list of any type that is amenable to equality comparisons and removes
all the consecutive duplicates of the list. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; dropConsecutiveDuplicates []
[]
ghci&gt; dropConsecutiveDuplicates [1, 2, 2, 3, 3, 3, 3, 4, 4]
[1, 2, 3, 4]
ghci&gt; dropConsecutiveDuplicates "aabcccddeee"
"abcde"
</code></pre>
<p>For this function to be polymorphic, you will need to add a constraint
<code>Eq a =&gt;</code>{.haskell} at the beginning of the function's type signature
just like we did for the <code>EqExpr</code>{.haskell} constructor of our
<code>Expr a</code>{.haskell} GADT.
:::</p>
<p>::: exercise
[]{#q:listzipper label="q:listzipper"} Suppose we have a list
<code>[1,2,3,4,5]</code>{.haskell}. Since lists in Haskell are singly-linked lists,
and not to mention that Haskell lists are immutable, changing the values
at the tail end of the list (e.g. <code>4</code> or <code>5</code>) can be inefficient! Not
only that, if we want to then change something near the element we've
just changed, we have to traverse all the way down to that element from
the head all over again!<br />
Instead, what we can use is a <em>zipper</em>, which allows us to focus on a
part of a data structure so that accessing those elements and walking
around it is efficient. The idea is to write functions that let us walk
down the list, do our changes, and walk back up to recover the full
list. For this, we shall define some functions:</p>
<ol>
<li>
<p><code>mkZipper</code> which receives a list and makes a zipper</p>
</li>
<li>
<p><code>r</code> which walks to the right of the list zipper</p>
</li>
<li>
<p><code>l</code> which walks to the left of the list zipper</p>
</li>
<li>
<p><code>setElement x</code> which changes the element at the current position of
the zipper to <code>x</code>.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; x = mkZipper [1,2,3,4,5]
ghci&gt; x
([], [1,2,3,4,5])
ghci&gt; y = r $ r $ r $ r x
ghci&gt; y = ([4,3,2,1], [5])
ghci&gt; z = setElement (-1) y
ghci&gt; z
([4,3,2,1], [-1])
ghci&gt; w = setElement (-2) $ l z
ghci&gt; w 
([3,2,1], [-2,-1])
ghci&gt; l $ l $ l w
([], [1,2,3,-2,-1])
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:bst label="q:bst"} Let us create a data structure that represents
sorted sets. These are collections that contain unique elements and are
sorted in ascending order. A natural data structure that can represent
such sets is the Binary Search Tree (BST) abstract data type (ADT).<br />
Create a new type <code>SortedSet</code>{.haskell}. Then define the following
functions:</p>
<ol>
<li>
<p>The function <code>@+</code> that receives a sorted set and an element, and
returns the sorted set with the element added (unless it is already
in the sorted set).</p>
</li>
<li>
<p>The function <code>setToList</code> that receives a sorted set and returns it
as a list (in sorted order)</p>
</li>
<li>
<p>The function <code>sortedSet</code> that receives a list of elements and puts
them all in a sorted set.</p>
</li>
<li>
<p>The function <code>in’</code> which determines if an element is in the sorted
set.</p>
</li>
</ol>
<p>Note that if any of your functions perform any comparison operations
(<code>&gt;</code> etc.), you will need to include the <code>Ord a =&gt;</code>{.haskell} constraint
over the elements of the sorted set or list at the beginning of the type
signature of those functions. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; setToList $ (sortedSet []) @+ 1
[1]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2
[1,2]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2 @+ 0
[0,1,2]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2 @+ 0 @+ 2
[0,1,2]
ghci&gt; setToList $ sortedSet [7,3,2,5,5,2,1,7,6,3,4,2,4,4,7,1,2,3]
[1,2,3,4,5,6,7]
ghci&gt; setToList $ sortedSet "aaabccccbbbbbaaaaab"
"abc"
ghci&gt; 1 `in'` (sortedSet [1, 2, 3])
True
ghci&gt; 1 `in'` (sortedSet [4])
False
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:shapesexpressionproblem label="q:shapesexpressionproblem"} In this
question, we are going to demonstrate an example of the <em>expression
problem</em> by writing FP-style data structures and functions, and OO-style
classes, to represent the same problem. We shall use Haskell for the FP
formulation, and Python for the OOP formulation. Ensure that your Python
code is well-typed by checking it with pyright.<br />
The problem is as such. We want to represent various shapes, and the
facility to calculate the area of a shape. To start, we shall define two
shapes: circles and rectangles. Circles have a radius and rectangles
have a width and height. Assume these fields are all <code>Double</code>{.haskell}s
in Haskell, and <code>float</code>{.python}s in Python.<br />
Haskell: define a type <code>Shape</code>{.haskell} that represents these two
shapes, and a function <code>area</code>{.haskell} that computes the area of any
shape.</p>
<p>Python: define a (abstract) class <code>Shape</code> that comes with a (abstract)
method <code>area</code> which gives its area. Then, define two subclasses of
<code>Shape</code> that represents circles and rectangles, and define their
constructors and methods appropriately.<br />
The <em>expression problem</em> essentially describes the phenomenon that it
can either be easy to add new representations of a type, easy to add new
functions over types, but not both. To observe this, we are going to
extend the code we've written in the following ways:</p>
<ol>
<li>
<p>Create a new shape called <code>Triangle</code> that has a width and height.</p>
</li>
<li>
<p>Create a new function/method <code>scale</code> that scales the shape (by
length) by some factor $n$.</p>
</li>
</ol>
<p>Proceed to do so in both formulations. As you are doing so, think about
whether each extension is easy to do if the code we've previously
written cannot be amended, e.g. if it is in a pre-compiled library which
you do not have the source code of.
:::</p>
<p>::: exercise
[]{#q:exprgadt label="q:exprgadt"} Let us extend our Expressions GADT.
Define the following expressions:</p>
<ol>
<li>
<p><code>LitBoolExpr</code>{.haskell} holds a boolean value (<code>True</code>{.haskell} or
<code>False</code>{.haskell})</p>
</li>
<li>
<p><code>AndExpr</code>{.haskell} has two boolean expressions and evaluates to
their conjunction</p>
</li>
<li>
<p><code>OrExpr</code>{.haskell} has two boolean expressions and evaluates to
their disjunction</p>
</li>
<li>
<p><code>FuncExpr</code>{.haskell} holds a function</p>
</li>
<li>
<p><code>FuncCall</code>{.haskell} receives a function and an argument, and
evaluates to the function application to that argument</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; n = LitNumExpr
ghci&gt; b = LitBoolExpr
ghci&gt; a = AndExpr
ghci&gt; o = OrExpr
ghci&gt; f = FuncExpr
ghci&gt; c = FuncCall
ghci&gt; eval (b True `a` b False)
False
ghci&gt; eval (b True `a` b True)
True
ghci&gt; eval (b True `o` b False)
True
ghci&gt; eval (b False `o` b False)
False
ghci&gt; eval $ f (\x -&gt; x + 1) `c` n 1
2
ghci&gt; eval $ c (c (f (\x y -&gt; x + y)) (n 1)) (n 2)
3
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:bankaccounts label="q:bankaccounts"} In this question we shall
simulate a simple banking system consisting of bank accounts. We shall
write all this code in Python, but in a typed functional programming
style. That means:</p>
<ol>
<li>
<p>No loops</p>
</li>
<li>
<p>No mutable data structures or variables</p>
</li>
<li>
<p>Pure functions only</p>
</li>
<li>
<p>Annotate all variables, functions etc. with types</p>
</li>
<li>
<p>Program must be type-safe</p>
</li>
</ol>
<p>There are several kinds of bank accounts that behave differently on
certain operations. We aim to build a banking system that receives such
operations that act on these accounts. We shall build this system
incrementally (as we should!), so you may want to follow the parts in
order, and check your solutions after completing each part.<br />
<strong>[BANK ACCOUNTS]{.sans-serif}</strong><br />
<strong>[Bank Account ADT]{.sans-serif}</strong><br />
First, create an Algebraic Data Type (ADT) called <code>BankAccount</code>{.python}
that represents two kinds of bank accounts:</p>
<ol>
<li>
<p>Normal bank accounts</p>
</li>
<li>
<p>Minimal bank accounts</p>
</li>
</ol>
<p>Both kinds of accounts have an ID, account balance and an interest
rate.<br />
Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; NormalAccount("a", 1000, 0.01)
NormalAccount(account_id='a', balance=1000, interest_rate=0.01)
&gt;&gt;&gt; MinimalAccount("a", 1000, 0.01)
MinimalAccount(account_id='a', balance=1000, interest_rate=0.01)
</code></pre>
<p><strong>[Basic Features]{.sans-serif}</strong><br />
Now let us write some simple features of these bank accounts. There are
two features we shall explore:</p>
<ol>
<li>
<p>Depositing money into a bank account. Since we are writing code in a
purely functional style, our function does not mutate the state of
the bank account. Instead, it returns a new state of the account
with the money deposited. Assume that the deposit amount is
non-negative.</p>
</li>
<li>
<p>Deducting money from a bank account. Just like before, we are not
mutating the state of the bank account, and instead will be
returning the new state of the bank account. However, the deduction
might not happen since the account might have insufficient funds. As
such, this function returns a tuple containing a boolean flag
describing whether the deduction succeeded, and the new state of the
bank account after the deduction (if the deduction does not occur,
the state of the bank account remains unchanged).</p>
</li>
</ol>
<p><em>Note</em>: The type of a tuple with two elements of types <code>A</code>{.python} and
<code>B</code>{.python} is <code>tuple[A, B]</code>{.python}. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = NormalAccount('abc', 1000, 0.01)
&gt;&gt;&gt; y = MinimalAccount('bcd', 2000, 0.02)
&gt;&gt;&gt; deposit(1000, x)
NormalAccount(account_id='abc', balance=2000, interest_rate=0.01)
&gt;&gt;&gt; deduct(1000, x)
(True, NormalAccount(account_id='abc', balance=0, interest_rate=0.01))
&gt;&gt;&gt; deduct(2001, y)
(False, MinimalAccount(account_id='bcd', balance=2000, 
    interest_rate=0.02))
</code></pre>
<p><strong>[Advanced Features]{.sans-serif}</strong><br />
Now we shall implement some more advanced features:</p>
<ol>
<li>
<p>Compounding interest. Given a bank account with balance $b$ and
interest rate $i$, the new balance after compounding will be
$b(1+i)$. For minimal accounts, an administrative fee of $20 will
be deducted if its balance is strictly below $1000. This fee
deduction happens <strong>before</strong> compounding. Importantly, bank balances
never go below $0, so e.g. if a minimal account has $10, after
compounding, its balance will be $0.</p>
</li>
<li>
<p>Bank transfers. This function receives a transaction amount and two
bank accounts: (1) the credit account (the bank account where funds
will come from) and (2) the debit account (bank account where funds
will be transferred to). The result of the transfer is a triplet
(tuple of three elements) containing a boolean describing the
success of the transaction, and the new states of the credit and
debit accounts. The transaction does not happen if the credit
account has insufficient funds.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = NormalAccount('abc', 1000, 0.01)
&gt;&gt;&gt; y = MinimalAccount('bcd', 2000, 0.02)
&gt;&gt;&gt; z = MinimalAccount('def', 999, 0.01)
&gt;&gt;&gt; w = MinimalAccount('xyz', 19, 0.01)
&gt;&gt;&gt; compound(x)
NormalAccount(account_id='abc', balance=1010, interest_rate=0.01)
&gt;&gt;&gt; compound(compound(x))
NormalAccount(account_id='abc', balance=1020.1, interest_rate=0.01)
&gt;&gt;&gt; compound(y)
MinimalAccount(account_id='bcd', balance=2040, interest_rate=0.02)
&gt;&gt;&gt; compound(z)
MinimalAccount(account_id='def', balance=988.79, interest_rate=0.01)
&gt;&gt;&gt; compound(w)
MinimalAccount(account_id='xyz', balance=0, interest_rate=0.01)
&gt;&gt;&gt; transfer(2000, x, y)
(False, NormalAccount(account_id='abc', balance=1000,
    interest_rate=0.01), MinimalAccount(account_id='bcd', 
    balance=2000, interest_rate=0.02))
&gt;&gt;&gt; transfer(2000, y, x)
(True, MinimalAccount(account_id='bcd', balance=0,
    interest_rate=0.02), NormalAccount(account_id='abc', 
    balance=3000, interest_rate=0.01))
</code></pre>
<p><strong>[OPERATING ON BANK ACCOUNTS]{.sans-serif}</strong><br />
Let us suppose that we have a dictionary whose keys are bank account IDs
and values are their corresponding bank accounts. This dictionary
simulates a 'database' of bank accounts which we can easily lookup by
bank account ID:</p>
<pre><code class="language-python">&gt;&gt;&gt; d: dict[str, BankAccount] = {
  'abc': NormalAccount('abc', 1000, 0.01)
  'bcd': MinimalAccount('bcd', 2000, 0.02)
}
</code></pre>
<p>Now we are going to process a whole bunch of operations on this
'database'.<br />
<strong>[Operations ADT]{.sans-serif}</strong><br />
The first step in processing a bunch of operations on the accounts in
our database is to create a data structure that represents the desired
operation in the first place. For this, create an algebraic data type
<code>Op</code>{.python} comprised of two classes:</p>
<ol>
<li>
<p><code>Transfer</code>{.python}: has a transfer amount, and credit bank account
ID, and a debit bank account ID. This represents the operation where
we are transferring the transfer amount from the credit account to
the debit account.</p>
</li>
<li>
<p><code>Compound</code>{.python}. This just tells the processor to compound all
the bank accounts in the map. There should be no attributes in this
class.</p>
</li>
</ol>
<p><strong>[Processing One Operation]{.sans-serif}</strong><br />
Write a function <code>process_one</code>{.python} that receives an operation and a
dictionary of bank accounts (keys are bank account IDs, and values are
the corresponding bank accounts), and performs the operation on the bank
accounts in the dictionary. As a result, the function returns a pair
containing:</p>
<ol>
<li>
<p>A boolean value to describe whether the operation has succeeded</p>
</li>
<li>
<p>The resulting dictionary containing the updated bank accounts after
the operations have been processed.</p>
</li>
</ol>
<p>Take note that there are several ways in which a <code>Transfer</code>{.python}
operation may fail:</p>
<ol>
<li>
<p>If either account IDs do not exist in the dictionary, the transfer
will fail</p>
</li>
<li>
<p>If the credit account does not have sufficient funds, the transfer
will fail</p>
</li>
<li>
<p>Otherwise, the transfer should proceed as per normal</p>
</li>
</ol>
<p>Keep in mind that you should not mutate any data structure used. Example
runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')
&gt;&gt;&gt; process_one(c, mp)
(True, {'alice': NormalAccount(account_id='alice', balance=1100.0, 
  interest_rate=0.1), 'bob': MinimalAccount(account_id='bob', 
  balance=1076.9, interest_rate=0.1)})
&gt;&gt;&gt; process_one(t1, mp)
(True, {'alice': NormalAccount(account_id='alice', balance=0, 
  interest_rate=0.1), 'bob': MinimalAccount(account_id='bob', 
  balance=1999, interest_rate=0.1)})
&gt;&gt;&gt; process_one(t2, mp)
(False, {'alice': NormalAccount(account_id='alice', balance=1000, 
  interest_rate=0.1), 'bob': MinimalAccount(account_id='bob', 
  balance=999, interest_rate=0.1)})
</code></pre>
<p><strong>[Processing All Operations]{.sans-serif}</strong><br />
Now let us finally define a function <code>process_all</code>{.python} that
receives a list of operations and a dictionary of bank accounts (the
keys are bank account IDs, and the values are bank accounts). As a
result, the function returns a pair containing:</p>
<ol>
<li>
<p>A list of booleans where the $i^\text{th}$ boolean value describes
whether the $i^\text{th}$ operation has succeeded</p>
</li>
<li>
<p>The resulting dictionary containing the updated bank accounts after
all the operations have been processed.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')
&gt;&gt;&gt; process_all([t2, c, t2, t1], mp)
([False, True, True, True], {'alice': NormalAccount(account_id='alice', 
  balance=1100.0, interest_rate=0.1), 'bob': 
  MinimalAccount(account_id='bob', balance=1076.9, interest_rate=0.1)})
</code></pre>
<p><strong>[Polymorphic Processing]{.sans-serif}</strong> If you were careful with your
implementation of <code>process_all</code>{.python}, you might notice that if we
had parameterized all invocations of <code>process_one</code>{.python}, then
nothing about the implementation of <code>process_all</code>{.python} depends on
the types like <code>Op</code>{.python}, <code>dict[str, BankAccount]</code>{.python} or
<code>bool</code>{.python}. Thus we should make this function polymorphic!<br />
Our goal is to write a polymorphic function <code>process</code>{.python} that can
process any list over a state and produce the resulting list and an
updated state after performing stateful processing over the list. It
should be defined such that <code>process(process_one, ops, mp)</code>{.python}
should be the exact same as <code>process_all(ops, mp)</code>{.python} as you have
defined earlier:</p>
<pre><code class="language-python">&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')
&gt;&gt;&gt; process(process_one, [t2, c, t2, t1], mp)
([False, True, True, True], {'alice': NormalAccount(account_id='alice', 
  balance=1100.0, interest_rate=0.1), 'bob': 
  MinimalAccount(account_id='bob', balance=1076.9, interest_rate=0.1)})
</code></pre>
<p>Furthermore, the best part of this polymorphic function is that it can
be used in any situation where we need this stateful accumulation over a
list. For example, we can define a function that tests if a number $n$
is co-prime to a list of other numbers, and if it is indeed co-prime to
all of the input numbers, add $n$ to the state list:</p>
<pre><code class="language-python">&gt;&gt;&gt; def gather_primes(n: int, ls: list[int]) -&gt; tuple[bool, list[int]]:
...     if any(n % i == 0 for i in ls):
...         return (False, ls)
...     return (True, ls + [n])
</code></pre>
<p>Example uses of this follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; gather_primes(2, [])
(True, [2])
&gt;&gt;&gt; gather_primes(3, [2])
(True, [2, 3])
&gt;&gt;&gt; gather_primes(4, [2, 3])
(False, [2, 3])
</code></pre>
<p>This way, we can use <code>process</code>{.python} to generate prime numbers and do
primality testing!</p>
<pre><code class="language-python">&gt;&gt;&gt; def primes(n: int) -&gt; tuple[list[bool], list[n]]:
...     return process(gather_primes, list(range(2, n)), [])
... 
&gt;&gt;&gt; primes(10)
([True, True, False, True, False, True, False, False], [2, 3, 5, 7])
&gt;&gt;&gt; primes(30)
([True, True, False, True, False, True, False, False, False, # 2 to 10
  True, False, True, False, False, False, True, False, True, # 11 to 20
  False, False, False, True, False, False, False, False, False, True], 
  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29])
</code></pre>
<p>Proceed to define the <code>process</code>{.python} function. Example runs are as
above.<br />
<em>Note</em>: The type of a function that receives parameters <code>A</code>, <code>B</code> and <code>C</code>
and returns <code>D</code> is <code>Callable[[A, B, C], D]</code>{.python}. You will need to
import <code>Callable</code> from <code>typing</code>.
:::</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../types/sections/pattern_matching.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../typeclasses/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../types/sections/pattern_matching.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../typeclasses/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
