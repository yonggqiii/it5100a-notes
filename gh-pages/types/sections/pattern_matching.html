<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pattern Matching - Typed Functional Programming</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../../about.html">About IT5100A</a></li><li class="chapter-item expanded affix "><li class="part-title">Typed Functional Programming</li><li class="chapter-item expanded "><a href="../../course_introduction/index.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../course_introduction/sections/course_admin.html"><strong aria-hidden="true">1.1.</strong> Course Administration</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/functional_programming.html"><strong aria-hidden="true">1.2.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/haskell.html"><strong aria-hidden="true">1.3.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="../../course_introduction/sections/exercises.html"><strong aria-hidden="true">1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/sections/type_systems.html"><strong aria-hidden="true">2.1.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="../../types/sections/polymorphism.html"><strong aria-hidden="true">2.2.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../../types/sections/algebraic_data_types.html"><strong aria-hidden="true">2.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="../../types/sections/pattern_matching.html" class="active"><strong aria-hidden="true">2.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="../../types/sections/exercises.html"><strong aria-hidden="true">2.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="../../typeclasses/index.html"><strong aria-hidden="true">3.</strong> Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../typeclasses/sections/ad-hoc-polymorphism.html"><strong aria-hidden="true">3.1.</strong> Ad-Hoc Polymorphism</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/typeclasses.html"><strong aria-hidden="true">3.2.</strong> Typeclasses</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/commonly-used-typeclasses.html"><strong aria-hidden="true">3.3.</strong> Commonly-Used Typeclasses</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/functional-dependencies.html"><strong aria-hidden="true">3.4.</strong> Functional Dependencies</a></li><li class="chapter-item expanded "><a href="../../typeclasses/sections/exercises.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Railway Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Concurrent and Parallel Programming</div></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Solutions to Exercises</div></li><li class="chapter-item expanded "><a href="../../recap/index.html"><strong aria-hidden="true">8.</strong> Recap of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../recap/sections/recursion.html"><strong aria-hidden="true">8.1.</strong> Recursion</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> First-Class Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Lambda Calculus</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typed Functional Programming</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>We have seen how we can write constructors for algebraic data types, and
even use record syntax to create functions for accessing fields.
However, one natural question would then be to ask, how do we write
functions that access these fields, if we do not use record syntax? For
example, if we defined a fraction type normally, how do we obtain a
fraction's numerator and denominator?</p>
<p>The answer to this question is to use <em>pattern matching</em>. It is a
control structure just like if-else statements, except that we would
execute different branches based on the value/structure of the data,
instead of a general condition.</p>
<p>::: example
[]{#eg:factorialpatternmatching label="eg:factorialpatternmatching"} Let
us define the factorial function using pattern matching instead of
conditional expressions or guards. We use <code>case</code>{.haskell} expressions
to do so:</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac n = case n of -- match n against these patterns:
    0 -&gt; 1
    x -&gt; x * fac (x - 1) -- any other Int
</code></pre>
<p>:::</p>
<p>The nice thing about pattern matching is that we can also match against
the <em>structure</em> of data, i.e. to match against constructors:</p>
<p>::: example
[]{#eg:fstsndpatternmatching label="eg:fstsndpatternmatching"} Let us
redefine the <code>fst</code>{.haskell} and <code>snd</code>{.haskell} functions which project
a tuple into its component values:</p>
<pre><code class="language-haskell">fst' :: (a, b) -&gt; a
fst' p = case p of 
    (x, _) -&gt; x

snd' :: (a, b) -&gt; b
snd' p = case p of
    (_, y) -&gt; y
</code></pre>
<p>:::</p>
<p>::: example
[]{#eg:fractionpatternmatching label="eg:fractionpatternmatching"} Let
us write accessor functions to access the numerator and denominator of a
fraction.</p>
<pre><code class="language-haskell">data Fraction = F Int Int
numerator, denominator :: Fraction -&gt; Int
numerator f = case f of
    F x _ -&gt; x
denominator f = case f of 
    F _ x -&gt; x
</code></pre>
<p>:::</p>
<p>One nice thing about Haskell is that because we perform pattern matching
over the arguments of functions so frequently, we can actually bring the
patterns up to the definitions of the functions themselves.</p>
<p>::: example
Let us define all of the functions we've just written using
<code>case</code>{.haskell} expressions in
<a href="#eg:factorialpatternmatching">[eg:factorialpatternmatching]</a>{reference-type="autoref"
reference="eg:factorialpatternmatching"},
<a href="#eg:fstsndpatternmatching">[eg:fstsndpatternmatching]</a>{reference-type="autoref"
reference="eg:fstsndpatternmatching"} and
<a href="#eg:fractionpatternmatching">[eg:fractionpatternmatching]</a>{reference-type="autoref"
reference="eg:fractionpatternmatching"} into more idiomatic uses of
pattern matching.</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac 0 = 1
fac n = n * fac (n - 1)
 
fst' :: (a, b) -&gt; a
snd' :: (a, b) -&gt; b
fst' (x, _) = x
snd' (_, y) = y
 
data Fraction = F Int Int
numerator, denominator :: Fraction -&gt; Int

numerator (F x _) = x
denominator (F _ y) = y
</code></pre>
<p>:::</p>
<p>We also know that the list type is a singly linked list, which is
roughly defined as such:</p>
<pre><code class="language-haskell">data [a] = [] | a : [a]
</code></pre>
<p>We can use this fact to pattern match against lists!</p>
<p>::: example
The sum of a list of integers is 0 if the list is empty, otherwise its
the head of the list plus the sum of the tail of the list.</p>
<pre><code class="language-haskell">sum' :: [Int] -&gt; Int
sum' [] = 0
sum' (x : xs) = x + sum' xs
</code></pre>
<p>:::</p>
<p>::: example
The length of a list is 0 if the list is empty, otherwise it is 1 more
than the length of its tail.</p>
<pre><code class="language-haskell">len :: [a] -&gt; Int
len [] = 0
len (_ : xs) = 1 + len xs
</code></pre>
<p>:::</p>
<p>Really neat! Defining functions operating on algebraic data types
(including recursive data types) are very convenient thanks to pattern
matching! What's more, patterns can actually be used virtually anywhere
on the left side of any binding:</p>
<p>::: example
Let us use pattern matching in a <code>let</code>{.haskell} binding:</p>
<pre><code class="language-haskell">len :: [a] -&gt; Int
len [] = 0
len ls = 
    let (_ : xs) = ls
    in  1 + len xs
</code></pre>
<p>:::</p>
<p>Perhaps the most powerful feature of pattern matching is that the
compiler will warn you if your pattern matches are non-exhaustive, i.e.
if you do not match against all possible constructors of the type! Let
us define a function that only matches against the empty list
constructor.</p>
<pre><code class="language-haskell">-- Main.hs
emp :: [a] -&gt; [a]
emp [] = []
</code></pre>
<p>Compile it to see the warning!</p>
<pre><code>ghc Main.hs
Main.hs:3:1: warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘emp’: Patterns of type ‘[a]’ not matched: (_:_)
  |
3 | emp [] = []
  | ^^^^^^^^^^^
</code></pre>
<p>This is one reason why pattern matching is so powerful; compilers can
check if you have covered all possible patterns of a given type. This is
unlike usual if-else statements where it is much less straightforward to
check if you have covered all possible branches, especially if you omit
<code>else</code>{.python} statements.</p>
<p>One important point to highlight here is that pattern matching is done
top-down. Thus, using pattern-matching is kind of similar to if-else
statements in that regard: your most specific condition should be
defined first, then followed by more general or catch-all patterns.</p>
<p>::: example
The following factorial function is poorly defined, because the first
pattern match will match all possible integers, thereby causing the
function to never terminate:</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac n = n * fac (n - 1)
fac 0 = 1 -- redundant as pattern above matches all
          -- possible integers
</code></pre>
<p>:::</p>
<p>With pattern matching, let us know fulfil our earlier promise of
defining the <code>eval</code>{.haskell} function for the <code>Expr</code>{.haskell} GADT in
<a href="#sec:gadt">[sec:gadt]</a>{reference-type="autoref"
reference="sec:gadt"}.</p>
<p>In our Python formulation, we know that <code>eval</code>{.haskell} should have the
type signature <code>Expr a -&gt; a</code>{.haskell}. Let us then define how each
expression should be evaluated with pattern matching.</p>
<pre><code class="language-haskell">eval :: Expr a -&gt; a
eval (LitNumExpr n)   = n
eval (AddExpr a b)    = eval a + eval b
eval (EqExpr a b)     = eval a == eval b
eval (CondExpr a b c) = if eval a then eval b else eval c
</code></pre>
<p>This is highly straightforward! However, you might find that when this
program is compiled, the compiler throws an error on the use of the
<code>(==)</code>{.haskell} function:</p>
<pre><code>ghc Main.hs
Main.hs:13:28: error:
    • Could not deduce (Eq a1) arising from a use of ‘==’
      from the context: a ~ Bool
        bound by a pattern with constructor:
                   EqExpr :: forall a. Expr a -&gt; Expr a -&gt; Expr Bool,
                 in an equation for ‘eval’
        at app/Main.hs:13:7-16
      Possible fix:
        add (Eq a1) to the context of the data constructor ‘EqExpr’
    • In the expression: eval a == eval b
      In an equation for ‘eval’: eval (EqExpr a b) = eval a == eval b
   |
13 | eval (EqExpr a b) = eval a == eval b
   |       
</code></pre>
<p>The reason for this is Haskell is unable to determine that the type
parameter <code>a</code> is amenable to equality comparisons. Solving this requires
an understanding of <em>typeclasses</em>, which we will explore in the next
lecture. For now, just include an <code>Eq a =&gt;</code>{.haskell} constraint in our
GADT declaration.</p>
<p>You might also get a warning about pattern matching on GADTs being
fragile; that is because GADTs are actually a Haskell language
extension. As such, enable this extension when compiling this program,
or add a <code>LANGUAGE</code> <em>pragma</em> at the top of the file.</p>
<pre><code class="language-haskell">{-# LANGUAGE GADTs #-}
data Expr a where
  LitNumExpr ::         Int -&gt; Expr Int
  AddExpr    ::         Expr Int -&gt; Expr Int -&gt; Expr Int
  EqExpr     :: Eq a =&gt; Expr a -&gt; Expr a -&gt; Expr Bool
  CondExpr   ::         Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Our program should compile now!</p>
<h3 id="pattern-matching-in-python"><a class="header" href="#pattern-matching-in-python">Pattern Matching in Python</a></h3>
<p>Python also has pattern matching with <code>match</code>{.python} statements with
<code>case</code>{.python} clauses! It looks very similar to how we would write
<code>case</code>{.haskell} expressions in Haskell.</p>
<pre><code class="language-python">def factorial(n: int) -&gt; int:
  match n:
    case 0: return 1
    case n: return n * factorial(n - 1)
</code></pre>
<p>We can also match on the structure of types by unpacking. For example,
defining a function that sums over a list of integers:</p>
<pre><code class="language-python">def sum(ls: list[int]) -&gt; int:
  match ls:
    case []: return 0
    case (x, *xs): return x + sum(xs)
    case _: raise TypeError()
</code></pre>
<p>Alternatively, performing structural pattern matching over a so called
algebraic data type:</p>
<pre><code class="language-python">@dataclass
class Tree[a]: pass
 
@dataclass
class Node[a](Tree[a]):
    val: a
    left: Tree[a]
    right: Tree[a]
 
@dataclass
class Leaf[a](Tree[a]):
    val: a

def preorder[a](tree: Tree[a]) -&gt; list[a]:
    match tree:
        case Node(v, l, r): return [v] + preorder(l) + preorder(r)
        case Leaf(v): return [v]
        case _: raise TypeError
</code></pre>
<p>However, notice that in the <code>sum</code> and <code>preorder</code> function definitions,
the last clause catches all patterns and raises an error. This is needed
to side-step the exhaustiveness checker. This is because we are using
classes to model algebraic data types, and Python does not always know
all the possible structures of a given class. In the case of <code>sum</code>,
Python's type system does not contain information about the length of a
list, so it has no way of determining exhaustiveness. In the case of
<code>preorder</code>, the reason omitting the last case gives a non-exhaustiveness
error is because we did not match against other possible subclasses of
<code>Tree</code>.</p>
<p>If we had formulated our <code>Tree</code> type using unions, pyright can determine
the exhaustiveness of our patterns:</p>
<pre><code class="language-python">type Tree[a] = Node[a] | Leaf[a]

@dataclass
class Node[a]:
    val: a
    left: Tree[a]
    right: Tree[a]

@dataclass
class Leaf[a]:
    val: a

def preorder[a](tree: Tree[a]) -&gt; list[a]:
    match tree:
        case Node(v, l, r): return [v] + preorder(l) + preorder(r)
        case Leaf(v): return [v]
        # no need for further cases
</code></pre>
<p>However, this may not always be ideal, especially if we are to define
GADTs in Python. Until Algebraic Data Types or ways to annotate the
exhaustivity of subclasses (such as defining a <em>sealed</em> class) are
formally introduced, exhaustive pattern matching checks are going to be
difficult to do. When doing pattern matching in Python, ensure that all
possible cases are handled before doing a catch-all clause in your
<code>match</code>{.python} statement.</p>
<p>All-in-all, we have just introduced a new control structure known as
pattern matching. When should we use this control structure? The general
rule of thumb is as follows:</p>
<ul>
<li>
<p>If you are doing different things based on the value and/or
structure of data, use pattern matching. You can tell this is the
case if you are doing equality and <code>isinstance</code>{.python} checks in
your conditional statements in Python.</p>
</li>
<li>
<p>Otherwise, you are likely going with the more general case of doing
different things based on the satisfiability of a condition, in
which case, rely on if-else statements, or in Haskell, conditional
expressions and/or guards.</p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Python doesn't have arrow types. The actual type of the function
is <code>Callable[[int], int]</code>{.python}.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>These are the three axes that form the <em>lambda cube</em>, with the
simply typed lambda calculus only having terms that depend on terms,
and the Calculus of Constructions having types and terms depending
on types and terms.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>The word <em>polymorphism</em> can be broken down into <em>poly</em> (many) and
<em>morphism</em> (shape). The word is not just used in Computer Science,
but in other areas like biology and pharmacology. Within Computer
Science itself there are several kinds of polymorphism, and we shall
investigate the most common ones in this lecture and in later
lectures too. Finally, polymorphism in Computer Science is really
about things taking on different forms, but I suspect that our
description of parametric polymorphism gives a pretty good picture
of what it entails.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>The code snippet requires Python 3.12.</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../types/sections/algebraic_data_types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../types/sections/exercises.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../types/sections/algebraic_data_types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../types/sections/exercises.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
