<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Typed Functional Programming</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About IT5100A</a></li><li class="chapter-item expanded affix "><li class="part-title">Typed Functional Programming</li><li class="chapter-item expanded "><a href="course_introduction/index.html"><strong aria-hidden="true">1.</strong> Course Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course_introduction/sections/course_admin.html"><strong aria-hidden="true">1.1.</strong> Course Administration</a></li><li class="chapter-item expanded "><a href="course_introduction/sections/functional_programming.html"><strong aria-hidden="true">1.2.</strong> Functional Programming</a></li><li class="chapter-item expanded "><a href="course_introduction/sections/haskell.html"><strong aria-hidden="true">1.3.</strong> Haskell</a></li><li class="chapter-item expanded "><a href="course_introduction/sections/exercises.html"><strong aria-hidden="true">1.4.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="types/index.html"><strong aria-hidden="true">2.</strong> Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="types/sections/type_systems.html"><strong aria-hidden="true">2.1.</strong> Type Systems</a></li><li class="chapter-item expanded "><a href="types/sections/polymorphism.html"><strong aria-hidden="true">2.2.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="types/sections/algebraic_data_types.html"><strong aria-hidden="true">2.3.</strong> Algebraic Data Types</a></li><li class="chapter-item expanded "><a href="types/sections/pattern_matching.html"><strong aria-hidden="true">2.4.</strong> Pattern Matching</a></li><li class="chapter-item expanded "><a href="types/sections/exercises.html"><strong aria-hidden="true">2.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><a href="typeclasses/index.html"><strong aria-hidden="true">3.</strong> Typeclasses</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="typeclasses/sections/ad-hoc-polymorphism.html"><strong aria-hidden="true">3.1.</strong> Ad-Hoc Polymorphism</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/typeclasses.html"><strong aria-hidden="true">3.2.</strong> Typeclasses</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/commonly-used-typeclasses.html"><strong aria-hidden="true">3.3.</strong> Commonly-Used Typeclasses</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/functional-dependencies.html"><strong aria-hidden="true">3.4.</strong> Functional Dependencies</a></li><li class="chapter-item expanded "><a href="typeclasses/sections/exercises.html"><strong aria-hidden="true">3.5.</strong> Exercises</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Railway Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Concurrent and Parallel Programming</div></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Solutions to Exercises</div></li><li class="chapter-item expanded "><a href="recap/index.html"><strong aria-hidden="true">8.</strong> Recap of Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="recap/sections/recursion.html"><strong aria-hidden="true">8.1.</strong> Recursion</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> First-Class Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Lambda Calculus</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Typed Functional Programming</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="it5100aindustry-readiness-typed-functional-programming"><a class="header" href="#it5100aindustry-readiness-typed-functional-programming">IT5100A—Industry Readiness: Typed Functional Programming</a></h1>
<p><em>by Foo Yong Qi</em></p>
<p>This is a set of lecture notes for students enrolled in IT5100A—Industry Readiness: Typed Functional Programming in NUS SoC.</p>
<h2 id="about-it5100a"><a class="header" href="#about-it5100a">About IT5100A</a></h2>
<p>Typed functional programming are becoming more widely adopted in industry, as can be seen in the success of a number of advanced programming languages, such as OCaml, Haskell and Scala 3. These advanced languages offer a range of expressive features to allow robust, reusable and high-performing software codes to be safely and rapidly developed. This course will cover key programming techniques of typed functional programming that are becoming widely adopted, such as strong typing, code composition and abstraction, effect handlers, and safe techniques for asynchronous and concurrent programming.</p>
<h2 id="about-these-notes"><a class="header" href="#about-these-notes">About These Notes</a></h2>
<p>I hope that these notes can be used as good supplementary material for those looking to learn Functional Programming in a bit more detail :)</p>
<h2 id="release-history"><a class="header" href="#release-history">Release History</a></h2>
<h3 id="2024-sep-24"><a class="header" href="#2024-sep-24">2024 Sep 24</a></h3>
<p>The first draft of these notes have been released with the first three chapters and their solutions to exercises completed.</p>
<div style="break-before: page; page-break-before: always;"></div><p>In this chapter, we go through some of the usual administrivia of this course, and proceed to discuss some core ideas of Functional Programming (FP) in different settings, some which should be unfamiliar to you.</p>
<p>Readers who find some of the concepts in <a href="course_introduction/sections/functional_programming.html">Chapter 1.2 (Functional Programming)</a> challenging or unfamiliar can revisit these ideas in <a href="course_introduction/../recap/README.html">Chapter 8 (Recap of Concepts)</a> before proceeding.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="course-administration"><a class="header" href="#course-administration">Course Administration</a></h1>
<h2 id="course-coordinator"><a class="header" href="#course-coordinator">Course Coordinator</a></h2>
<p>Foo Yong Qi</p>
<p>Instructor &amp; Ph.D. Student</p>
<p>Email: yongqi@nus.edu.sg</p>
<h2 id="course-outline"><a class="header" href="#course-outline">Course Outline</a></h2>
<ul>
<li>Course Introduction
<ul>
<li>Course Administration</li>
<li>Functional Programming</li>
<li>Introduction to Haskell</li>
</ul>
</li>
<li>Types
<ul>
<li>Types and Type Systems</li>
<li>Polymorphism</li>
<li>Algebraic Data Types</li>
<li>Pattern Matching</li>
</ul>
</li>
<li>Typeclasses
<ul>
<li>What Are Typeclasses?</li>
<li>Important Typeclasses</li>
<li>Typeclasses and Typeclass Instances</li>
</ul>
</li>
<li>Railway Pattern
<ul>
<li>Functors</li>
<li>Applicative Functors</li>
<li>Validation</li>
<li>Monads</li>
</ul>
</li>
<li>Monads
<ul>
<li>Commonly-Used Monads</li>
<li>Monad Transformers</li>
</ul>
</li>
<li>Concurrent Programming
<ul>
<li>Concurrent Programming with Threads</li>
<li>Parallel Programming</li>
<li>Software Transactional Memory</li>
</ul>
</li>
<li>Course Conclusion</li>
</ul>
<h2 id="graded-items"><a class="header" href="#graded-items">Graded Items</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Item</th><th>Weightage</th></tr></thead><tbody>
<tr><td>Assignment 1</td><td>20%</td></tr>
<tr><td>Assignment 2</td><td>20%</td></tr>
<tr><td>Assignment 3</td><td>20%</td></tr>
<tr><td>Practical Exam</td><td>40%</td></tr>
</tbody></table>
</div>
<p>The Practical Exam is planned to be during the last lecture.</p>
<h2 id="plagiarism-notice"><a class="header" href="#plagiarism-notice">Plagiarism Notice</a></h2>
<p>Assignments are on programming... standard plagiarism rules apply.</p>
<p><mark>No code sharing!</mark></p>
<ul>
<li>ChatGPT (and similar tools) is allowed for <strong>learning only</strong></li>
<li>Using LLMs to generate code is <strong>not allowed</strong></li>
<li>NUS takes a strict view of plagiarism and cheating</li>
<li>Disciplinary action will be taken against students who violate NUS Student Code of Conduct</li>
<li>No part of your assignment can come from any other source</li>
<li>No discussion and sharing of solutions during exams</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programming"><a class="header" href="#functional-programming">Functional Programming</a></h1>
<p><em>Functional Programming</em> (FP) is a <em>declarative</em> <em>programming paradigm</em> where <em>functions</em> take centre stage. As a recap from IT5001, you might have learnt that programming paradigms are schools of thought for writing programs. IT5001 has very likely exposed you to <em>imperative</em> paradigms like <em>procedural</em> and <em>Object-Oriented Programming</em>. These are some of the more popular programming paradigms today.</p>
<div class="table-wrapper"><table><thead><tr><th>Imperative</th><th>Declarative</th></tr></thead><tbody>
<tr><td>Procedural</td><td>Logic</td></tr>
<tr><td>Object-Oriented</td><td>Functional</td></tr>
</tbody></table>
</div>
<p>Object-Oriented Programming (OOP) has four principles as you might recall: <em>Abstraction</em>, <em>Inheritance</em>, <em>Encapsulation</em> and
<em>Polymorphism</em>.<sup class="footnote-reference"><a href="#1">1</a></sup> Functional Programming, on the other hand, is centered around the following principles, which really are just principles of mathematical functions and the <em>lambda calculus</em>:</p>
<ul>
<li>Immutability</li>
<li>Pure Functions</li>
<li>Recursion</li>
<li>Types</li>
<li>First-Class Functions</li>
</ul>
<p>Let's briefly describe what these principles entail.</p>
<h2 id="immutability"><a class="header" href="#immutability">Immutability</a></h2>
<p>The idea of <em>immutability</em> is simple—only use <strong>immutable</strong> data. Let's look at an example of programming using only immutable data (and variables)! The following program fragment does not perform any mutation:</p>
<pre><code class="language-python"># Python
def add_one(fraction):
    """fraction is a tuple of (numerator, denominator)"""
    old_num, den = fraction
    num = old_num + den
    return (num, den)
 
my_fraction = (3, 2)
new_fraction = add_one(my_fraction)
 
print(new_fraction) # (5, 2)
print(my_fraction) # (3, 2)
</code></pre>
<p>The fact that the program does not perform any mutation makes this very
similar to mathematical functions where mathematical objects are seen as
values instead of references to cells that can be changed. This makes
reasoning about any of the variables, objects and functions incredibly
simple.</p>
<p>Overall, immutability forces us to be disciplined with <strong>state</strong>.
Contrast this with using <strong>mutable</strong> data structures and variables, such as in the following program fragment:</p>
<pre><code class="language-python"># Python
def f(ls):
  ls[0] = 4
  return ls
 
my_ls = [1, 2, 3]
print(f(my_ls)) # [4, 2, 3]
print(my_ls) # [4, 2, 3]
</code></pre>
<p>This is one of the classic examples of the problems with mutability—it is
not at all clear whether passing a list into a function will preserve
the state of the list. Because lists are mutable, we have no guarantee
that functions or any operation will not cause the <em>side-effect</em> of
mutation (accidental or intentional).</p>
<h2 id="pure-functions"><a class="header" href="#pure-functions">Pure Functions</a></h2>
<p>Just like mathematical functions, functions (in programming) should be
<em>pure</em>. Pure functions really look like mathematical functions, for
example, \(f\) below:</p>
<p>\[f: \mathbb{N} \to \mathbb{N}\]
\[f(x) = x^2 + 2x + 3\]</p>
<p>An equivalent implementation in Python would
look like</p>
<pre><code class="language-python"># Python
def f(x):
  return x ** 2 + 2 * x + 3
</code></pre>
<p>The idea is that pure functions <strong>only receive input and return
output</strong>. Pure functions do not produce side effects, and do not depend
on external state. And example of this is as follows:</p>
<pre><code class="language-python"># Python
def double(ls):
  return [i * 2 for i in ls]
 
x = [1, 2, 3]
 
print(double(x)) # [2, 4, 6]
print(double(x)) # [2, 4, 6]
print(double(x)) # ...
# ...
</code></pre>
<p>Notice that the <code>double</code> function is pure! In this example,
<code>double(x)</code> evaluates to <code>[2, 4, 6]</code>; thus,
<code>double(x)</code> and <code>[2, 4, 6]</code> are the <strong>same</strong>! This
property of pure functions is known as <em>referential transparency</em>, and
makes reasoning about and optimizing programs much more straightforward.</p>
<p>Contrast the behaviour of pure functions with that of impure functions:</p>
<pre><code class="language-python"># Python
def f():
  global ls
  x = ls # use of global variable
  addend = x[-1] + 1
  x.append(addend) # is there a side-effect?
  ls = x + [addend + 1] # mutate global variable
  return ls
 
ls = [1, 2, 3]
x = ls
 
print(f()) # [1, 2, 3, 4, 5]
print(ls) # [1, 2, 3, 4, 5]
print(x) # [1, 2, 3, 4]
</code></pre>
<p>So many side effects have been caused! Functions like these make
reasoning about program behaviour incredibly difficult. Converting this
function into a pure one (removing all side-effects) makes its behaviour
clearer and more transparent.</p>
<pre><code class="language-python"># Python
def f(ls):
  x = ls
  addend = x[-1] + 1
  x = x + [addend]
  ls = x + [addend + 1]
  return ls
 
ls = [1, 2, 3]
x = ls
 
print(f(ls)) # [1, 2, 3, 4, 5]
print(ls) # [1, 2, 3]
print(x) # [1, 2, 3]
</code></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>You have seen this before—use <em>recursive</em> functions to simulate loops.<sup class="footnote-reference"><a href="#2">2</a></sup> Let's look at an example of a perfectly reasonable way to sum
the numbers of a 2-dimensional list, using the <code>sum2D</code> function:</p>
<pre><code class="language-python"># Python
def sum2D(ls):
  total = 0
  for row in ls:
    for num in row:
      total += num
  return total
</code></pre>
<p>Loops are typically useful for its side-effects, primarily mutation.
Looking at the (nested) loop above, a bunch of mutation occurs: the
reassignments to <code>row</code> and <code>num</code> (the loop variables),
and the mutation of the <code>total</code> variable in the loop body. In
an environment where mutation is impossible, can we write the same
program? Yes! Like we have said, rely on <strong>recursion</strong>! An example
recursive formulation of the <code>sum2D</code> function from above would
be like so:</p>
<pre><code class="language-python"># Python
def row_sum(row):
    return 0 if not row else \
           row[0] + row_sum(row[1:])
 
def sum2D(ls):
    return 0 if not ls else \
           row_sum(ls[0]) + sum2D(ls[1:])
</code></pre>
<p>Again, the behaviour of the program has not changed: the
<code>sum2D</code> function still produces the correct output given any
2-dimensional list of integers. However, our function is still pure and
does not mutate <strong>any</strong> data structure or variable.</p>
<p>Recursive solutions can also be incredibly elegant to express,
especially when the problem or data structures used are (inherently)
recursive. Take the example of obtaining the preorder of a binary tree.
Binary trees are recursive data structures, if formulated the following
way:</p>
<blockquote>
<p>A (nonempty) tree is either:</p>
<ul>
<li>A node with a value, a left tree and a right tree; OR</li>
<li>A leaf with just a value</li>
</ul>
</blockquote>
<p>As you can see, the definition of a node contains (sub)trees, making it
a recursive data structure<sup class="footnote-reference"><a href="#3">3</a></sup>. Therefore, operations on trees can often be
expressed elegantly using recursion. For example, the specification of
getting the <em>preorder</em> of a tree can be like so:</p>
<ol>
<li>
<p>The preorder of a leaf is a list containing the leaf's value</p>
</li>
<li>
<p>The preorder of a node is the node's value, together with the
preorder of the left (sub)tree, then the preorder of the right
(sub)tree.</p>
</li>
</ol>
<p>This specification written in code is concise and elegant:</p>
<pre><code class="language-python"># Python 3.11
from dataclasses import dataclass
 
@dataclass
class Tree: pass
 
@dataclass
class Node(Tree):
    val: object
    left: Tree
    right: Tree
 
@dataclass
class Leaf(Tree):
    val: object
 
def preorder(tree):
    match tree:
        case Node(val=v, left=l, right=r):
            return [v] + preorder(l) + preorder(r)
        case Leaf(val=v):
            return [v]
</code></pre>
<p>Recursive functions are also amenable to <strong>formal</strong> reasoning. Some
languages (usually <em>Interactive Theorem Provers</em>) support proofs and can
even automatically synthesize proofs of correctness for you. In the
following example written in Lean 4, the following program defines a
binary tree and a program for obtaining the preorder of the tree just as
before; the key difference being, that Lean automatically helps us prove
that the function <strong>terminates</strong>. In such an environment, we rarely have
to worry whether our program gets stuck or crashes.</p>
<pre><code class="language-lean">-- Lean 4
inductive Tree (α : Type) : Type where
  | node : α -&gt; Tree α -&gt; Tree α -&gt; Tree α
  | leaf : α -&gt; Tree α 
 
-- compiler automatically synthesizes proof of termination
def Tree.preorder { β : Type } : Tree β -&gt; List β
  | .node v l r =&gt; v :: (preorder l) ++ (preorder r)
  | .leaf v =&gt; [v]
 
def myTree : Tree Nat := .node 1 (.leaf 2) (.leaf 3)
#eval myTree.preorder -- [1, 2, 3]
</code></pre>
<p>The primary reason for this is that recursive functions can often be
reasoned about via <em>induction</em>:</p>
<p>\[\frac{P(0)~~~~~\forall k \in \mathbb{N}. P(k)\to P(k + 1)}{\forall n \in \mathbb{N}. P(n)} \text{Modus Ponens}\]</p>
<p>We have seen that factorial can be written recursively, and in fact we
can prove its correctness (in a quite straightforward manner) via
induction. This makes the following factorial function implementation
obviously correct.</p>
<pre><code class="language-lean">-- Lean 4
def fac : Nat -&gt; Nat 
  | 0     =&gt; 1
  | n + 1 =&gt; (n + 1) * fac n
</code></pre>
<h3 id="types"><a class="header" href="#types">Types</a></h3>
<p>Adhering strictly to type information <strong>eliminates type-related bugs</strong>
and makes functions <strong>transparent</strong>. Perhaps most importantly, adherence
to type information can be verified by a program.</p>
<p>Observe the following program fragment.</p>
<pre><code class="language-python"># Python
x: int = 123
# ...
print(x + 5)
</code></pre>
<p>If we fix the type of <code>x</code> to <code>int</code> and strictly adhere
to it, then the last line containing <code>x + 5</code> will definitely
not cause a <code>TypeError</code>, because we know that adding any number
to an integer will always work.</p>
<p>Contrast the above with the following example.</p>
<pre><code class="language-python"># Python
def safe_div(num: int, den: int) -&gt; int:
    return None if den == 0 else \
           num // den
 
x = int(input())
y = int(input())
z = safe_div(x, y) + 1 # hmmm...
print(z)
</code></pre>
<p>If we do not adhere to typing information strictly, no one knows that
the <code>safe_div</code> function could return <code>None</code>! In such a
scenario, if the user enters <code>0</code> for <code>y</code>, the
expression <code>safe_div(x, y) + 1</code> would give a
<code>TypeError</code>!</p>
<p>Function purity and adhering to types forces functions to be
<strong>transparent in effects</strong>. That is because if we want our pure function
to perform some effectful computation (such as potentially returning
<code>None</code>), we must return an object that encapsulates this
behaviour; coupled with adhering to types, we must assign the correct
type for the output of the function—the type of the object which
encapsulates this behaviour—making the function's effects obvious.</p>
<p>To improve the program written earlier, let us try to create a data structure
<code>Maybe</code> that is one of two things: <code>Just</code> a value, or
<code>Nothing</code>. We can express this as dataclasses in Python (you
may ignore the stuff involving <code>typing</code> and <code>Generic</code>s
for now, they will make sense later).</p>
<pre><code class="language-python"># Python 3.11
from dataclasses import dataclass
from typing import Generic, TypeVar, Any
T = TypeVar('T', covariant=True)
 
@dataclass(frozen=True)
class Maybe(Generic[T]):
    """Represents computation that may result in nothing"""
    pass
 
@dataclass(frozen=True)
class Just(Maybe[T], Generic[T]):
    j: T
 
@dataclass(frozen=True)
class Nothing(Maybe[Any], Generic[T]):
    pass
</code></pre>
<p>Now we can amend our <code>safe_div</code> function appropriately to
return a <code>Maybe</code> value:</p>
<pre><code class="language-python">def safe_div(num: int, den: int) -&gt; Maybe[int]:
    return Nothing() if den == 0 else \
           Just(num // den)
</code></pre>
<p>Notice two things: 1) the function is pure, and does nothing other than
receive inputs and returns output 2) the function's type signature makes
it incredibly obvious that the function will <em>maybe</em> produce an
<code>int</code>. Therefore, users of this function are <em>forced</em> to handle
the case where the function produces <code>Nothing</code>.</p>
<p>From this, we may proceed to use the <code>safe_div</code> function as
before, except that instead of directly assigning
<code>z = safe_div(x, y) + 1</code>, we must first call
<code>safe_div</code> and handle the two cases: one where some integer was
returned, the other where nothing was.</p>
<pre><code class="language-python">x: int = int(input())
y: int = int(input())
z: Maybe[int]
match safe_div(x, y):
    case Just(j=j):
        z = Just(j + 1)
    case Nothing():
        z = Nothing()
</code></pre>
<p>Types and type systems are highly useful, not just for verification of
type safety, but also more generally, program verification and theorem
proving, etc. Types are backed by a rich theory (type theory) and is
widely studied. As an example, interactive theorem provers may use
advanced type systems (such as the calculus of constructions, which has
<em>dependent types</em>) to form the computational basis for proof assistance
and proof checking. When these systems are baked into the language, we
can write proof-carrying code and theorems (mathematical theorems or
theorems about properties of code itself). An example is as follows,
where theorems about the additive identity and the commutativity of
addition of numbers can be used to show that concatenating a vector
(like an immutable list) of length \(n\) to one of length \(k\) gives a
vector of length \(n + k\).</p>
<pre><code class="language-lean">-- Lean 4
theorem izero : ∀ (k : Nat) , k = 0 + k
  | 0 =&gt; by rfl
  | n + 1 =&gt; congrArg (. + 1) (izero n)
 
theorem isucc (n k : Nat) : n + k + 1 = n + 1 + k :=
  match k with 
  | 0 =&gt; by rfl
  | x + 1 =&gt; congrArg (. + 1) (isucc n x)
 
def Vect.concat {α : Type} {n k : Nat} : 
    Vect α n -&gt; Vect α k -&gt; Vect α (n + k)
  | .nil, ys =&gt; izero k ▸ ys
  | .cons x xs, ys =&gt; isucc _ _ ▸ .cons x (xs.concat ys)
</code></pre>
<h3 id="first-class-functions"><a class="header" href="#first-class-functions">First-Class Functions</a></h3>
<p>You might have seen in IT5001 that in some languages, functions are
<em>first-class</em> objects. This gives rise to higher-order functions which
support <strong>code re-use</strong>. <em>Higher-order functions</em> can receive functions
as arguments and/or return functions as output.</p>
<p>In the following program fragment, the <code>map</code> method of
<code>Tree</code>s receive a function and returns a new tree with the
function applied to all of its values. We then also <em>curry</em> the
<code>add</code> function so that it receives the first addend, then
returns a function that receives the second addend and returns the sum.
This way, adding 2 to the values of a tree is as simple as several
function calls:</p>
<pre><code class="language-python"># Python
@dataclass(frozen=True)
class Tree:
    def map(self, f):
        match self:
            case Leaf(v):
                return Leaf(f(v))
            case Node(v, l, r):
                newval = f(v)
                newl = l.map(f)
                newr = r.map(f)
                return Node(newval, newl, newr)
 
@dataclass(frozen=True)
class Node(Tree):
    val: object
    left: Tree
    right: Tree
 
@dataclass(frozen=True)
class Leaf(Tree):
    val: object
 
def add(x):
    return lambda y: x + y
 
x = Node(1, Leaf(2), Leaf(3))
print(x.map(add(2))) # Node(3, Leaf(4), Leaf(5))
</code></pre>
<p>Functional programming languages emphasize this fact and makes it easy
and ergonomic to define higher-order functions. For example, in Haskell,
functions are automatically curried, and has higher-order functions like
<code>map</code> built into the standard library. This makes, for
example, adding two to elements of a list, straightforward:</p>
<pre><code class="language-haskell">main :: IO ()
main = do
  let x = [1, 2, 3]
  print (map (+2) x) -- [3, 4, 5]

class Eq a where
    (==) :: a -&gt; a -&gt; Bool
</code></pre>
<h3 id="so-what"><a class="header" href="#so-what">So what?</a></h3>
<p>Ideas from functional programming languages are increasingly being
adopted in commonly-used imperative programming languages:</p>
<ul>
<li>
<p>Closures in C++/Rust/Java 8</p>
</li>
<li>
<p>Structural pattern matching in Python 3.11/Java 21</p>
</li>
<li>
<p>Algebraic Data Types in Rust</p>
</li>
<li>
<p>Records in Java 14 etc.</p>
</li>
</ul>
<p>As such, learning functional programming features has direct carry-over
to the work that you might do in the future. Of course, functional
programming is more than just a set of programming language features and
principleslearning functional programming is about <strong>rethinking the way
we solve problems</strong>. As you have seen, some of the principles we have
discussed impose restrictions on the programmer. Although these are
meaningful restrictions, solving problems with them imposed can be quite
challenging and will require different approaches. However, learning
functional programming is worth it as it gives you an entirely new
perspective of problem solving. The new skills you would gain from doing
so allows you to grow into a more disciplined developer, and allows you
to explore different solutions to problems you face in your day-to-day
experience as a software engineer.</p>
<p>Our goal for this course is to therefore first learn how to write
programs in a purely functional programming language (thus forcing you
to write programs fully with FP), and then transfer concepts into
commonly used programming languages. For this, we will be writing code
in two languages: <em>Haskell</em> (a purely functional programming language)
and Python (which you should all be relatively familiar with).</p>
<h3 id="things-you-need"><a class="header" href="#things-you-need">Things You Need</a></h3>
<p>For this course, you will need the following software:</p>
<ul>
<li>
<p>The Glasgow Haskell Compiler (GHC)</p>
</li>
<li>
<p>Python 3.12 (note the version; we shall be using new features)</p>
</li>
<li>
<p>Any text editor you like (Visual Studio Code, Neovim etc.)</p>
</li>
</ul>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Polymorphism in OOP refers to <em>subtype polymorphism</em>, which is
different to the polymorphism in FP known as <em>parametric
polymorphism</em>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>If you have not, you may want to read
<a href="course_introduction/sections/../../recap/sections/recursion.html">a recap on recursion</a> before continuing.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>(Singly-linked) lists are also recursive data structures. To see
this, look at our definition of binary trees, and remove one subtree
in the definition of a node (therefore, a node has a value and one
subtree). This is now a singly-linked list.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="haskell"><a class="header" href="#haskell">Haskell</a></h1>
<p>Haskell is a <em>statically-typed</em>, <em>purely functional</em>
<em>nonstrict-evaluation</em> programming language. Informally, static typing
means that we can look at a program (without executing it) and tell what
the type of any object or variable is. A purely-functional language is a
language that supports only functional programming concepts (unlike
multi-paradigm languages like Python). Nonstrict-evaluation means that
there is no strict sequence of evaluating statements or expressions<em>lazy
evaluation</em> can be employed and compilers are free to decide which
expressions should be evaluated first. We will look at non-strict
evaluation eventually; for now, understanding static typing and purely
functional programming is more important.</p>
<p>In a purely functional language like Haskell, you will miss the
following programming language features:</p>
<ul>
<li>
<p>Mutation (even variables are immutable);</p>
</li>
<li>
<p>Loops;</p>
</li>
<li>
<p>Objects (classes etc.);</p>
</li>
<li>
<p>Dynamic typing (e.g. <code>x</code> can be an <code>int</code> now, and
a <code>str</code> later);</p>
</li>
</ul>
<p>You might find it difficult to adjust to such a programming environment.
However, you will find these restrictions meaningful as we have alluded
to in the previous section.</p>
<h3 id="basic-expressions"><a class="header" href="#basic-expressions">Basic Expressions</a></h3>
<p>By this point you should have already installed GHC, which comes with
two main parts: <code>ghc</code> itself (the compiler), and <code>ghci</code> the
REPL/interpreter. For now, open <code>ghci</code> to start an interactive Haskell
shell, and enter some basic mathematical expressions!</p>
<pre><code class="language-haskell">ghci&gt; 1 + 2 - 3
0
ghci&gt; 1 * 2 / 4
0.5
ghci&gt; 5 ^ 2 `mod` 5
0
</code></pre>
<p>Note some differences: <code>^</code> is exponentiation (just as you would normally
type in a calculator), and there is no modulo operator. There is a
modulo function called <code>mod</code>, and you can apply any binary
function in an <em>infix</em> manner by surrounding the function in backticks.
The operator precedence rules apply.</p>
<p>In a functional programming language like Haskell, it should come as no
surprise that virtually everything is a function. Mathematical operators
are actually just functions! In GHCI, we can observe the type of any
object (functions are objects!) using <code>:t</code>, and we can show the type of
the function of the <code>+</code> operator by issuing <code>:t (+)</code> (when writing
operators as a normal object, surround it in parentheses). We can in
fact re-write an infix operator function call as a normal prefix
function call. Note that in Haskell, <code>f x y z</code> is essentially
the same as <code>f(x, y, z)</code> in languages like Python.</p>
<pre><code class="language-haskell">ghci&gt; :t (+)
Num a =&gt; a -&gt; a -&gt; a
ghci&gt; 2 + 3
5
ghci&gt; (+) 2 3
5
</code></pre>
<p>As we know, currying is the act of translating an $n$-ary function to a
unary function that receives one parameter and returns a function that
receives the remaining parameters (in curried form). In Haskell, all
functions are curried, so even a function like <code>(+)</code> really
looks something like this in Python:</p>
<pre><code class="language-python">def add(x):
    return lambda y: x + y
</code></pre>
<p>This is automatically done in Haskell. Thus we might be able to write
our Python equivalent of <code>add(2)</code> directly in Haskell as
<code>(+2)</code>:</p>
<pre><code class="language-haskell">ghci&gt; y = (+2)              
ghci&gt; y 3
5
</code></pre>
<p>which in Python, looks like:</p>
<pre><code class="language-python">&gt;&gt;&gt; def add(x): return lambda y: x + y
&gt;&gt;&gt; y = add(2)
&gt;&gt;&gt; y(3)
5
</code></pre>
<p>Therefore, to be more specific, <code>f x y z</code> in Haskell is more
like <code>f(x)(y)(z)</code> in Python.</p>
<p>We can also load Haskell source files into GHCI. Python source files
have the <code>.py</code> extension; Haskell source files instead have the <code>.hs</code>
extension. Let us try writing a simple Haskell program. Create a new
file like <code>MyCode.hs</code> and write in the following:</p>
<pre><code class="language-haskell">-- MyCode.hs
main :: IO () -- entry point to the program
main = putStrLn "Hello World!"
</code></pre>
<p>We will look at what the first line means in the future. For now, try
compiling and running your code by issuing the following commands in
your terminal (windows users might have to run <code>./MyCode.exe</code>):</p>
<pre><code>ghc MyCode.hs
./MyCode
</code></pre>
<p>The first command invokes GHC to <em>compile</em> your source file.
<em>Compilation</em> translates your source file into an <em>executable</em> file that
your computer that understand. The compilation process will also perform
a bunch of compile-time checks, such as type-checking etc. It may also
perform some optimizations. The outcome of invoking that command is an
executable (probably called <code>MyCode</code>) along with other files (which we
shall not talk about for now). The second command then executes that
executable, and you should see <code>Hello World!</code> shown in the terminal.</p>
<p>We shall ignore compiling source files for now and temporarily focus on
working with GHCI. In GHCI, we can load files by issuing <code>:l MyFile.hs</code>,
which loads the source into the shell. For now, write the following code
in <code>MyCode.hs</code>:</p>
<pre><code class="language-haskell">-- MyCode.hs
z = 1 -- ok
y = 2 -- ok
y = 3 -- not ok!
</code></pre>
<p>As we have described earlier, everything in Haskell is immutable.
Therefore, re-defining what <code>y</code> is should be disallowed! Let's try
loading <code>MyCode.hs</code> into GHCI:</p>
<pre><code class="language-haskell">ghci&gt; :l MyCode.hs
[1 of 2] Compiling Main ( MyCode.hs, interpreted )

MyCode.hs:4:1: error:
    Multiple declarations of 'y'
    Declared at: MyCode.hs:3:1
                 MyCode.hs:4:1
  |
4 | y = 3 -- not ok!
  | ^
</code></pre>
<p>As you can see, you cannot redefine functions or variables. Everything
is immutable in Haskell!</p>
<h3 id="control-structures"><a class="header" href="#control-structures">Control Structures</a></h3>
<p>In Haskell, you mainly write <em>expressions</em>, and not statements.
Consequently, there are only if-else expressions, and no if-else
statements. That means, that you cannot omit an else branch of an
if-else expression, just like in Python:</p>
<pre><code class="language-haskell">ghci&gt; x = 2 * (-1)
ghci&gt; y = if x == 2 then "positive" else "negative"
ghci&gt; y
"negative"
</code></pre>
<p>In Python, this might look like<sup class="footnote-reference"><a href="#4">1</a></sup>:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = 2 * -1
&gt;&gt;&gt; y = 'positive' if x == 2 else 'negative'
&gt;&gt;&gt; y
'negative'
</code></pre>
<p>Just like in Python, if-else expressions are <em>expressions</em> and therefore
evaluate to the appropriate value:</p>
<pre><code class="language-haskell">ghci&gt; (if 1 /= 2 then 3 else 4) + 5
8
</code></pre>
<p>Note that <em>not equals</em> looks like <code>/=</code> in Haskell but <code>!=</code> in Python.
The equivalent expression in Python might be:</p>
<pre><code class="language-python">&gt;&gt;&gt; (3 if 1 != 2 else 4) + 5
8
</code></pre>
<p>Importantly, the type of any expression is fixed, or at least, we should
be able to determine what the type of every expression is unambiguously
just by looking at it. Therefore, writing the following expression in
Haskell will throw an error:</p>
<pre><code class="language-haskell">ghci&gt; x = 2 * (-1)
ghci&gt; y = if x == 2 then 2 else "negative"
&lt;interactive&gt;:2:20: error:
  - No instance for (Num String) arising from the literal '2'
  - In the expression: 2
    In the expression: if x == 2 then 2 else "negative"
    In an equation for 'y': y = if x == 2 then 2 else "negative"
</code></pre>
<p>The reason is because we should not need to evaluate the truth of
<code>x == 2</code> to determine what the type of the entire if-else
expression is. Thus, Haskell requires that the type of the expression in
the if branch be the same as the type of the expression in the else
branch. This departs from Python which is <em>dynamically typed</em>, where
types are determined at runtime, so expressions can freely be of
different types based on the values they inherit at the time of program
execution.</p>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p>Defining functions in Haskell looks like defining a variable. This
should be expected since Haskell is centred around functions, so it
should come as no surprise that functions do not need to be defined with
any special syntax.</p>
<pre><code class="language-haskell">ghci&gt; oddOrEven x = if even x then "even" else "odd"
ghci&gt; oddOrEven 1
"odd"
ghci&gt; oddOrEven 2
"even"

ghci&gt; quadratic c2 c1 c0 x = c2 * x ^ 2 + c1 * x + c0
ghci&gt; f = quadratic 1 2 3 -- x^2 + 2x + 3
ghci&gt; f 4
27
ghci&gt; f 5
38
</code></pre>
<p>We might then ask: how do we write a loop in Haskell? Like we said
earlier, Haskell is a purely functional programming language, so there
are no loops (we may later see loops being simulated with functions).
Thus, for now we shall use recursion as it is often the most elegant way
to solve problems.</p>
<p>Recall that the familiar factorial function may be written iteratively
in Python as:</p>
<pre><code class="language-python">def fac(n):
    res = 1
    for i in range(2, n + 1):
        res *= i
    return res
</code></pre>
<p>As we know, the factorial function can be defined recursively as such:
$$n! = \begin{cases}
1 &amp; \text{if }n=0\\
n \times (n - 1)!&amp; \text{otherwise}
\end{cases}$$ And in Python:</p>
<pre><code class="language-python">def fac(n):
    return 1 if n == 0 else \
           n * fac(n - 1)
</code></pre>
<p>In Haskell, we are free to do the same:</p>
<pre><code class="language-haskell">ghci&gt; fac n = if n == 0 then 1 else n * fac (n - 1)
ghci&gt; fac 4
24
</code></pre>
<p>In fact, we can also express functions like this elegantly in Haskell
with <em>guards</em>. Guards allow us to define expressions differently based
on a condition.</p>
<p>We know that the fibonacci function may be written like so:
$$f(n) = \begin{cases}
1 &amp; \text{if } n = 0\\
1 &amp; \text{if }n = 1\\
f(n - 1) + f(n - 2) &amp; \text{otherwise}
\end{cases}$$ And writing this function with regular if-else
expressions might look like: <sup class="footnote-reference"><a href="#5">2</a></sup></p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| fib n = if n == 0 || n == 1 
ghci|         then 1 
ghci|         else fib (n - 1) + fib (n - 2)
ghci| :}
</code></pre>
<p>However, it might look clearer to define it this way with guards:</p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| fib n
ghci|   | n == 0    = 1
ghci|   | n == 1    = 1
ghci|   | otherwise = fib (n - 1) + fib (n - 2)
ghci| :}
ghci&gt; fib 5
8
</code></pre>
<p>Even better, we can use <em>pattern matching</em> to define such functions much
more easily. We will look at pattern matching in more detail in the
future:</p>
<pre><code class="language-haskell">ghci&gt; fib 0 = 1
ghci&gt; fib 1 = 1
ghci&gt; fib n = fib (n - 1) + fib (n - 2)
ghci&gt; fib 5
8
</code></pre>
<p>Thus far we have defined functions as a single expression; this is akin
to writing a <em>lambda expression</em> in Python. As we know, that may not
always be the most ergonomic considering that many functions can be
better defined with several 'statements' that lead into a final
expression. One example would be the following in Python:</p>
<pre><code class="language-python">def weight_sum(n1, w1, n2, w2):
    x = n1 * w1
    y = n2 * w2
    return x + y
</code></pre>
<p>While it is completely acceptable to define this function in one line,
it is not as readable. In Haskell, functions indeed have to be written
as a single expression, but we may add additional bindings for the
expression using <code>let</code> bindings:</p>
<pre><code class="language-haskell">ghci&gt; :{
ghci| weightSum n1 w1 n2 w2 =
ghci|   let x = n1 * w1
ghci|       y = n2 * w2
ghci|   in  x + y
ghci| :}
ghci&gt; weightSum 2 3 4 5
26
</code></pre>
<p>The <code>let</code> binding allows us to introduce the definitions of
<code>x</code> and <code>y</code> which are used in the expression after
the <code>in</code> clause. These make writing larger expressions more readable.</p>
<p><code>let</code> bindings are (more-or-less) <em>syntax sugar</em> for function calls:</p>
<pre><code class="language-haskell">weightSum n1 w1 n2 w2 = 
    let x = n1 * w1
        y = n2 * w2
    in  x + y
 
-- same as
 
weightSum n1 w1 n2 w2 =
    f (n1 * w1) (n2 * w2)

f x y = x + y
</code></pre>
<p>Importantly, <code>let</code> bindings are expressions; they therefore evaluate to
a value, as seen in this example:</p>
<pre><code class="language-haskell">ghci&gt; (let x = 1 + 2 in x * 3) + 4
13
</code></pre>
<p>This is different to <code>where</code> bindings, which also allow us to write
auxiliary definitions that support the main definition:</p>
<pre><code class="language-haskell">weightSum n1 w1 n2 w2 = 
    let x = n1 * w1
        y = n2 * w2
    in  x + y
 
-- same as

weightSum n1 w1 n2 w2 = x + y
    where x = n1 * w1
          y = n2 * w2
</code></pre>
<p>Other differences between <code>let</code> and <code>where</code> are not so apparent at this
stage. You are free to use either appropriately (use <code>let</code> where an
expression is desired, using either <code>let</code> or <code>where</code> are both okay in
other scenarios).</p>
<h3 id="data-types"><a class="header" href="#data-types">Data Types</a></h3>
<p>We have looked at some simple data types so far: numbers like
<code>1.2</code>, and strings like <code>"abc"</code>. Strings are
actually <strong>lists</strong> of characters! Strings are surrounded by double
quotes, and characters are surrounded by single quotes, like
<code>'a'</code>.</p>
<p>Lists in Haskell are <em>singly-linked list</em> with homogenous data. That
means that the types of the elements in the list must be the same. We
can write lists using very familiar syntax, e.g. <code>[1, 2, 3]</code>
being a list containing the numbers 1, 2 and 3. Indexing a list can be
done with the <code>!!</code> function.</p>
<pre><code class="language-haskell">ghci&gt; x = [1, 2, 3]
ghci&gt; x !! 1 -- indexing, like x[1]
2
</code></pre>
<p>We can also construct ranges of numbers, or any enumerable type (such as
characters). The syntax for creating such lists is straightforward as
shown in the examples below.</p>
<pre><code class="language-haskell">ghci&gt; y = [1,3..7] -- list(range(1, 8, 2))
ghci&gt; y
[1,3,5,7]
ghci&gt; z = [1..10]  -- list(range(1, 11))
ghci&gt; z
[1,2,3,4,5,6,7,8,9,10]
ghci&gt; inflist = [1..] -- 1,2,3,...
ghci&gt; inflist !! 10
11
</code></pre>
<p>As we stated earlier, strings are lists of characters, we can even build
ranges of characters which result in strings.</p>
<pre><code class="language-haskell">ghci&gt; ['h', 'e', 'l', 'l', 'o']
"hello"
ghci&gt; ['a'..'e']
"abcde"
ghci&gt; ['a'..'e'] ++ ['A'..'D'] -- ++ is concatentation
"abcdeABCD"
</code></pre>
<p>As you know, a singly-linked list is one of two things: an empty list,
or a node with a value (head) and a reference to the remaining part of
the list (tail). Thus, one of the most frequently used operations is the
<em>cons</em> operation (<code>:</code>) which builds (or de-structures) a list
given its head and tail values. The <code>:</code> operator is
right-associative.</p>
<pre><code class="language-haskell">ghci&gt; x = [1, 2, 3]
ghci&gt; 0 : x
[0,1,2,3]
ghci&gt; 0 : 1 : 2 : 3 : []
[0,1,2,3]
ghci&gt; 'a' : "bcde"
"abcde"
</code></pre>
<p>One of the most interesting parts of Haskell is that it has
nonstrict-evaluation. That means that the compiler is free to evaluate
any expression only when it is needed. This allows us to quite nicely
define recursive data without running into infinite loops:</p>
<pre><code class="language-haskell">ghci&gt; y = 1 : y
ghci&gt; take 5 y
[1,1,1,1,1]
</code></pre>
<p>As we know, performing recursion over a list frequently requires us to
get a head element and then recursively calling the function over the
remaining list. This is nicely supported without any performance costs
unlike in Python, where <code>ls[1:]</code> runs in $O(n)$. For example,
writing a function that sums a list of numbers might look like the
following in Python:</p>
<pre><code class="language-haskell">def sum(ls):
    if len(ls) == 0:
        return 0
    return ls[0] + sum(ls[1:])
</code></pre>
<p>Haskell is very similar (<code>head</code> is a function that returns the
first element of a list, and <code>tail</code> is a function that returns
the remainder of a list):</p>
<pre><code class="language-haskell">sum' ls = 
    if length ls == 0 then 
        0
    else 
        head ls ++ sum' (tail ls)
</code></pre>
<p>As a quick aside, the <code>:</code> operator is really a constructor for
lists, so in fact we can use pattern matching (again, we will discuss
this in the future) to define the <code>sum'</code> function very
elegantly.</p>
<pre><code class="language-haskell">sum' [] = 0
sum' (x : xs) = x + sum' xs
</code></pre>
<p>Python also supports <em>list comprehension</em> as you may recall:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = [1, 2, 3]
&gt;&gt;&gt; y = 'abc'
&gt;&gt;&gt; [(i, j) for i in x for j in y if i % 2 == 1]
[(1, 'a'), (1, 'b'), (1, 'c'), (3, 'a'), (3, 'b'), (3, 'c')]
</code></pre>
<p>Haskell also provides the same facility, with different syntax:</p>
<pre><code class="language-haskell">ghci&gt; x = [1, 2, 3]
ghci&gt; y = "abc"
ghci&gt; [(i, j) | i &lt;- x, j &lt;- y, odd i]
[(1,'a'),(1,'b'),(1,'c'),(3,'a'),(3,'b'),(3,'c')]
</code></pre>
<p>At this junction it would be most appropriate to discuss tuples. Like
Python, the fields of a tuple can be of different types. However, tuples
in Haskell are <strong>not</strong> sequences. Tuples behave more like the product of
several types, as is usually the case in many domains.</p>
<p>As such, there are not many operations we can do on tuples. One of the
only special cases is pairs, which have functions to project each value:</p>
<pre><code class="language-haskell">ghci&gt; fst (1,"abc")
1
ghci&gt; snd (1,(2,[3,4,5]))
(2,[3,4,5])
ghci&gt; snd (snd (1,(2,[3,4,5])))
[3,4,5]
</code></pre>
<p>This should suffice for now. Now is your turn to try the exercises to
get you started on your functional programming journey!</p>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">1</sup>
<p>If you haven't realized, we show the Haskell shell with the prefix
<code>ghci&gt;</code>, and the Python shell having the prefix <code>&gt;&gt;&gt;</code>.</p>
</div>
<div class="footnote-definition" id="5"><sup class="footnote-definition-label">2</sup>
<p>Note that <code>:{</code> and <code>:}</code> are used only in GHCI to define blocks of
code, and are not part of Haskell.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises"><a class="header" href="#exercises">Exercises</a></h1>
<h4 id="question-1"><a class="header" href="#question-1">Question 1</a></h4>
<p>Without using GHCI, evaluate the results of
the following expressions:</p>
<ol>
<li>
<p><code>3 * 4 + 5</code></p>
</li>
<li>
<p><code>3 + 4 * 5</code></p>
</li>
<li>
<p><code>5 ^ 3 `mod` 4</code></p>
</li>
<li>
<p><code>97 / 4</code></p>
</li>
<li>
<p><code>97 `div` 4</code></p>
</li>
<li>
<p><code>if (let x = 3 in x + 3) /= 5 &amp;&amp; 3 &lt; 4 then 1 else 2</code></p>
</li>
<li>
<p><code>not otherwise</code></p>
</li>
<li>
<p><code>fst (0, 1, 2)</code></p>
</li>
<li>
<p><code>succ (1 / 2)</code></p>
</li>
<li>
<p><code>sqrt 2</code></p>
</li>
<li>
<p><code>1 `elem` [1, 2, 3]</code></p>
</li>
<li>
<p><code>let f x = x + 1; g x = x * 2 in (g . f) 1</code></p>
</li>
<li>
<p><code>[1, 2, 3] ++ [4, 5, 6]</code></p>
</li>
<li>
<p><code>head [1, 2, 3]</code></p>
</li>
<li>
<p><code>tail [1, 2, 3]</code></p>
</li>
<li>
<p><code>init [1, 2, 3]</code></p>
</li>
<li>
<p><code>[1, 2, 3] !! 0</code></p>
</li>
<li>
<p><code>null []</code></p>
</li>
<li>
<p><code>length [1, 2, 3]</code></p>
</li>
<li>
<p><code>drop 2 [1, 2, 3]</code></p>
</li>
<li>
<p><code>take 5 [-1..]</code></p>
</li>
<li>
<p><code>dropWhile even [2, 6, 4, 5, 1, 2, 3]</code></p>
</li>
<li>
<p><code>sum [fst x | x &lt;- [(i, j) | i &lt;- [1..4], j &lt;- [-1..1]]]</code></p>
</li>
</ol>
<h4 id="question-2"><a class="header" href="#question-2">Question 2</a></h4>
<p>Write a function <code>eqLast</code> that
receives two nonempty lists and checks whether the last element of both
are the same. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; eqLast [1,2,3] [4,5]
False
ghci&gt; eqLast "ac" "dc"
True
</code></pre>
<h4 id="question-3"><a class="header" href="#question-3">Question 3</a></h4>
<p>A palindrome is a word that reads the same forward or backward. Write a function <code>isPalindrome</code> that checks if a string is a palindrome. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; isPalindrome "a"
True
ghci&gt; isPalindrome "bcde"
False
ghci&gt; isPalindrome "racecar"
True
</code></pre>
<h4 id="question-4"><a class="header" href="#question-4">Question 4</a></h4>
<p>You are writing a function to
determine the cost of a ride. The cost of a ride is determined by
$f + rd$ where $f$ is the flag down fare, $r$ is the per km rate of the
ride and $d$ is the distance of the ride in km. Write a function
<code>taxiFare</code> that receives $f$, $r$ and $d$ and computes the
total cost. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; grab = taxiFare 3 0.5
ghci&gt; gojek = taxiFare 2.5 0.6
ghci&gt; grab 3
4.5
ghci&gt; gojek 3
4.3
ghci&gt; grab 10
8.0
ghci&gt; gojek 10
8.5
</code></pre>
<h4 id="question-5"><a class="header" href="#question-5">Question 5</a></h4>
<p>Nowadays, we can customize the
food that we order. For example, you can order your burger with extra or
no cheese. In this exercise, write a function that takes a string as the
customization and compute the price for burgers with the code names for
the customization. You are given the price list for ingredients:</p>
<div class="table-wrapper"><table><thead><tr><th>Ingredient</th><th>Price</th></tr></thead><tbody>
<tr><td>B for bun</td><td>$0.50</td></tr>
<tr><td>C for cheese</td><td>$0.80</td></tr>
<tr><td>P for patty</td><td>$1.50</td></tr>
<tr><td>V for veggies</td><td>$0.70</td></tr>
<tr><td>O for onions</td><td>$0.40</td></tr>
<tr><td>M for mushrooms</td><td>$0.90</td></tr>
</tbody></table>
</div>
<p>Write a function <code>burgerPrice</code> that takes in a burger and
returns the price of the burger. While doing so, define an auxilliary
function <code>ingredientPrice</code> that receives a single ingredient
(as a character) and returns its price. Define
<code>ingredientPrice</code> as part of <code>burgerPrice</code> using a
<code>where</code> binding. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; burgerPrice "BVPB"
3.2
ghci&gt; burgerPrice "BVPCOMB"
5.3
</code></pre>
<h4 id="question-6"><a class="header" href="#question-6">Question 6</a></h4>
<p>Write a function
<code>sumDigits</code> that receives a nonnegative integer and gives the
sum of its digits. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; sumDigits 123
6
ghci&gt; sumDigits 12356
17
</code></pre>
<h4 id="question-7"><a class="header" href="#question-7">Question 7</a></h4>
<p>Write a function <code>@:</code> that
receives a list and a tuple of two values <code>(start, stop)</code>, and
performs list slicing with indices starting from <code>start</code> and ending at
(and excluding) <code>stop</code>. The step size is 1. Assume that both the start
and stop values are nonnegative integers. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; [1, 2, 3] @: (1, 4)
[2,3]
ghci&gt; [1, 2, 3] @: (4, 1)
[]
ghci&gt; [1, 2, 3] @: (0,1)
[1]
ghci&gt; [1, 2, 3] @: (1,67)
[2,3]
</code></pre>
<p>Syntactically, the way to define this function might be the following:</p>
<pre><code class="language-haskell">ls @: (start, stop) = your implementation here
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ch:types"><a class="header" href="#ch:types">Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-systems"><a class="header" href="#type-systems">Type Systems</a></h1>
<p>As the course title suggests, Haskell is a typed functional programming
languagein particular, it uses a statically-typed <em>type system</em>. This
begs the question, "what is a type system?"</p>
<p>An online search for definitions might give you the following:</p>
<blockquote>
<p><strong>Definition (Type System)</strong>. A type system is a
<strong>tractable syntactic method</strong> for <strong>proving the absence of certain
program behaviours</strong> by classifying phrases according to the <strong>kinds of
values they compute</strong>.</p>
</blockquote>
<p>Let us unpack the highlighted phrases in the definition above.</p>
<h4 id="tractable-syntactic-method"><a class="header" href="#tractable-syntactic-method">Tractable syntactic method</a></h4>
<p><em>Tractable</em> more or less means <em>easy</em>, or <em>polynomial time</em>. <em>Method</em>
refers to a <em>formal method</em>, which means it is a kind of mathematically
formal process. The fact that it is a <em>syntactic method</em> means that this
formal analysis can be done syntactically, without the need to appeal to
a <em>semantic</em> analysis (although, static type checking is done against
the static semantics of the type system). More or less, it can be
performed without executing any of the code it is analyzing.</p>
<h4 id="proving-the-absence-of-certain-program-behaviours"><a class="header" href="#proving-the-absence-of-certain-program-behaviours">Proving the absence of certain program behaviours</a></h4>
<p>In the case of type systems, this usually means that the type system is
used to prove the absence of type errors. The realm of program analysis
is broken down into roughly two kinds: over-approximation analyses, and
under-approximation analyses. Notice that both perform <em>approximations</em>
of program behaviourthis is because obtaining a precise specification of
any program is <em>undecidable</em>. Generally, static analyses, like type
checking, perform an over-approximation of program behaviour. An analogy
of how this works is as follows: assume true program behaviour is \(x\)
and buggy behaviour is at \(y\) (these are all positive numbers, let's
say). We then over-approximate the true program behaviour, giving us
\(x + \epsilon\). If we can show that \(x + \epsilon &lt; y\), then we can
guarantee that \(x &lt; y\).</p>
<p>A more concrete example is as follows. Let's suppose we have the following code snippet in Python:</p>
<pre><code class="language-python">y: int = 0 if f() else 'abc'
print(y + 1)
</code></pre>
<p>Notice that if we can determine that <code>f</code> always returns
<code>True</code>, then we know for sure that there will be no type
errors. However, it is not possible to make this determination in
general. Thus, we over-approximate program behaviour by assuming that it
is possible that <code>f</code> may return either <code>True</code> or
<code>False</code>leading us to show that we cannot prove the absence of
type errors in this program. Instead, if we had written the following:</p>
<pre><code class="language-python">y: int = 0 if f() else 1
print(y + 1)
</code></pre>
<p>Then even by assuming that both branches of the conditional expression
may be the result, we can conclusively show that <code>y</code> will
always be an <code>int</code>. Our over-approximation of program behaviour
doesn't have type errors, meaning, that our actual program really does
not have type errors.
:::</p>
<h4 id="kinds-of-values-they-compute"><a class="header" href="#kinds-of-values-they-compute">Kinds of values they compute</a></h4>
<p>This is a simple description of what <em>types</em> are. Types, as we will
informally define later, are classifications of data/things in the
program that all behave similarly or have similar characteristics. In
some other sense, types can be seen as abstractions over terms.</p>
<p>Simply put, a type system is a formal system that lets us show that
there won't be type errors. As we have seen, the nature of
[statically-typed] type systems forces us to program in a different
way (at least compared to dynamically typed languages like Python), and
this is what we will explore in this lecture.</p>
<h2 id="types-1"><a class="header" href="#types-1">Types</a></h2>
<p>Type systems are systems of types; but <em>what is a type</em>? In essence, a
type is like a <em>kind</em> of thing, or a high-level description of what
something is. Types (1) give meaning to some data, and (2) describe what
its members are like.</p>
<p>Since you have already programmed in Python, you should have some
inkling of what types are. In Python, everything is an object. Thus, in
Python, the type of an object is the <em>class</em> from which it was
instantiated.</p>
<p>Some sample output showing the types of various objects. The output of
all these function calls are classes.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; x = 1
&gt;&gt;&gt; type(x)
&lt;class 'int'&gt;
&gt;&gt;&gt; type('abc')
&lt;class 'str'&gt;
&gt;&gt;&gt; class A: pass
&gt;&gt;&gt; type(A())
&lt;class '__main__.A'&gt;
</code></pre>
<p>This is very apt—classes are blueprints for creating objects, and (for
the most part), all <em>instances</em> of a class will abide by the
specification as laid out in the class. Therefore, Python's type system
based on classes is very appropriate for our purposes. In fact, this is
not unique to Python. Many other languages with OO features also have
classes as types.</p>
<p>In Python, we mainly think of types as being bound to <em>objects</em>, that
is, objects have <em>reified</em> types that can be accessed at runtime. We
have never thought of assigning types to variables or function
parameters, since when we are investigating the type of a variable, what
we are really doing is investigating the type of the object that is
referred to by the variable. However, Python actually does allow us to
annotate variables, function parameters etc with types to document
"suggestions" as to what the types of the objects assigned to them
should be.</p>
<p>Observe the following program fragment.</p>
<pre><code class="language-python"># Python
def f(x: int) -&gt; str:
    y: int = x * 2
    return f'{x} * 2 = {y}'
z: int
z = 3
s: str = f(z)
print(s) # 3 * 2 = 6
</code></pre>
<p>This program fragment contains several <em>type annotations</em>. In the
function header, we have a specification for <code>f</code> to receive an
<code>int</code> and return a <code>str</code>. That is, if the type
annotations make sense, then passing an <code>int</code> into <code>f</code>
will always result in a <code>str</code>. In the function body, we also
have an annotation for the variable <code>y</code> stating that it is also
an <code>int</code>. This makes senseif <code>x</code> is an <code>int</code>,
then so will <code>x * 2</code>. Actually, the type of <code>y</code> can be
<em>inferred</em> (a type checker can determine the type of <code>y</code>
automatically), so our type annotation for it is not necessary. Outside
the function body we have other type annotations, documenting what the
types of the other variables are. On visual inspection, we can see that
all the type annotations make sense and we have adhered to them fully;
we are thus guaranteed that we have no type errors.</p>
<p>While Haskell also provides the capability for type annotations, a
notable distinction lies in Haskell's <em>enforcement</em> of adherence to
these annotations. Consequently, it might be more fitting to refer to
them as <em>type declarations</em>. Nevertheless, the core concept remains
unchanged: specifying the types of variables, functions, or terms
ensures that, when adhered to correctly, our program will be well-typed.</p>
<p>The following code snippet shows some Haskell code with type
declarations.</p>
<pre><code class="language-haskell">f :: Int -&gt; String
f x = show x ++ " * 2 = " ++ show y
    where y = x * 2
z :: Int
z = 3
s :: String
s = f(z) -- 3 * 2 = 6
</code></pre>
<p>A natural question would be to ask, what types can we declare variables
to be of? We have looked at some basic types earlier, <code>Int</code>,
<code>String</code> (which is an alias for <code>[Char]</code>),
<code>Char</code>, <code>[Int]</code>, <code>Bool</code>,
<code>Double</code> etc. There are many other types in Haskell's Prelude,
and later on we will see how we can create our own types.</p>
<p>Declaring types for functions is slightly different. In Python, when
writing type annotations for functions, we are really annotating the
types of its parameters, and its return type. In Haskell, we are
declaring the type of the function itself. The difference is actually
not as large as one might imagine. If the function receives a type \(S\)
and returns a type \(T\), then the function has the type \(S\to T\). We
similarly use arrows to declare the type of functions in Haskell. Thus,
as above, since <code>f</code> receives an <code>Int</code> and returns a
<code>String</code>, then <code>f</code> itself is of the type
<code>Int -&gt; String</code>.</p>
<p>Haskell has roots in formal systems, in particular, System \(F_C\), which
is a dialect of System \(F\omega\) (without type lambdas). Thus, the types
of terms can be described formally. Knowing the formal typing rules of
Haskell is not required, but may give you some insight as to how it
works. Below we show the typing rules for function declarationmore
specifically, lambda abstraction.</p>
<p>\[\frac{\Gamma,x:S\vdash e: T}{\Gamma\vdash\lambda x.e : S \to T}\text{T-Abs}\]</p>
<p>The T-Abs rule is an <em>inference rule</em> stating that if the
premise above the line is true, then the conclusion below the line will
also be true. Let's first parse the premise. The part to the left of
$\vdash$ is the <em>typing environment</em>, more or less describing the type
declarations we have at the point of analysis of the program.
Specifically, $\Gamma$ is the actual type environment, while $x: S$ is
an additional assumption that a variable $x$ has type $S$. The part to
the right of $\vdash$ describes the judgement of the type of $e$ being
$T$. Overall, the premise states "given what we have so far, if in
assuming $x$ is of type $S$ we get that $e$ is of type $T$, ...". The
conclusion can be understood similarly: it states that the typing
environment $\Gamma$ will show that the function $\lambda x.e$ has type
$S \to T$. Putting these together, the rule states that "given typing
environment $\Gamma$, if by assuming that variable $x$ has type $S$ we
get that the expression $e$ is of type $T$, then $\Gamma$ will also show
that the type of the function $\lambda x.e$ is of type $S \to T$".</p>
<p>::: example
A simple demonstration in Python is as follows: suppose we have $x$ as
<code>x</code> and $e$ as <code>x * 2</code>. If we assume that <code>x</code>
is of type <code>int</code>, then we know that <code>x * 2</code> will also
be an <code>int</code>. Therefore, the type of $\lambda x.e$ which is
<code>lambda x: x * 2</code> is <code>int -&gt; int</code>[^1].
:::</p>
<p>What about multi-parameter functions? Remember that in Haskell, all
functions are curried, thus, all functions in Haskell are single
parameter functions. Curried functions receive one parameter, and return
a function <em>closure</em> that receives the remaining variables and
eventually will return the final result. Therefore the <code>(+)</code>
function actually looks more like:</p>
<pre><code class="language-python"># Python
def add(x):
    return lambda y: x + y
</code></pre>
<p>The type of <code>add</code> is more like <code>int -&gt; (int -&gt; int)</code>.
This is (more or less) the type of <code>(+)</code> in Haskell, which
(more or less) has type <code>Int -&gt; Int -&gt; Int</code>. Note that
<code>-&gt;</code> is right-associative, so <code>Int -&gt; Int -&gt; Int</code> is
the same as <code>Int -&gt; (Int -&gt; Int)</code>.</p>
<p>In Haskell, the types of everything is <strong>fixed</strong>. This should be
unsurprising since everything in Haskell is immutable, but it is a
restriction that can also be found in other less restrictive languages
like Java and C++. In this environment, we have to, perhaps ahead of
time, decide what the type of a variable, function, function parameter
is, then write the implementation of your function around those
restrictions.</p>
<p>::: example
[]{#eg:inferredtypeofg label="eg:inferredtypeofg"} The following code
snippet first <em>declares</em> the type of <code>f</code> before showing its
implementation. It is not only good practice to declare types above
their implementation, but it can be a nice way to frame your mind around
the implementation of your functionstart by providing a high-level
specification of your function, then work on the implementation to
describe what the function is actually trying to achieve.</p>
<pre><code class="language-haskell">f :: Int -&gt; String -- explicit type declaration
f x = show x ++ "!"
g x = x + 1 -- type of g is inferred
</code></pre>
<p>However, observe that the type of <code>g</code> is not defined. This
does not mean that the type of <code>g</code> is dynamic or is not being
checked; rather, Haskell can infer the <em>principal</em> (most liberal) type
of <code>g</code> via a process known as <em>type inference</em>. That still
means that the implementation of <code>g</code> itself must be well-typed
(its implementation does not break any of the typing rules), and that
any users of <code>g</code> must abide by its static type signature.
:::</p>
<p>Generally speaking, it is good practice to declare the types of
top-level bindingsthat is, nested bindings of functions, variables (for
example, in <code>let</code> expressions) do not need type declarations
and can often be inferred. The example above of the declaration of
<code>f</code> is a perfectly idiomatic way of defining and declaring a
function, unlike <code>g</code> which lacks a type declaration.</p>
<h3 id="programming-with-types"><a class="header" href="#programming-with-types">Programming with Types</a></h3>
<p>When learning Python, you might not have had to think very much about
types; this is because Python does not care about type annotations. For
example, you can happily annotate a variable to be an <code>int</code> but
then assign a string into it. This is very much unlike Haskell, where
adherence to type declarations and well-typedness is <em>enforced</em> by the
compilerthe compiler will reject any program that is not well-typed.</p>
<p>::: example
Observe the following program fragment:</p>
<pre><code class="language-haskell">f :: Int -&gt; String -- explicit type declaration
f x = show x ++ "!"
 
g = f "1" -- compiler throws type error as f receives Int, not String
</code></pre>
<p>The definition of <code>f</code> is well-typed since it abides by all the
typing rules, and all the types make sense. However, since <code>f</code>
only receives <code>Int</code>, passing a <code>String</code> into it is a
clear violation of the rules. Thus, the entire program is ill-typed and
will not be compiled. Try this for yourself!
:::</p>
<p>Programming in such a strict and formal language can feel restrictive,
but these restrictions actually feel more like "guard rails" or
"seatbelts"; if your program passes the checks done by the compiler, you
can be quite assured that it works. As the saying goes, in Haskell, "if
it compiles, it works". Although this is not necessarily true,
Haskell's robust and expressive type system allows you to rule out a
large class of bugs, and often, results in correct programs. However,
one question to ask is: how do we go about programming with static
types?</p>
<p>The first step of being able to program with types is understanding the
typing rules. We shall elide explanation on how typing works with
inference, typeclasses, polymorphism and etc. and focus solely on the
simplest typing rules:</p>
<ol>
<li>
<p>In a binding <code>x = e</code>, the type of <code>x</code> must be
the same as the type of <code>e</code></p>
</li>
<li>
<p>In a conditional expression <code>if x then y else z</code>, the type
of <code>x</code> must be <code>Bool</code> and the types of
<code>y</code> and <code>z</code> must both be equal to some type
<code>a</code>; the type of the entire expression is <code>a</code></p>
</li>
<li>
<p>In a function application expression <code>f x</code> the type of
<code>f</code> must be <code>a -&gt; b</code> for some <code>a</code> and
<code>b</code>, <code>x</code> must be of type <code>a</code>, and the
type of the expression is <code>b</code></p>
</li>
<li>
<p>(Without loss of generality of number of parameters) For a function
binding <code>f x = e</code> the type of <code>f</code> must be
<code>a -&gt; b</code> for some <code>a</code> and <code>b</code> and in
assuming <code>x</code> to be of type <code>a</code>, <code>e</code>
must be of type <code>b</code>.</p>
</li>
</ol>
<p>::: example
Try calculating the types of every expression in the following code
snippet. Can you get it all right?</p>
<pre><code class="language-haskell">f :: Int -&gt; Int -&gt; [Int]
f x n =
  if n == 0 then
    []
  else
    let r = f x (n - 1)
    in  x : r
</code></pre>
<p>Let's work through this example. We are declaring <code>f</code> to be of
type <code>Int -&gt; Int -&gt; [Int]</code>, so it stands to reason that in the
definition of <code>f</code> we are assuming that <code>x</code> and
<code>n</code> are both of type <code>Int</code>. For this to be
well-typed, we must ensure that the conditional expression evaluates to
<code>[Int]</code>, that means both branches must themselves evaluate to
<code>[Int]</code>. First we observe the condition <code>n == 0</code>;
the <code>(==)</code> function receives two numbers and returns a
<code>Bool</code>, so this is well-typed. Looking at the <code>True</code>
branch, we see that we are returning the empty list, which matches the
type of <code>[Int]</code>. In the <code>False</code> branch, we have a
<code>let</code> expression, so we must ensure that <code>x : r</code>
evaluates to <code>[Int]</code> too. The <code>let</code> binding contains
a binding <code>r = f x (n - 1)</code>; knowing that (by our own
declaration) <code>f</code> has type <code>Int -&gt; Int -&gt; [Int]</code>,
knowing that <code>x</code> and <code>n - 1</code> are of type
<code>Int</code> means we can safely conclude that <code>r</code> has type
<code>[Int]</code> (of course, the <code>(-)</code> function receives two
integers and returns an integer). The <code>(:)</code> function receives
an <code>Int</code> and a <code>[Int]</code> and returns a
<code>[Int]</code>, so all the types match. Overall, we have seen that we
successfully determined the types of every expression in the program
fragment, and concluded that it is well-typed.
:::</p>
<p>Now that you are familiar with the basic typing rules and how (roughly)
types are inferred, the next step is to get comfortable writing programs
with static types. Generally this comes with practice, but one great way
to get you started with typeful programming is to try letting the types
guide your programming.</p>
<p>::: example
[]{#eg:programmingbytypessimple label="eg:programmingbytypessimple"}
Suppose we are trying to define a function <code>f</code> that receives
an integer <code>x</code> and returns a string showing the result of
multiplying <code>x</code> by 2:</p>
<pre><code class="language-haskell">ghci&gt; f 3
"3 * 2 = 6"
ghci&gt; f 5
"5 * 2 = 10"
</code></pre>
<p>Let us try implementing this function. The first thing we have to
consider is the type of <code>f</code> itself, which by definition,
should receive an <code>Int</code> and return a <code>String</code>. As
such, we may start with the type declaration
<code>f :: Int -&gt; String</code>.<br />
Next, we know we are eventually going to have to convert <code>x</code>
into a <code>String</code>. We know that there is a <code>show</code>
function that does that. Its type signature (modified) is
<code>Int -&gt; String</code>, so we know that <code>show x</code> is a
<code>String</code>.<br />
We also know that we need to multiply <code>x</code> by 2. For this, we
can use the <code>(*)</code> function, which has a (modified) type
signature of <code>Int -&gt; Int -&gt; Int</code>. Thus, we can write
<code>x * 2</code> and that gives us an <code>Int</code>. Knowing that we
eventually need to display it as a <code>String</code>, once again, we
can rely on the <code>show</code> function.<br />
Now we have all the numbers we need in <code>String</code> form, we need
to concatenate them together. For this, we can rely on our trusty
<code>(++)</code> function that receives two <code>String</code> and
returns a <code>String</code>. Using this allows us to concatenate all
our desired strings together. Since our original function <code>f</code>
was meant to return a <code>String</code>, we can return it as our final
result.</p>
<pre><code class="language-haskell">f :: Int -&gt; String
f x = 
  let sx :: String = show x
      y  :: Int    = x * 2
      sy :: String = show y
  in  sx ++ " * 2 = " ++ sy
</code></pre>
<p>:::</p>
<p><a href="types/sections/type_systems.html#eg:programmingbytypessimple">[eg:programmingbytypessimple]</a>{reference-type="autoref"
reference="eg:programmingbytypessimple"} is a simple example of using
types to guide your programming. While seemingly trivial, this skill can
be incredibly useful for defining recursive functions!</p>
<p>::: example
Suppose we are trying to define a function that sums the integers in a
list. Let us attempt to define this function recursively.<br />
As always, we must decide what the type of this function is. As per our
definition, it receives a list of integers and returns the final sum,
which should be an integer as well. This gives us the type declaration
<code>sum' :: [Int] -&gt; Int</code>.<br />
First, let us define the base case. We should be quite clear on what the
condition for the base case: it should be when the input list is empty.
What should we return in the base case? By our type declaration, we must
return an <code>Int</code>, so we must express our base result in that
type. The result is <code>0</code>, which matches our type declaration.<br />
Next we must define the recursive case. This one might be tricky
initially. We know that we can make our recursive call, passing in the
tail of the input list. This might look something like
<code>sum' (tail ls)</code>. We must be very clear about the type of this
expression; as per the type declaration, the result is an
<code>Int</code>, and not anything else.<br />
We also know that we want to add the head of the input list to the
result of the recursive call. In doing so we get an <code>Int</code>.<br />
Finally, we can sum the results together, giving us an <code>Int</code>,
which matches our return type.</p>
<pre><code class="language-haskell">sum' :: [Int] -&gt; Int
sum' ls = 
    if null ls then
      0
    else
      let r  :: Int = sum' (tail ls)
          hd :: Int = head ls
      in  hd + r
</code></pre>
<p>:::</p>
<p>By getting used to types, having a statically-typed system no longer
feels like a chore or a hurdle to cross, and instead feels like a
support system that makes everything you are doing clear! Many
developers (including myself) love statically-typed programming
languages for this very reason, so much so that people have gone to
great lengths to add static typing to otherwise dynamically typed
languages like JavaScript.</p>
<p>Python is no different. Several static type checkers are out there to
help us analyze the well-typedness of our program. One of the most
popular analyzers is mypy, which was heavily developed by Dropbox.
However, I recommend pyright because at the time of writing, it has
implemented bleeding edge features that we need for further discussion
of types which we shall see very shortly.</p>
<p>Let's try to see if pyright works correctly. Let's write an ill-typed
program and see if it catches the potential bug:</p>
<pre><code class="language-python"># main.py
def f(x: int, y: int) -&gt; int:
    z = x / y
    return z
</code></pre>
<pre><code>pyright main.py
/home/main.py
  /home/main.py:4:12 - error:
    Expression of type "float" is incompatible with return
    type "int"
    "float" is incompatible with "int" (reportReturnType)
1 error, 0 warnings, 0 informations 
</code></pre>
<p>Great! This makes sense because assuming <code>x</code> and <code>y</code>
are of type <code>int</code>, the type of <code>z</code> should actually be
<code>float</code>! Let's correct the program and try running pyright
against it:</p>
<pre><code class="language-python"># main.py
def f(x: int, y: int) -&gt; int:
    z = x // y
    return z
</code></pre>
<pre><code>pyright main.py
0 errors, 0 warnings, 0 informations
</code></pre>
<p>Very well! We have now learnt how to program with types in Haskell and
in Python, and since Python does not come with a type-checker, we are
able to use tools like pyright to do the type checking for us!</p>
<p>One additional great feature about pyright is that it is actually also a
language server. As such, you can include pyright in your favourite text
editors so that it can catch bugs while writing programs!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sec:polymorphism"><a class="header" href="#sec:polymorphism">Polymorphism</a></h1>
<p>In FP, functions describe computation and applying functions perform
said computation. For example, given a function $f$:
$$f(x) = x \times 2$$ $f$ describes what computation is to be done
(multiplying the parameter by 2), and applying $f$ onto a value (such as
$f(2)$) performs the computation that gives the result, which is $4$.
Importantly, you might also find that applying it onto a different input
may give you a different outcome. In this case, $f(2)=4\neq f(3)=6$. The
output depends on the input, i.e. we have <em>terms that depend on terms</em>.
This may at first glance seem like a trivial observation because that is
what functions are designed to do: if functions are always constant like
$g(x) = 1$ then we can always replace all applications of the function
with the result and no computation needs to be done.</p>
<p>However, now that we have learnt about types, we get a much more
interesting avenue for extending this idea of dependence. In fact, we
now have three orthogonal directions to explore[^2]:</p>
<ol>
<li>
<p>Can terms depend on types?</p>
</li>
<li>
<p>Can types depend on types?</p>
</li>
<li>
<p>Can types depend on terms?</p>
</li>
</ol>
<p>The answer to the first two questions is yes! This phenomenon is known
as [parametric] <em>polymorphism</em>, i.e. where types and terms can depend
on types[^3].</p>
<h3 id="polymorphic-types"><a class="header" href="#polymorphic-types">Polymorphic Types</a></h3>
<p>Let us motivate this need with an example. Suppose we are trying to
create a wrapper class called <code>Box</code>{.python}, that contains a single
value. As per usual, we have to think about the type of the value it
contains. At this point we cannot simply allow the value to be
<em>anything</em>, so we shall fix the type of the value to something, say,
<code>int</code>{.python}.</p>
<pre><code class="language-python"># Python
@dataclass
class IntBox:
    value: int
</code></pre>
<p>However, we may later want a <code>Box</code>{.python} that stores strings. In this
case, we will have to define a new class that does so.</p>
<pre><code class="language-python"># Python
@dataclass
class StrBox:
    value: str
</code></pre>
<p>Recall one of the core principles in programming: whenever you see a
pattern in your code, <em>retain similarities</em> and <em>parameterize</em>
differences. Looking at the two <code>Box</code> implementations, you should be
able to see that the implementation is virtually identical, and the only
difference is the <em>type</em> of <code>value</code>. We have previously been able to
parameterize values (regular function parameters), parameterize
behaviour (higher-order functions), however, can we parameterize
<em>types</em>?</p>
<p>Yes! We can define <code>Box</code> to receive a <em>type parameter</em> <code>a</code>, and allow
the value in the box to be of that type <code>a</code>[^4].</p>
<pre><code class="language-python"># Python 3.12
@dataclass
class Box[a]:
    value: a
</code></pre>
<p>This class is a generalized <code>Box</code> class that can be <em>specialized</em> into a
specific <code>Box</code>. For example, by replacing <code>a</code> with <code>int</code>{.python} then
we recover our <code>IntBox</code>{.python} class with an <code>int</code>{.python} value;
replacing <code>a</code> with <code>str</code>{.python} recovers our <code>StrBox</code>{.python} class
with a <code>str</code>{.python} value.</p>
<pre><code class="language-python">x: Box[int] = Box[int](1)
y: Box[str] = Box[str]('a')
z: Box[Box[int]] = Box(Box(1))
bad: Box[int] = Box[int]('a')
</code></pre>
<p>In Python and many Object-Oriented languages, <code>Box</code> is called a
<em>generic</em> or <em>parametrically polymorphic</em> class/type. This is one
example of a <em>type depending on a type</em>.</p>
<h3 id="polymorphic-functions"><a class="header" href="#polymorphic-functions">Polymorphic Functions</a></h3>
<p>The same principle can be applied to <em>terms depending on types</em>. Suppose
we have a function <code>singleton</code> that is to receive an object and puts
that object in a list. In the same vein, we have to decide what the type
of the parameter is, which dictates the corresponding return type. For
example, may define this function that works on <code>int</code>{.python}s, and
separately, another function that works on <code>str</code>{.python}s:</p>
<pre><code class="language-python"># Python 3.12
def singleton_int(x: int) -&gt; list[int]:
    return [x]
def singleton_str(x: str) -&gt; list[str]:
    return [x]
</code></pre>
<p>Once again, we can observe that the implementations of these functions
are identical, and only the types are different. Let us combine these
implementations into a single function where the types are
parameterized!</p>
<pre><code class="language-python"># Python 3.12
def singleton[a](x: a) -&gt; list[a]:
    return [x]
x: list[int] = singleton(1)
y: list[str] = singleton('a')
bad: list[bool] = singleton(2)
</code></pre>
<p><code>singleton</code> is what is known as a polymorphic function, where the
function depends on the type!</p>
<h3 id="polymorphic-functions-in-haskell"><a class="header" href="#polymorphic-functions-in-haskell">Polymorphic Functions in Haskell</a></h3>
<p>How would we define the type of polymorphic functions in Haskell? That
is pretty straightforward: type parameters are lowercase. For example,
the <code>singleton</code> function can be defined like so:</p>
<pre><code class="language-haskell">singleton :: a -&gt; [a]
singleton x = [x]
</code></pre>
<p>In fact we can see the type signatures of some built-in polymorphic
functions:</p>
<pre><code class="language-haskell">ghci&gt; :t head
head :: [a] -&gt; a
ghci&gt; :t (.)
(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</code></pre>
<p>Not sure what the type parameters are? Or, want to make your type
parameters explicit? We can use <code>forall</code>{.haskell} to introduce a
polymorphic function type, with the variables succeeding
<code>forall</code>{.haskell} being the type parameters to the function.</p>
<pre><code class="language-haskell">ghci&gt; :set -fprint-explicit-foralls
ghci&gt; :t head
head :: forall a. [a] -&gt; a
ghci&gt; :t (.)
(.) :: forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
ghci&gt; :{
ghci| singleton :: forall a. a -&gt; [a]
ghci| singleton x = [x]
ghci| :}
ghci&gt; singleton 2
[2]
ghci&gt; singleton 'a'
"a"
</code></pre>
<p>Let's inspect the type signature of <code>(.)</code>{.haskell}. Recall that this
function performs function composition; the implementation of
<code>(.)</code>{.haskell} might look something like this:</p>
<pre><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
(.) g f x = g (f x)
</code></pre>
<p>We have three terms, <code>g</code>, <code>f</code> and <code>x</code>. We know that <code>g</code> and <code>f</code> must be
functions since we are calling them, thus we are going to let the types
of <code>g</code> and <code>f</code> to be <code>d -&gt; c</code>{.haskell} and <code>a -&gt; b</code>{.haskell}
respectively. Additionally, <code>x</code> is just some other term, and we will let
its type be <code>e</code>. Thus for now, we shall let the type signature of
<code>(.)</code>{.haskell} be the following, assuming the return type ultimately
becomes <code>r</code>:</p>
<pre><code class="language-haskell">(.) :: (d -&gt; c) -&gt; (a -&gt; b) -&gt; e -&gt; r
(.) g f x = g (f x)
</code></pre>
<p>Now notice the following: for <code>f x</code>{.haskell} to be well-typed, the type
of <code>x</code> must be the same as the type of the parameter to <code>f</code>, which is
<code>a</code>. Thus, more accurately, <code>x</code> must be of type <code>a</code>:</p>
<pre><code class="language-haskell">(.) :: (d -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; r
(.) g f x = g (f x)
</code></pre>
<p>We can now see that <code>f x</code> is well-typed, and this expression is of type
<code>b</code>. We then pass this result into <code>g</code>. For this to be well-typed,
again, the parameter type of <code>g</code> must match the type of <code>f x</code>. Thus, <code>g</code>
must actually be of type <code>b -&gt; c</code>{.haskell}:</p>
<pre><code class="language-haskell">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; r
(.) g f x = g (f x)
</code></pre>
<p>Finally, <code>g (f x)</code> has type <code>c</code>, which is what is returned from the
function. As such, the return type of <code>(.) g f x</code>{.haskell} should also
be <code>c</code>. This recovers the correct type signature shown by GHCI.</p>
<p>::: remark
You might be surprised to know that the process of recovering or
reconstructing the types is known as type inference, which as stated in
earlier chapters, is also done by GHC! When you omit the type signature
of any binding, GHC goes through this same process and helps us
determine what the type of that binding is.
:::</p>
<h3 id="programming-with-polymorphic-typesfunctions"><a class="header" href="#programming-with-polymorphic-typesfunctions">Programming with Polymorphic Types/Functions</a></h3>
<p>When should we define polymorphic types or functions? As we have shown,
when the implementations of classes, data types, functions etc. are the
same except for the types, then we are able to parameterize the
differing types which makes the class/data type/function polymorphic!
Knowing immediately when to create polymorphic types/functions takes
some practice, so to start, just create specialized versions of those
types/functions, and as the need arises, make them polymorphic by
parameterizing the appropriate types.</p>
<p>::: example
[]{#eg:polymorphictypetree label="eg:polymorphictypetree"} Suppose we
are trying to create a <code>Tree</code> class that represents binary trees. Should
this class be polymorphic? For now, let's ignore this fact and proceed
to create a naive implementation of this class. Further suppose we are
expecting to create a tree of integers, so we shall let that be the type
of the values of our tree.</p>
<pre><code class="language-python">@dataclass
class IntTree:
    pass
@dataclass
class IntNode(IntTree):
    left: IntTree
    value: int
    right: IntTree
@dataclass
class IntLeaf(IntTree):
    value: int
</code></pre>
<p>Looks great! From this class we are able to create binary trees of
integers, for example, <code>IntNode(IntLeaf(1), 2, IntLeaf(3))</code>{.python}
gives a binary tree with preorder 2, 1 and 3.</p>
<p>Further suppose later on we need to store strings in a binary tree.
Again, let's naively implement a separate class that does so:</p>
<pre><code class="language-python">@dataclass
class StrTree:
    pass
@dataclass
class StrNode(StrTree):
    left: StrTree
    value: str
    right: StrTree
@dataclass
class StrLeaf(StrTree):
    value: str
</code></pre>
<p>Once again, notice that the implementations of the classes are
identical, and the only difference is in the types! This is one clear
example where we should make our class polymorphic!</p>
<pre><code class="language-python">@dataclass
class Tree[a]:
    pass
@dataclass
class Node[a](Tree[a]):
    left: Tree[a]
    value: a
    right: Tree[a]
@dataclass
class Leaf[a](Tree[a]):
    value: a
</code></pre>
<p>Now from this one class, we are able to create all kinds of trees!
:::</p>
<p>::: example
[]{#eg:polymorphicfunctionreverse label="eg:polymorphicfunctionreverse"}
Suppose we are trying to define a function that reverses a list. Once
again, we have to be specific with the type of this function.
Temporarily, we shall create a function that works on lists of integers:</p>
<pre><code class="language-python">def reverse_int(ls: list[int]) -&gt; list[int]:
    return [] if not ls else \
           reverse_int(ls[1:]) + [ls[0]]
</code></pre>
<p>Then, later on we might have to define a similar function that reverses
lists of strings:</p>
<pre><code class="language-python">def reverse_str(ls: list[str]) -&gt; list[str]:
    return [] if not ls else \
           reverse_str(ls[1:]) + [ls[0]]
</code></pre>
<p>Once again, we can see that the implementations of the two functions are
identical, and only the types are different. Make this function
polymorphic!</p>
<pre><code class="language-python">def reverse[a](ls: list[a]) -&gt; list[a]:
    return [] if not ls else \
           reverse(ls[1:]) + [ls[0]]
</code></pre>
<p>:::</p>
<p><a href="types/sections/polymorphism.html#eg:polymorphictypetree">[eg:polymorphictypetree]</a>{reference-type="autoref"
reference="eg:polymorphictypetree"} and
<a href="types/sections/polymorphism.html#eg:polymorphicfunctionreverse">[eg:polymorphicfunctionreverse]</a>{reference-type="autoref"
reference="eg:polymorphicfunctionreverse"} give us some scenarios where
we discover that we have to make a class or function polymorphic. More
importantly, we see that that the implementations across the specialized
versions of the class/function are equal, and only the types differ. One
key insight we can draw from this is: a class/function should be made
polymorphic if its implementation is <em>independent</em> of the type(s) it is
representing/acting on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="algebraic-data-types"><a class="header" href="#algebraic-data-types">Algebraic Data Types</a></h1>
<p>We have just seen different data types in Haskell, and introduced the
concept of polymorphic types as demonstrated by examples in Python. Yet,
we have not discussed how we can create our own (polymorphic) data types
in Haskell!</p>
<p>Haskell is a purely functional language, so do not expect classes here.
In OOP, objects have both data (attributes) and behaviour (methods),
whereas this is not necessarily a principle in FP (you can have data
types with functions as fields). We already know how to create
functions, so now we must investigate how we can create data types in a
purely functional language.</p>
<p>If we think about it carefully, we might notice that data types are a
mix of the following:</p>
<ul>
<li>
<p>A type <strong>and</strong> another type <strong>and</strong>...<strong>and</strong> yet another type</p>
</li>
<li>
<p>A type <strong>or</strong> another type <strong>or</strong>...<strong>or</strong> yet another type</p>
</li>
</ul>
<p>::: example
We can express the following types using <strong>and</strong> and <strong>or</strong> over other
types:</p>
<ul>
<li>
<p>A <code>Fraction</code> consists of a numerator (<code>Int</code>) <strong>and</strong> a denominator
(<code>Int</code>)</p>
</li>
<li>
<p>A <code>Student</code> consists of a name (<code>String</code>) and an ID (<code>Int</code>)</p>
</li>
<li>
<p>A <code>Bool</code> is either <code>True</code> <strong>or</strong> <code>False</code></p>
</li>
<li>
<p>A <code>String</code> is either an empty string <strong>or</strong> (a head character
(<code>Char</code>) <strong>and</strong> a tail list (<code>String</code>))</p>
</li>
<li>
<p>A polymorphic <code>Tree</code> is either (a leaf with a value of type <code>a</code>)
<strong>or</strong> (a node with a value (<code>a</code>) <strong>and</strong> a left subtree (<code>Tree a</code>)
<strong>and</strong> a right subtree (<code>Tree a</code>))
:::</p>
</li>
</ul>
<p>This formulation of data types as products (<strong>and</strong>) and/or sums
(<strong>sum</strong>) is what is known as Algebraic Data Types (not to be confused
with Abstract Data Types). In Haskell, types are <strong>sums</strong> of one or more
<strong>constructors</strong>; constructors are <strong>products</strong> of zero or more types.</p>
<p>::: example
To create a new data type in Haskell, we can use the <code>data</code>{.haskell}
keyword. Let us create a fraction type based on our algebraic
specification above:</p>
<pre><code class="language-haskell">data Fraction = Fraction Int Int

half :: Fraction
half = Fraction 1 2
</code></pre>
<p>On the left hand side we have the declaration of the type, and on the
right hand side, a list of constructors that help us create the type.
Note that the <code>Fraction</code>{.haskell} on the right hand side is the name of
the constructor of the type; it in fact can be distinct from the name of
the type itself (which is very helpful when you have more than one
constructor). As you can see, to construct a <code>Fraction</code>{.haskell}, the
<code>Fraction</code>{.haskell} constructor receives two <code>Int</code>{.haskell}s, one
numerator, and one denominator.<br />
Then, defining the student type from our algebraic formulation above
should also be straightforward:</p>
<pre><code class="language-haskell">data Student = S String Int

bob :: Student
bob = S "Bob" 123
</code></pre>
<p>Let us define the <code>Bool</code> type, which should have two constructors, each
constructor not having any fields:</p>
<pre><code class="language-haskell">data Bool = True | False

true, false :: Bool
true = True
false = False
</code></pre>
<p>To construct a <code>Bool</code>{.haskell} we can use either the <code>True</code>{.haskell}
constructor or the <code>False</code>{.haskell} constructor. Neither of these
constructors receive any other fields.<br />
We can also have multiple constructors, each being products of more than
zero types, as we shall see in the algebraic formulation of a
<code>String</code>{.haskell}:</p>
<pre><code class="language-haskell">data String = EmptyString | Node Char String

hello, empty :: String
hello = Node 'h' (Node 'e' (Node 'l' (Node 'l' (Node 'o' EmptyString))))
empty = EmptyString
</code></pre>
<p>:::</p>
<h3 id="polymorphic-algebraic-data-types"><a class="header" href="#polymorphic-algebraic-data-types">Polymorphic Algebraic Data Types</a></h3>
<p>Now we show examples of creating our own polymorphic data types. The way
we would do so is similar to how we defined generic/polymorphic classes
in Python.</p>
<p>::: example
Let us start from the bottom again by creating specialized versions of a
box type, this time in Haskell. We start by assuming that a box contains
an <code>Int</code>{.haskell}:</p>
<pre><code class="language-haskell">data IntBox = IB Int
b :: IntBox
b = IB 1
</code></pre>
<p>Then define a box that contains a <code>String</code>{.haskell}:</p>
<pre><code class="language-haskell">data StrBox = SB String
b :: StrBox
b = SB "123"
</code></pre>
<p>Again, they look more or less the same, except for the type of the
field. As such, we should allow <code>Box</code>{.haskell} to be polymorphic by
introducing a type parameter:</p>
<pre><code class="language-haskell">data Box a = B a
x :: Box Int
x = B 1
y :: Box String
y = B "123"
</code></pre>
<p>Perfect! Let us try more complex polymorphic algebraic data types like
linked lists and trees:</p>
<pre><code class="language-haskell">data LinkedList a = EmptyList | Node a (LinkedList a)
cat :: LinkedList Char
cat = Node 'c' (Node 'a' (Node 't' EmptyList))

data Tree a = Leaf a | TreeNode (Tree a) a (Tree a)
tree :: Tree Int
tree = TreeNode (Leaf 1) 2 (Leaf 3)
</code></pre>
<p>:::</p>
<p>Constructors are actually functions!</p>
<pre><code class="language-haskell">ghci&gt; data Fraction = F Int Int
ghci&gt; :t F
F :: Int -&gt; Int -&gt; Fraction
ghci&gt; :t F 1
F 1 :: Int -&gt; Fraction
ghci&gt; :t F 1 2
F 1 2 :: Fraction
</code></pre>
<p>We now have the facilities to define and construct data types and their
terms, but so far we are not able to <em>access</em> the fields of a data type
in Haskell. Unlike Python, we are not able to do something like
<code>x.numerator</code> to obtain the numerator of a fraction <code>x</code>, for example.
There are ways to define functions that do so and we will show them to
you in later sections, but for now, Haskell has <em>record syntax</em> that
automatically defines these accessor functions for us.</p>
<p>::: example
Let us re-create the <code>Student</code>{.haskell} type, this time using record
syntax to automatically derive functions that obtain their names and
IDs:</p>
<pre><code class="language-haskell">data Student = S { name :: String, id :: Int }
</code></pre>
<p>With this, we no longer need to define our own functions that access
these fields for us. Record syntax is great for giving names to fields!
Importantly, record syntax is nothing special, and we can continue to
create terms of those types by way of usual constructor application.</p>
<pre><code class="language-haskell">x, y :: Student
x = S { name = "Alice", id = 123 }
y = S "Bob" 456
</code></pre>
<p>Let's try loading this into GHCI and see the accessor functions in
action:</p>
<pre><code class="language-haskell">ghci&gt; name x
"Alice"
ghci&gt; id y
456
</code></pre>
<p>:::</p>
<p>We can even mix and match these different forms of constructor
definitions, or create large data structures!</p>
<pre><code class="language-haskell">data Department = D {name' :: String, courses :: [Course]}
data Course = C { code :: String, 
                  credits :: Int,
                  students :: [Student] }
data Student = UG { homeFac :: String,
                    name :: String,
                    id :: Int }
             | PG [String] String Int

alice   = UG "SoC" "Alice" 123
bob     = PG ["SoC", "YLLSoM"] "Bob" 456
it5100a = C "IT5100A" 2 [alice]
it5100b = C "IT5100B" 2 [alice, bob]
cs      = D "Computer Science" [it5100a, it5100b]
</code></pre>
<h3 id="more-on-polymorphism"><a class="header" href="#more-on-polymorphism">More on Polymorphism</a></h3>
<p>Now that we have shown how to create our own algebraic data types in
Haskell (and polymorphic ones), we step aside and give a mental model
for understanding polymorphism. Recall that we have described
polymorphic functions and types as functions/types that
quantifies/parameterizes types; in other words, they receive a type as a
parameter.</p>
<p>Recall in the lambda calculus $\lambda$ creates a function over a
parameter. Assuming the parameter has type $S$ and the returned value
has type $T$, we get: $$\lambda x.e: S \to T$$ and when we call or apply
this function, we are substituting the parameter for the argument of the
function application: $$(\lambda x.e_1)e_2 \equiv_\beta e_1[x:=e_2]$$</p>
<p>::: example
$$\begin{aligned}
(\lambda x: \mathtt{Int}.x + 4)3 &amp;\equiv_\beta (x + 4)[x := 3]\
&amp;\equiv_\beta (3 + 4)\
&amp; \equiv_\beta 7
\end{aligned}$$ In Haskell (the expression in parentheses is a lambda
expression):</p>
<pre><code class="language-haskell">ghci&gt; (\x -&gt; x + 4) 3
7
</code></pre>
<p>:::</p>
<p>A typed variant of the lambda calculus known as System $F$ has
polymorphic functions, which are functions that also receive a type
parameter. We can then apply this function onto a type <em>argument</em> to get
a specialized version of that function. Such type parameters are bound
by $\Lambda$. As an example, if we have a term $e$ of type $T$, we get:
$$\Lambda \alpha.e: \forall\alpha.T$$ Calling or applying this function
with a type argument, once again, substitutes the type parameter with
the type argument:
$$(\Lambda\alpha.e).\tau\equiv_\beta e[\alpha := \tau]$$
$$(\Lambda\alpha.e).\tau : T[\alpha := \tau]$$</p>
<p>::: example
$$\begin{aligned}
(\Lambda \alpha.\lambda x:\alpha.[x]) \mathtt{Int} &amp;\equiv_\beta (\lambda x:\alpha.[x])[\alpha := \mathtt{Int}]\
&amp; \equiv_\beta \lambda x:\mathtt{Int}.[x]
\end{aligned}$$</p>
<p>We can show this with an example in Haskell. Explicit type arguments
must be enabled with a language extension and the type arguments must be
prefixed by <code>@</code>:</p>
<pre><code class="language-haskell">ghci&gt; :set -XTypeApplications -fprint-explicit-foralls
ghci&gt; :{
ghci| f :: forall a. a -&gt; [a]
ghci| f x = [x]
ghci| :}

ghci&gt; :t f
f :: forall a. a -&gt; [a]

ghci&gt; :t f @Int
f @Int :: Int -&gt; [Int]

ghci&gt; f @Int 1
[1]
</code></pre>
<p>:::</p>
<p>On the other hand, polymorphic types can be seen as <em>functions at the
type-level</em>. These are "functions" that receive types and return types!
For example, we can define a <code>Pair</code>{.haskell} type that is polymorphic
in its component types. Thus, the <code>Pair</code>{.haskell} type itself (not its
constructor!) receives two types, and returns the resulting
<code>Pair</code>{.haskell} type specialized to those component types. This makes
<code>Pair</code>{.haskell} what is known as a <em>type constructor</em>.</p>
<p>To observe this fact, know that types are to terms as <em>kinds</em> are to
types: they describe what <em>kind</em> of type a type is. The usual types that
we encounter <code>Int</code>{.haskell}, <code>[[Char]]</code>{.haskell} etc. have kind
<code>*</code>{.haskell}, and type constructors or "type-level functions" have
kind <code>* -&gt; *</code>{.haskell} for example. Below, we show that
<code>Pair</code>{.haskell} is a type constructor of kind <code>* -&gt; * -&gt; *</code>{.haskell},
which makes sense since it receives two types and returns the
specialized type of the <code>Pair</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; data Pair a b = P a b
ghci&gt; :k Pair
Pair :: * -&gt; * -&gt; *
ghci&gt; :k Pair Int
Pair Int :: * -&gt; *
ghci&gt; :k Pair Int String
Pair Int String :: *
</code></pre>
<p>We know that we can have higher-order functions, for example, the type
of <code>map</code>{.haskell} might be something like
<code>(a -&gt; b) -&gt; [a] -&gt; [b]</code>{.haskell}. Can we have higher-order type
constructors? Yes! These are known as <em>higher kinds</em> or <em>higher-kinded
types</em>. These types receive <em>type constructors</em> as type arguments. Let
us construct a higher-kinded type that receives a type constructor and
applies it onto a type:</p>
<pre><code class="language-haskell">ghci&gt; data Crazy f a = C (f a)
</code></pre>
<p>Upon visual inspection we can see that <code>f</code> must be a type constructor,
because the constructor <code>C</code>{.haskell} receives a term of type <code>f a</code>!
What's crazier is, when inspecting the kind of <code>Crazy</code>{.haskell}, we see
that it exhibits <em>kind polymorphism</em>:</p>
<pre><code class="language-haskell">ghci&gt; :set -fprint-explicit-foralls
ghci&gt; :k Crazy
Crazy :: forall {k}. (k -&gt; *) -&gt; k -&gt; *
</code></pre>
<p>To give you an example of how this might work, because we know we can
construct lists of any type, <code>[]</code>{.haskell} (the type, not the empty
list) must be a type constructor. We can thus pass the <code>[]</code>{.haskell}
type constructor into <code>Crazy</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; :k Crazy []
Crazy [] :: * -&gt; *
ghci&gt; :k Crazy [] Int
Crazy [] Int :: *
</code></pre>
<p>How might this work? We see that <code>Crazy [] Int</code>{.haskell} has kind <code>*</code>,
so we should be able to construct a term of this type. We can do so by
using the <code>C</code>{.haskell} constructor defined above! To be clear, let's
see the specialized version of the constructor with the type arguments
entered:</p>
<pre><code class="language-haskell">ghci&gt; :t C @[] @Int
C @[] @Int :: [Int] -&gt; Crazy [] Int
</code></pre>
<p>As we can see, to construct a term of this type, we just need to pass in
a list of integers to <code>C</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; x :: Crazy [] Int = C [1]
</code></pre>
<p>We can in fact instantiate other crazy types with different type
constructors:</p>
<pre><code class="language-haskell">ghci&gt; data Box a = B a
ghci&gt; y :: Crazy Box Int = C (B 2)
</code></pre>
<p>The utility of higher-kinded types may not be apparent to you now; later
on we might see some of them in action!</p>
<p>Although this might confuse you so far, what we have demonstrated merely
serves to demonstrate the idea that parametric polymorphism can be
thought of the phenomenon where something (type or term) can receive a
type and give you a type or term, just as we have stated at the
beginning of
<a href="types/sections/algebraic_data_types.html#sec:polymorphism">[sec:polymorphism]</a>{reference-type="autoref"
reference="sec:polymorphism"}.</p>
<h3 id="other-polymorphisms"><a class="header" href="#other-polymorphisms">Other Polymorphisms</a></h3>
<p>At the start of
<a href="types/sections/algebraic_data_types.html#sec:polymorphism">[sec:polymorphism]</a>{reference-type="autoref"
reference="sec:polymorphism"} we introduced three questions, two of
which have been answered. Let us restate the final question and pose one
more:</p>
<ol>
<li>
<p>Can types depend on terms?</p>
</li>
<li>
<p>Are there other kinds of polymorphism?</p>
</li>
</ol>
<p>The answers to both questions is yes. Types that depend on terms are
known as <em>dependent types</em>, which we shall not cover in this course.
There are also other kinds of polymorphisms, some of which you have
already dealt with. Subtype polymorphism is used frequently in OOP,
since subclasses are types that are <em>subtypes</em> of their superclasses. An
umbrella term <em>ad-hoc polymorphism</em> generally refers to <em>overloading</em>,
which we shall discuss in the future. There are also more kinds of
polymorphisms, but we shall not discuss them in this course.</p>
<p>Python (and several other mainstream languages) is quite special, being
a multi-paradigm language means that several forms of polymorphism are
applicable to it. In particular, we have seen that Python supports
parametric polymorphism, and since Python supports OOP, it also has
subtype polymorphism. Despite Python not having algebraic data types
(yet), we may also formulate our types to behave similarly to Algebraic
Data Types. Two formulations we may attempt are: 1) with types as unions
and constructors as classes, 2) with types as classes and constructors
as their subclasses. Below we present both formulations for the linked
list type:</p>
<pre><code class="language-python"># (1)
type List[a] = Node[a] | Empty

@dataclass
class Empty:
    pass

@dataclass
class Node[a]:
    head: a
    tail: List[a]

x: List[int] = Node(1, Node(2, Empty()))
</code></pre>
<pre><code class="language-python"># (2)
from typing import Any
@dataclass
class List[a]:
    pass

@dataclass
class Empty(List[Any]):
    pass

@dataclass
class Node[a](List[a]):
    head: a
    tail: List[a]

x: List[int] = Node(1, Node(2, Empty()))
</code></pre>
<p>There are some differences between the two formulations, and between
these with Haskell's Algebraic Data Types. Most importantly, in Haskell,
data types are types, but constructors are not. This is unlike Python,
where all classes are types. That means a variable of type
<code>Node[int]</code>{.python} is valid in Python, but a variable of type
<code>Node Int</code>{.haskell} is not in Haskell.</p>
<h3 id="sec:gadt"><a class="header" href="#sec:gadt">Generalized Algebraic Data Types</a></h3>
<p>However, something interesting is going on here. In the second
formulation, a <code>Node[a]</code>{.python} is a <code>List[a]</code>, which makes sense. On
the other hand, an <code>Empty</code> can be typed as <code>List[Any]</code>, because an empty
list fits all kinds of lists. An interesting observation you might see
is that the supertype of our "constructors" need not strictly be
<code>List[a]</code>, it could be any kind of list!</p>
<p>Consider the following example of defining simple expressions in a
polymorphic manner using OOP.</p>
<pre><code class="language-python">class Expr[a]:
    def eval(self) -&gt; a:
        raise Exception
</code></pre>
<p>The <code>Expr</code> class is parameterized by the type of its evaluation. From
this class we may now create subclasses of <code>Expr</code>. For example, some
simple numeric expressions.</p>
<pre><code class="language-python">@dataclass
class LitNumExpr(Expr[int]):
    n: int
    def eval(self) -&gt; int:
        return self.n

@dataclass
class AddExpr(Expr[int]):
    lhs: Expr[int]
    rhs: Expr[int]
    def eval(self) -&gt; int:
        return self.lhs.eval() + self.rhs.eval()
</code></pre>
<p>We can then create other kinds of expressions. For example, an equality
expression that returns booleans:</p>
<pre><code class="language-python">@dataclass
class EqExpr[a](Expr[bool]):
    lhs: Expr[a]
    rhs: Expr[a]
    def eval(self) -&gt; bool:
        return self.lhs.eval() == self.rhs.eval()
</code></pre>
<p>Or even a conditional expression whose evaluated type is parameterized:</p>
<pre><code class="language-python">@dataclass
class CondExpr[a](Expr[a]):
    cond: Expr[bool]
    true: Expr[a]
    false: Expr[a]
    def eval(self) -&gt; a:
        return self.true.eval() if self.cond.eval() else self.false.eval()
</code></pre>
<p>Let's try this out! Suppose we would like to evaluate the following
expression:</p>
<p>::: center
<code>if 1 == 2 then 1 + 1 else 0</code>
:::</p>
<p>Let's write this in the program using our classes and evaluate it!</p>
<pre><code class="language-python">zero: Expr[int] = LitNumExpr(0)
one: Expr[int] = LitNumExpr(1)
two: Expr[int] = LitNumExpr(2)
one_plus_one: Expr[int] = AddExpr(one, one)
one_eq_two: Expr[bool] = EqExpr(one, two)
cond: Expr[int] = CondExpr(one_eq_two, one_plus_one, zero)
print(cond.eval()) # 0
</code></pre>
<p>How do we create such an algebraic data type in Haskell? For this, we
have to use <em>Generalized Algebraic Data Types</em> (GADTs). Loosely, these
are algebraic data types like before, except that each constructor can
decide what type it returns!</p>
<p>First, let us formulate our original algebraic data types using GADT
syntax.</p>
<pre><code class="language-haskell">data LinkedList a where
    EmptyList :: LinkedList a -- this is a different a!
    Node :: b -&gt; LinkedList b -&gt; LinkedList b
</code></pre>
<p>Now let us take it a step further, and truly customize the constructors
of an <code>Expr</code>{.haskell} GADT:</p>
<pre><code class="language-haskell">data Expr a where
    LitNumExpr :: Int -&gt; Expr Int
    AddExpr    :: Expr Int -&gt; Expr Int -&gt; Expr Int
    EqExpr     :: Expr a -&gt; Expr a -&gt; Expr Bool
    CondExpr   :: Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Pretty neat huh! There are many uses of GADTs, and we might see them in
the future. In the next section, we will show you how we can write
functions against algebraic data types and GADTs, including how we can
implement the <code>eval</code>{.haskell} function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h1>
<p>We have seen how we can write constructors for algebraic data types, and
even use record syntax to create functions for accessing fields.
However, one natural question would then be to ask, how do we write
functions that access these fields, if we do not use record syntax? For
example, if we defined a fraction type normally, how do we obtain a
fraction's numerator and denominator?</p>
<p>The answer to this question is to use <em>pattern matching</em>. It is a
control structure just like if-else statements, except that we would
execute different branches based on the value/structure of the data,
instead of a general condition.</p>
<p>::: example
[]{#eg:factorialpatternmatching label="eg:factorialpatternmatching"} Let
us define the factorial function using pattern matching instead of
conditional expressions or guards. We use <code>case</code>{.haskell} expressions
to do so:</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac n = case n of -- match n against these patterns:
    0 -&gt; 1
    x -&gt; x * fac (x - 1) -- any other Int
</code></pre>
<p>:::</p>
<p>The nice thing about pattern matching is that we can also match against
the <em>structure</em> of data, i.e. to match against constructors:</p>
<p>::: example
[]{#eg:fstsndpatternmatching label="eg:fstsndpatternmatching"} Let us
redefine the <code>fst</code>{.haskell} and <code>snd</code>{.haskell} functions which project
a tuple into its component values:</p>
<pre><code class="language-haskell">fst' :: (a, b) -&gt; a
fst' p = case p of 
    (x, _) -&gt; x

snd' :: (a, b) -&gt; b
snd' p = case p of
    (_, y) -&gt; y
</code></pre>
<p>:::</p>
<p>::: example
[]{#eg:fractionpatternmatching label="eg:fractionpatternmatching"} Let
us write accessor functions to access the numerator and denominator of a
fraction.</p>
<pre><code class="language-haskell">data Fraction = F Int Int
numerator, denominator :: Fraction -&gt; Int
numerator f = case f of
    F x _ -&gt; x
denominator f = case f of 
    F _ x -&gt; x
</code></pre>
<p>:::</p>
<p>One nice thing about Haskell is that because we perform pattern matching
over the arguments of functions so frequently, we can actually bring the
patterns up to the definitions of the functions themselves.</p>
<p>::: example
Let us define all of the functions we've just written using
<code>case</code>{.haskell} expressions in
<a href="types/sections/pattern_matching.html#eg:factorialpatternmatching">[eg:factorialpatternmatching]</a>{reference-type="autoref"
reference="eg:factorialpatternmatching"},
<a href="types/sections/pattern_matching.html#eg:fstsndpatternmatching">[eg:fstsndpatternmatching]</a>{reference-type="autoref"
reference="eg:fstsndpatternmatching"} and
<a href="types/sections/pattern_matching.html#eg:fractionpatternmatching">[eg:fractionpatternmatching]</a>{reference-type="autoref"
reference="eg:fractionpatternmatching"} into more idiomatic uses of
pattern matching.</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac 0 = 1
fac n = n * fac (n - 1)
 
fst' :: (a, b) -&gt; a
snd' :: (a, b) -&gt; b
fst' (x, _) = x
snd' (_, y) = y
 
data Fraction = F Int Int
numerator, denominator :: Fraction -&gt; Int

numerator (F x _) = x
denominator (F _ y) = y
</code></pre>
<p>:::</p>
<p>We also know that the list type is a singly linked list, which is
roughly defined as such:</p>
<pre><code class="language-haskell">data [a] = [] | a : [a]
</code></pre>
<p>We can use this fact to pattern match against lists!</p>
<p>::: example
The sum of a list of integers is 0 if the list is empty, otherwise its
the head of the list plus the sum of the tail of the list.</p>
<pre><code class="language-haskell">sum' :: [Int] -&gt; Int
sum' [] = 0
sum' (x : xs) = x + sum' xs
</code></pre>
<p>:::</p>
<p>::: example
The length of a list is 0 if the list is empty, otherwise it is 1 more
than the length of its tail.</p>
<pre><code class="language-haskell">len :: [a] -&gt; Int
len [] = 0
len (_ : xs) = 1 + len xs
</code></pre>
<p>:::</p>
<p>Really neat! Defining functions operating on algebraic data types
(including recursive data types) are very convenient thanks to pattern
matching! What's more, patterns can actually be used virtually anywhere
on the left side of any binding:</p>
<p>::: example
Let us use pattern matching in a <code>let</code>{.haskell} binding:</p>
<pre><code class="language-haskell">len :: [a] -&gt; Int
len [] = 0
len ls = 
    let (_ : xs) = ls
    in  1 + len xs
</code></pre>
<p>:::</p>
<p>Perhaps the most powerful feature of pattern matching is that the
compiler will warn you if your pattern matches are non-exhaustive, i.e.
if you do not match against all possible constructors of the type! Let
us define a function that only matches against the empty list
constructor.</p>
<pre><code class="language-haskell">-- Main.hs
emp :: [a] -&gt; [a]
emp [] = []
</code></pre>
<p>Compile it to see the warning!</p>
<pre><code>ghc Main.hs
Main.hs:3:1: warning: [-Wincomplete-patterns]
    Pattern match(es) are non-exhaustive
    In an equation for ‘emp’: Patterns of type ‘[a]’ not matched: (_:_)
  |
3 | emp [] = []
  | ^^^^^^^^^^^
</code></pre>
<p>This is one reason why pattern matching is so powerful; compilers can
check if you have covered all possible patterns of a given type. This is
unlike usual if-else statements where it is much less straightforward to
check if you have covered all possible branches, especially if you omit
<code>else</code>{.python} statements.</p>
<p>One important point to highlight here is that pattern matching is done
top-down. Thus, using pattern-matching is kind of similar to if-else
statements in that regard: your most specific condition should be
defined first, then followed by more general or catch-all patterns.</p>
<p>::: example
The following factorial function is poorly defined, because the first
pattern match will match all possible integers, thereby causing the
function to never terminate:</p>
<pre><code class="language-haskell">fac :: Int -&gt; Int
fac n = n * fac (n - 1)
fac 0 = 1 -- redundant as pattern above matches all
          -- possible integers
</code></pre>
<p>:::</p>
<p>With pattern matching, let us know fulfil our earlier promise of
defining the <code>eval</code>{.haskell} function for the <code>Expr</code>{.haskell} GADT in
<a href="types/sections/pattern_matching.html#sec:gadt">[sec:gadt]</a>{reference-type="autoref"
reference="sec:gadt"}.</p>
<p>In our Python formulation, we know that <code>eval</code>{.haskell} should have the
type signature <code>Expr a -&gt; a</code>{.haskell}. Let us then define how each
expression should be evaluated with pattern matching.</p>
<pre><code class="language-haskell">eval :: Expr a -&gt; a
eval (LitNumExpr n)   = n
eval (AddExpr a b)    = eval a + eval b
eval (EqExpr a b)     = eval a == eval b
eval (CondExpr a b c) = if eval a then eval b else eval c
</code></pre>
<p>This is highly straightforward! However, you might find that when this
program is compiled, the compiler throws an error on the use of the
<code>(==)</code>{.haskell} function:</p>
<pre><code>ghc Main.hs
Main.hs:13:28: error:
    • Could not deduce (Eq a1) arising from a use of ‘==’
      from the context: a ~ Bool
        bound by a pattern with constructor:
                   EqExpr :: forall a. Expr a -&gt; Expr a -&gt; Expr Bool,
                 in an equation for ‘eval’
        at app/Main.hs:13:7-16
      Possible fix:
        add (Eq a1) to the context of the data constructor ‘EqExpr’
    • In the expression: eval a == eval b
      In an equation for ‘eval’: eval (EqExpr a b) = eval a == eval b
   |
13 | eval (EqExpr a b) = eval a == eval b
   |       
</code></pre>
<p>The reason for this is Haskell is unable to determine that the type
parameter <code>a</code> is amenable to equality comparisons. Solving this requires
an understanding of <em>typeclasses</em>, which we will explore in the next
lecture. For now, just include an <code>Eq a =&gt;</code>{.haskell} constraint in our
GADT declaration.</p>
<p>You might also get a warning about pattern matching on GADTs being
fragile; that is because GADTs are actually a Haskell language
extension. As such, enable this extension when compiling this program,
or add a <code>LANGUAGE</code> <em>pragma</em> at the top of the file.</p>
<pre><code class="language-haskell">{-# LANGUAGE GADTs #-}
data Expr a where
  LitNumExpr ::         Int -&gt; Expr Int
  AddExpr    ::         Expr Int -&gt; Expr Int -&gt; Expr Int
  EqExpr     :: Eq a =&gt; Expr a -&gt; Expr a -&gt; Expr Bool
  CondExpr   ::         Expr Bool -&gt; Expr a -&gt; Expr a -&gt; Expr a
</code></pre>
<p>Our program should compile now!</p>
<h3 id="pattern-matching-in-python"><a class="header" href="#pattern-matching-in-python">Pattern Matching in Python</a></h3>
<p>Python also has pattern matching with <code>match</code>{.python} statements with
<code>case</code>{.python} clauses! It looks very similar to how we would write
<code>case</code>{.haskell} expressions in Haskell.</p>
<pre><code class="language-python">def factorial(n: int) -&gt; int:
  match n:
    case 0: return 1
    case n: return n * factorial(n - 1)
</code></pre>
<p>We can also match on the structure of types by unpacking. For example,
defining a function that sums over a list of integers:</p>
<pre><code class="language-python">def sum(ls: list[int]) -&gt; int:
  match ls:
    case []: return 0
    case (x, *xs): return x + sum(xs)
    case _: raise TypeError()
</code></pre>
<p>Alternatively, performing structural pattern matching over a so called
algebraic data type:</p>
<pre><code class="language-python">@dataclass
class Tree[a]: pass
 
@dataclass
class Node[a](Tree[a]):
    val: a
    left: Tree[a]
    right: Tree[a]
 
@dataclass
class Leaf[a](Tree[a]):
    val: a

def preorder[a](tree: Tree[a]) -&gt; list[a]:
    match tree:
        case Node(v, l, r): return [v] + preorder(l) + preorder(r)
        case Leaf(v): return [v]
        case _: raise TypeError
</code></pre>
<p>However, notice that in the <code>sum</code> and <code>preorder</code> function definitions,
the last clause catches all patterns and raises an error. This is needed
to side-step the exhaustiveness checker. This is because we are using
classes to model algebraic data types, and Python does not always know
all the possible structures of a given class. In the case of <code>sum</code>,
Python's type system does not contain information about the length of a
list, so it has no way of determining exhaustiveness. In the case of
<code>preorder</code>, the reason omitting the last case gives a non-exhaustiveness
error is because we did not match against other possible subclasses of
<code>Tree</code>.</p>
<p>If we had formulated our <code>Tree</code> type using unions, pyright can determine
the exhaustiveness of our patterns:</p>
<pre><code class="language-python">type Tree[a] = Node[a] | Leaf[a]

@dataclass
class Node[a]:
    val: a
    left: Tree[a]
    right: Tree[a]

@dataclass
class Leaf[a]:
    val: a

def preorder[a](tree: Tree[a]) -&gt; list[a]:
    match tree:
        case Node(v, l, r): return [v] + preorder(l) + preorder(r)
        case Leaf(v): return [v]
        # no need for further cases
</code></pre>
<p>However, this may not always be ideal, especially if we are to define
GADTs in Python. Until Algebraic Data Types or ways to annotate the
exhaustivity of subclasses (such as defining a <em>sealed</em> class) are
formally introduced, exhaustive pattern matching checks are going to be
difficult to do. When doing pattern matching in Python, ensure that all
possible cases are handled before doing a catch-all clause in your
<code>match</code>{.python} statement.</p>
<p>All-in-all, we have just introduced a new control structure known as
pattern matching. When should we use this control structure? The general
rule of thumb is as follows:</p>
<ul>
<li>
<p>If you are doing different things based on the value and/or
structure of data, use pattern matching. You can tell this is the
case if you are doing equality and <code>isinstance</code>{.python} checks in
your conditional statements in Python.</p>
</li>
<li>
<p>Otherwise, you are likely going with the more general case of doing
different things based on the satisfiability of a condition, in
which case, rely on if-else statements, or in Haskell, conditional
expressions and/or guards.</p>
</li>
</ul>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Python doesn't have arrow types. The actual type of the function
is <code>Callable[[int], int]</code>{.python}.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>These are the three axes that form the <em>lambda cube</em>, with the
simply typed lambda calculus only having terms that depend on terms,
and the Calculus of Constructions having types and terms depending
on types and terms.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>The word <em>polymorphism</em> can be broken down into <em>poly</em> (many) and
<em>morphism</em> (shape). The word is not just used in Computer Science,
but in other areas like biology and pharmacology. Within Computer
Science itself there are several kinds of polymorphism, and we shall
investigate the most common ones in this lecture and in later
lectures too. Finally, polymorphism in Computer Science is really
about things taking on different forms, but I suspect that our
description of parametric polymorphism gives a pretty good picture
of what it entails.</p>
</div>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">4</sup>
<p>The code snippet requires Python 3.12.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h1>
<p>::: exercise
[]{#q:whatarethetypes label="q:whatarethetypes"} Without using GHCI,
determine the types of the following expressions:</p>
<ol>
<li>
<p><code>(1 :: Int) + 2 * 3</code>{.haskell}</p>
</li>
<li>
<p><code>let x = 2 + 3 in show x</code>{.haskell}</p>
</li>
<li>
<p><code>if "ab" == "abc" then "a" else []</code>{.haskell}</p>
</li>
<li>
<p><code>(++ [])</code>{.haskell}</p>
</li>
<li>
<p><code>map (\(x :: Int) -&gt; x * 2)</code>{.haskell}</p>
</li>
<li>
<p><code>((\(x :: [Int]) -&gt; show x) . )</code>{.haskell}</p>
</li>
<li>
<p><code>( . (\(x :: [Int]) -&gt; show x))</code>{.haskell}</p>
</li>
<li>
<p><code>(,) . fst</code>{.haskell}</p>
</li>
<li>
<p><code>filter</code>{.haskell}
:::</p>
</li>
</ol>
<p>::: exercise
[]{#q:whatarethetypesoffunctions label="q:whatarethetypesoffunctions"}
Without the help of GHCI, describe the types of the functions that we
defined in <a href="types/sections/exercises.html#q:eqLast">[q:eqLast]</a>{reference-type="autoref"
reference="q:eqLast"},
<a href="types/sections/exercises.html#q:palindrome">[q:palindrome]</a>{reference-type="autoref"
reference="q:palindrome"},
<a href="types/sections/exercises.html#q:burgerPrice">[q:burgerPrice]</a>{reference-type="autoref"
reference="q:burgerPrice"} and
<a href="types/sections/exercises.html#q:slice">[q:slice]</a>{reference-type="autoref" reference="q:slice"}
(<code>eqLast</code>, <code>isPalindrome</code>, <code>burgerPrice</code>, <code>@:</code>).
:::</p>
<p>::: exercise
[]{#q:burgerPricePatternMatching label="q:burgerPricePatternMatching"}
Recall the following solution to
<a href="types/sections/exercises.html#q:burgerPrice">[q:burgerPrice]</a>{reference-type="autoref"
reference="q:burgerPrice"}:</p>
<pre><code class="language-haskell">burgerPrice burger 
  | null burger = 0
  | otherwise   =
      let first = ingredientPrice (head burger)
          rest  = burgerPrice (tail burger)
      in  first + rest
  where ingredientPrice i
          | i == 'B' = 0.5
          | i == 'C' = 0.8
          | i == 'P' = 1.5
          | i == 'V' = 0.7
          | i == 'O' = 0.4
          | i == 'M' = 0.9
</code></pre>
<p>There are several problems with this. First of all, writing
<code>burgerPrice</code>{.haskell} with guards does not allow us to rely on
compiler exhaustiveness checks, and may give us some additional warnings
about <code>head</code> and <code>tail</code> being <em>partial</em>, despite their use being
perfectly fine. The second problem is that we have allowed our burger to
be any string, even though we should only allow strings that are
composed of valid ingredientsthe compiler will not reject invocations of
<code>burgerPrice</code>{.haskell} with bogus arguments like <code>"AbcDEF"</code>{.haskell}.<br />
Define a new type that represents valid burgers, and re-define
<code>burgerPrice</code>{.haskell} against that type using pattern matching.
Additionally, provide a type declaration for this function. Note that
you may use the <code>Rational</code>{.haskell} type to describe rational numbers
like <code>0.8</code>{.haskell} etc, instead of <code>Double</code>{.haskell} which may have
precision issues. You might see that the output of your
<code>burgerPrice</code>{.haskell} function is of the form <code>x % y</code> which means
$x/y$.
:::</p>
<p>::: exercise
[]{#q:dropConsecutiveDuplicates label="q:dropConsecutiveDuplicates"}
Define a function <code>dropConsecutiveDuplicates</code>{.haskell} that receives a
list of any type that is amenable to equality comparisons and removes
all the consecutive duplicates of the list. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; dropConsecutiveDuplicates []
[]
ghci&gt; dropConsecutiveDuplicates [1, 2, 2, 3, 3, 3, 3, 4, 4]
[1, 2, 3, 4]
ghci&gt; dropConsecutiveDuplicates "aabcccddeee"
"abcde"
</code></pre>
<p>For this function to be polymorphic, you will need to add a constraint
<code>Eq a =&gt;</code>{.haskell} at the beginning of the function's type signature
just like we did for the <code>EqExpr</code>{.haskell} constructor of our
<code>Expr a</code>{.haskell} GADT.
:::</p>
<p>::: exercise
[]{#q:listzipper label="q:listzipper"} Suppose we have a list
<code>[1,2,3,4,5]</code>{.haskell}. Since lists in Haskell are singly-linked lists,
and not to mention that Haskell lists are immutable, changing the values
at the tail end of the list (e.g. <code>4</code> or <code>5</code>) can be inefficient! Not
only that, if we want to then change something near the element we've
just changed, we have to traverse all the way down to that element from
the head all over again!<br />
Instead, what we can use is a <em>zipper</em>, which allows us to focus on a
part of a data structure so that accessing those elements and walking
around it is efficient. The idea is to write functions that let us walk
down the list, do our changes, and walk back up to recover the full
list. For this, we shall define some functions:</p>
<ol>
<li>
<p><code>mkZipper</code> which receives a list and makes a zipper</p>
</li>
<li>
<p><code>r</code> which walks to the right of the list zipper</p>
</li>
<li>
<p><code>l</code> which walks to the left of the list zipper</p>
</li>
<li>
<p><code>setElement x</code> which changes the element at the current position of
the zipper to <code>x</code>.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; x = mkZipper [1,2,3,4,5]
ghci&gt; x
([], [1,2,3,4,5])
ghci&gt; y = r $ r $ r $ r x
ghci&gt; y = ([4,3,2,1], [5])
ghci&gt; z = setElement (-1) y
ghci&gt; z
([4,3,2,1], [-1])
ghci&gt; w = setElement (-2) $ l z
ghci&gt; w 
([3,2,1], [-2,-1])
ghci&gt; l $ l $ l w
([], [1,2,3,-2,-1])
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:bst label="q:bst"} Let us create a data structure that represents
sorted sets. These are collections that contain unique elements and are
sorted in ascending order. A natural data structure that can represent
such sets is the Binary Search Tree (BST) abstract data type (ADT).<br />
Create a new type <code>SortedSet</code>{.haskell}. Then define the following
functions:</p>
<ol>
<li>
<p>The function <code>@+</code> that receives a sorted set and an element, and
returns the sorted set with the element added (unless it is already
in the sorted set).</p>
</li>
<li>
<p>The function <code>setToList</code> that receives a sorted set and returns it
as a list (in sorted order)</p>
</li>
<li>
<p>The function <code>sortedSet</code> that receives a list of elements and puts
them all in a sorted set.</p>
</li>
<li>
<p>The function <code>in’</code> which determines if an element is in the sorted
set.</p>
</li>
</ol>
<p>Note that if any of your functions perform any comparison operations
(<code>&gt;</code> etc.), you will need to include the <code>Ord a =&gt;</code>{.haskell} constraint
over the elements of the sorted set or list at the beginning of the type
signature of those functions. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; setToList $ (sortedSet []) @+ 1
[1]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2
[1,2]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2 @+ 0
[0,1,2]
ghci&gt; setToList $ (sortedSet []) @+ 1 @+ 2 @+ 0 @+ 2
[0,1,2]
ghci&gt; setToList $ sortedSet [7,3,2,5,5,2,1,7,6,3,4,2,4,4,7,1,2,3]
[1,2,3,4,5,6,7]
ghci&gt; setToList $ sortedSet "aaabccccbbbbbaaaaab"
"abc"
ghci&gt; 1 `in'` (sortedSet [1, 2, 3])
True
ghci&gt; 1 `in'` (sortedSet [4])
False
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:shapesexpressionproblem label="q:shapesexpressionproblem"} In this
question, we are going to demonstrate an example of the <em>expression
problem</em> by writing FP-style data structures and functions, and OO-style
classes, to represent the same problem. We shall use Haskell for the FP
formulation, and Python for the OOP formulation. Ensure that your Python
code is well-typed by checking it with pyright.<br />
The problem is as such. We want to represent various shapes, and the
facility to calculate the area of a shape. To start, we shall define two
shapes: circles and rectangles. Circles have a radius and rectangles
have a width and height. Assume these fields are all <code>Double</code>{.haskell}s
in Haskell, and <code>float</code>{.python}s in Python.<br />
Haskell: define a type <code>Shape</code>{.haskell} that represents these two
shapes, and a function <code>area</code>{.haskell} that computes the area of any
shape.</p>
<p>Python: define a (abstract) class <code>Shape</code> that comes with a (abstract)
method <code>area</code> which gives its area. Then, define two subclasses of
<code>Shape</code> that represents circles and rectangles, and define their
constructors and methods appropriately.<br />
The <em>expression problem</em> essentially describes the phenomenon that it
can either be easy to add new representations of a type, easy to add new
functions over types, but not both. To observe this, we are going to
extend the code we've written in the following ways:</p>
<ol>
<li>
<p>Create a new shape called <code>Triangle</code> that has a width and height.</p>
</li>
<li>
<p>Create a new function/method <code>scale</code> that scales the shape (by
length) by some factor $n$.</p>
</li>
</ol>
<p>Proceed to do so in both formulations. As you are doing so, think about
whether each extension is easy to do if the code we've previously
written cannot be amended, e.g. if it is in a pre-compiled library which
you do not have the source code of.
:::</p>
<p>::: exercise
[]{#q:exprgadt label="q:exprgadt"} Let us extend our Expressions GADT.
Define the following expressions:</p>
<ol>
<li>
<p><code>LitBoolExpr</code>{.haskell} holds a boolean value (<code>True</code>{.haskell} or
<code>False</code>{.haskell})</p>
</li>
<li>
<p><code>AndExpr</code>{.haskell} has two boolean expressions and evaluates to
their conjunction</p>
</li>
<li>
<p><code>OrExpr</code>{.haskell} has two boolean expressions and evaluates to
their disjunction</p>
</li>
<li>
<p><code>FuncExpr</code>{.haskell} holds a function</p>
</li>
<li>
<p><code>FuncCall</code>{.haskell} receives a function and an argument, and
evaluates to the function application to that argument</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; n = LitNumExpr
ghci&gt; b = LitBoolExpr
ghci&gt; a = AndExpr
ghci&gt; o = OrExpr
ghci&gt; f = FuncExpr
ghci&gt; c = FuncCall
ghci&gt; eval (b True `a` b False)
False
ghci&gt; eval (b True `a` b True)
True
ghci&gt; eval (b True `o` b False)
True
ghci&gt; eval (b False `o` b False)
False
ghci&gt; eval $ f (\x -&gt; x + 1) `c` n 1
2
ghci&gt; eval $ c (c (f (\x y -&gt; x + y)) (n 1)) (n 2)
3
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:bankaccounts label="q:bankaccounts"} In this question we shall
simulate a simple banking system consisting of bank accounts. We shall
write all this code in Python, but in a typed functional programming
style. That means:</p>
<ol>
<li>
<p>No loops</p>
</li>
<li>
<p>No mutable data structures or variables</p>
</li>
<li>
<p>Pure functions only</p>
</li>
<li>
<p>Annotate all variables, functions etc. with types</p>
</li>
<li>
<p>Program must be type-safe</p>
</li>
</ol>
<p>There are several kinds of bank accounts that behave differently on
certain operations. We aim to build a banking system that receives such
operations that act on these accounts. We shall build this system
incrementally (as we should!), so you may want to follow the parts in
order, and check your solutions after completing each part.<br />
<strong>[BANK ACCOUNTS]{.sans-serif}</strong><br />
<strong>[Bank Account ADT]{.sans-serif}</strong><br />
First, create an Algebraic Data Type (ADT) called <code>BankAccount</code>{.python}
that represents two kinds of bank accounts:</p>
<ol>
<li>
<p>Normal bank accounts</p>
</li>
<li>
<p>Minimal bank accounts</p>
</li>
</ol>
<p>Both kinds of accounts have an ID, account balance and an interest
rate.<br />
Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; NormalAccount("a", 1000, 0.01)
NormalAccount(account_id='a', balance=1000, interest_rate=0.01)
&gt;&gt;&gt; MinimalAccount("a", 1000, 0.01)
MinimalAccount(account_id='a', balance=1000, interest_rate=0.01)
</code></pre>
<p><strong>[Basic Features]{.sans-serif}</strong><br />
Now let us write some simple features of these bank accounts. There are
two features we shall explore:</p>
<ol>
<li>
<p>Depositing money into a bank account. Since we are writing code in a
purely functional style, our function does not mutate the state of
the bank account. Instead, it returns a new state of the account
with the money deposited. Assume that the deposit amount is
non-negative.</p>
</li>
<li>
<p>Deducting money from a bank account. Just like before, we are not
mutating the state of the bank account, and instead will be
returning the new state of the bank account. However, the deduction
might not happen since the account might have insufficient funds. As
such, this function returns a tuple containing a boolean flag
describing whether the deduction succeeded, and the new state of the
bank account after the deduction (if the deduction does not occur,
the state of the bank account remains unchanged).</p>
</li>
</ol>
<p><em>Note</em>: The type of a tuple with two elements of types <code>A</code>{.python} and
<code>B</code>{.python} is <code>tuple[A, B]</code>{.python}. Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = NormalAccount('abc', 1000, 0.01)
&gt;&gt;&gt; y = MinimalAccount('bcd', 2000, 0.02)
&gt;&gt;&gt; deposit(1000, x)
NormalAccount(account_id='abc', balance=2000, interest_rate=0.01)
&gt;&gt;&gt; deduct(1000, x)
(True, NormalAccount(account_id='abc', balance=0, interest_rate=0.01))
&gt;&gt;&gt; deduct(2001, y)
(False, MinimalAccount(account_id='bcd', balance=2000, 
    interest_rate=0.02))
</code></pre>
<p><strong>[Advanced Features]{.sans-serif}</strong><br />
Now we shall implement some more advanced features:</p>
<ol>
<li>
<p>Compounding interest. Given a bank account with balance $b$ and
interest rate $i$, the new balance after compounding will be
$b(1+i)$. For minimal accounts, an administrative fee of $20 will
be deducted if its balance is strictly below $1000. This fee
deduction happens <strong>before</strong> compounding. Importantly, bank balances
never go below $0, so e.g. if a minimal account has $10, after
compounding, its balance will be $0.</p>
</li>
<li>
<p>Bank transfers. This function receives a transaction amount and two
bank accounts: (1) the credit account (the bank account where funds
will come from) and (2) the debit account (bank account where funds
will be transferred to). The result of the transfer is a triplet
(tuple of three elements) containing a boolean describing the
success of the transaction, and the new states of the credit and
debit accounts. The transaction does not happen if the credit
account has insufficient funds.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; x = NormalAccount('abc', 1000, 0.01)
&gt;&gt;&gt; y = MinimalAccount('bcd', 2000, 0.02)
&gt;&gt;&gt; z = MinimalAccount('def', 999, 0.01)
&gt;&gt;&gt; w = MinimalAccount('xyz', 19, 0.01)
&gt;&gt;&gt; compound(x)
NormalAccount(account_id='abc', balance=1010, interest_rate=0.01)
&gt;&gt;&gt; compound(compound(x))
NormalAccount(account_id='abc', balance=1020.1, interest_rate=0.01)
&gt;&gt;&gt; compound(y)
MinimalAccount(account_id='bcd', balance=2040, interest_rate=0.02)
&gt;&gt;&gt; compound(z)
MinimalAccount(account_id='def', balance=988.79, interest_rate=0.01)
&gt;&gt;&gt; compound(w)
MinimalAccount(account_id='xyz', balance=0, interest_rate=0.01)
&gt;&gt;&gt; transfer(2000, x, y)
(False, NormalAccount(account_id='abc', balance=1000,
    interest_rate=0.01), MinimalAccount(account_id='bcd', 
    balance=2000, interest_rate=0.02))
&gt;&gt;&gt; transfer(2000, y, x)
(True, MinimalAccount(account_id='bcd', balance=0,
    interest_rate=0.02), NormalAccount(account_id='abc', 
    balance=3000, interest_rate=0.01))
</code></pre>
<p><strong>[OPERATING ON BANK ACCOUNTS]{.sans-serif}</strong><br />
Let us suppose that we have a dictionary whose keys are bank account IDs
and values are their corresponding bank accounts. This dictionary
simulates a 'database' of bank accounts which we can easily lookup by
bank account ID:</p>
<pre><code class="language-python">&gt;&gt;&gt; d: dict[str, BankAccount] = {
  'abc': NormalAccount('abc', 1000, 0.01)
  'bcd': MinimalAccount('bcd', 2000, 0.02)
}
</code></pre>
<p>Now we are going to process a whole bunch of operations on this
'database'.<br />
<strong>[Operations ADT]{.sans-serif}</strong><br />
The first step in processing a bunch of operations on the accounts in
our database is to create a data structure that represents the desired
operation in the first place. For this, create an algebraic data type
<code>Op</code>{.python} comprised of two classes:</p>
<ol>
<li>
<p><code>Transfer</code>{.python}: has a transfer amount, and credit bank account
ID, and a debit bank account ID. This represents the operation where
we are transferring the transfer amount from the credit account to
the debit account.</p>
</li>
<li>
<p><code>Compound</code>{.python}. This just tells the processor to compound all
the bank accounts in the map. There should be no attributes in this
class.</p>
</li>
</ol>
<p><strong>[Processing One Operation]{.sans-serif}</strong><br />
Write a function <code>process_one</code>{.python} that receives an operation and a
dictionary of bank accounts (keys are bank account IDs, and values are
the corresponding bank accounts), and performs the operation on the bank
accounts in the dictionary. As a result, the function returns a pair
containing:</p>
<ol>
<li>
<p>A boolean value to describe whether the operation has succeeded</p>
</li>
<li>
<p>The resulting dictionary containing the updated bank accounts after
the operations have been processed.</p>
</li>
</ol>
<p>Take note that there are several ways in which a <code>Transfer</code>{.python}
operation may fail:</p>
<ol>
<li>
<p>If either account IDs do not exist in the dictionary, the transfer
will fail</p>
</li>
<li>
<p>If the credit account does not have sufficient funds, the transfer
will fail</p>
</li>
<li>
<p>Otherwise, the transfer should proceed as per normal</p>
</li>
</ol>
<p>Keep in mind that you should not mutate any data structure used. Example
runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')
&gt;&gt;&gt; process_one(c, mp)
(True, {'alice': NormalAccount(account_id='alice', balance=1100.0, 
  interest_rate=0.1), 'bob': MinimalAccount(account_id='bob', 
  balance=1076.9, interest_rate=0.1)})
&gt;&gt;&gt; process_one(t1, mp)
(True, {'alice': NormalAccount(account_id='alice', balance=0, 
  interest_rate=0.1), 'bob': MinimalAccount(account_id='bob', 
  balance=1999, interest_rate=0.1)})
&gt;&gt;&gt; process_one(t2, mp)
(False, {'alice': NormalAccount(account_id='alice', balance=1000, 
  interest_rate=0.1), 'bob': MinimalAccount(account_id='bob', 
  balance=999, interest_rate=0.1)})
</code></pre>
<p><strong>[Processing All Operations]{.sans-serif}</strong><br />
Now let us finally define a function <code>process_all</code>{.python} that
receives a list of operations and a dictionary of bank accounts (the
keys are bank account IDs, and the values are bank accounts). As a
result, the function returns a pair containing:</p>
<ol>
<li>
<p>A list of booleans where the $i^\text{th}$ boolean value describes
whether the $i^\text{th}$ operation has succeeded</p>
</li>
<li>
<p>The resulting dictionary containing the updated bank accounts after
all the operations have been processed.</p>
</li>
</ol>
<p>Example runs follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')
&gt;&gt;&gt; process_all([t2, c, t2, t1], mp)
([False, True, True, True], {'alice': NormalAccount(account_id='alice', 
  balance=1100.0, interest_rate=0.1), 'bob': 
  MinimalAccount(account_id='bob', balance=1076.9, interest_rate=0.1)})
</code></pre>
<p><strong>[Polymorphic Processing]{.sans-serif}</strong> If you were careful with your
implementation of <code>process_all</code>{.python}, you might notice that if we
had parameterized all invocations of <code>process_one</code>{.python}, then
nothing about the implementation of <code>process_all</code>{.python} depends on
the types like <code>Op</code>{.python}, <code>dict[str, BankAccount]</code>{.python} or
<code>bool</code>{.python}. Thus we should make this function polymorphic!<br />
Our goal is to write a polymorphic function <code>process</code>{.python} that can
process any list over a state and produce the resulting list and an
updated state after performing stateful processing over the list. It
should be defined such that <code>process(process_one, ops, mp)</code>{.python}
should be the exact same as <code>process_all(ops, mp)</code>{.python} as you have
defined earlier:</p>
<pre><code class="language-python">&gt;&gt;&gt; alice = NormalAccount('alice', 1000, 0.1)
&gt;&gt;&gt; bob = MinimalAccount('bob', 999, 0.1)
&gt;&gt;&gt; mp = {'alice': alice, 'bob': bob}
&gt;&gt;&gt; c = Compound()
&gt;&gt;&gt; t1 = Transfer(1000, 'alice', 'bob')
&gt;&gt;&gt; t2 = Transfer(1000, 'bob', 'alice')
&gt;&gt;&gt; process(process_one, [t2, c, t2, t1], mp)
([False, True, True, True], {'alice': NormalAccount(account_id='alice', 
  balance=1100.0, interest_rate=0.1), 'bob': 
  MinimalAccount(account_id='bob', balance=1076.9, interest_rate=0.1)})
</code></pre>
<p>Furthermore, the best part of this polymorphic function is that it can
be used in any situation where we need this stateful accumulation over a
list. For example, we can define a function that tests if a number $n$
is co-prime to a list of other numbers, and if it is indeed co-prime to
all of the input numbers, add $n$ to the state list:</p>
<pre><code class="language-python">&gt;&gt;&gt; def gather_primes(n: int, ls: list[int]) -&gt; tuple[bool, list[int]]:
...     if any(n % i == 0 for i in ls):
...         return (False, ls)
...     return (True, ls + [n])
</code></pre>
<p>Example uses of this follow:</p>
<pre><code class="language-python">&gt;&gt;&gt; gather_primes(2, [])
(True, [2])
&gt;&gt;&gt; gather_primes(3, [2])
(True, [2, 3])
&gt;&gt;&gt; gather_primes(4, [2, 3])
(False, [2, 3])
</code></pre>
<p>This way, we can use <code>process</code>{.python} to generate prime numbers and do
primality testing!</p>
<pre><code class="language-python">&gt;&gt;&gt; def primes(n: int) -&gt; tuple[list[bool], list[n]]:
...     return process(gather_primes, list(range(2, n)), [])
... 
&gt;&gt;&gt; primes(10)
([True, True, False, True, False, True, False, False], [2, 3, 5, 7])
&gt;&gt;&gt; primes(30)
([True, True, False, True, False, True, False, False, False, # 2 to 10
  True, False, True, False, False, False, True, False, True, # 11 to 20
  False, False, False, True, False, False, False, False, False, True], 
  [2, 3, 5, 7, 11, 13, 17, 19, 23, 29])
</code></pre>
<p>Proceed to define the <code>process</code>{.python} function. Example runs are as
above.<br />
<em>Note</em>: The type of a function that receives parameters <code>A</code>, <code>B</code> and <code>C</code>
and returns <code>D</code> is <code>Callable[[A, B, C], D]</code>{.python}. You will need to
import <code>Callable</code> from <code>typing</code>.
:::</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typeclasses"><a class="header" href="#typeclasses">Typeclasses</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ad-hoc-polymorphism"><a class="header" href="#ad-hoc-polymorphism">Ad-Hoc Polymorphism</a></h1>
<p>So far, we have learnt how to define algebraic data types, and
construct---and destructure---terms of those types. However, algebraic
data types typically only represent data, unlike objects in OOP.
Therefore, we frequently write <em>functions</em> acting on terms of those
types. As an example, drawing from
<a href="typeclasses/sections/ad-hoc-polymorphism.html#q:shapesexpressionproblem">[q:shapesexpressionproblem]</a>{reference-type="autoref"
reference="q:shapesexpressionproblem"}, let us define a
<code>Shape</code>{.haskell} ADT that represents circles and rectangles.</p>
<pre><code class="language-haskell">data Shape = Circle Double
           | Rectangle Double Double
</code></pre>
<p>On its own, this ADT does not do very much. What we would like to do
additionally, is to define a function over <code>Shape</code>{.haskell}s. For
example, a function <code>area</code>{.haskell} that computes the area of a
<code>Shape</code>{.haskell}:</p>
<pre><code class="language-haskell">area :: Shape -&gt; Double
area (Circle r) = pi * r ^ 2
area (Rectangle w h) = w * h
</code></pre>
<p>However, you might notice that <code>area</code>{.haskell} should not be
exclusively defined on <code>Shape</code>{.haskell}s; it could very well be the
case that we will later define other algebraic data types from which we
can also compute its area. For example, let us define a
<code>House</code>{.haskell} data type that also has a way to compute its area:</p>
<pre><code class="language-haskell">data House = H [Room]
type Room = Rectangle

area' :: House -&gt; Double
area' (H ls) = foldr ((+) . area) 0 ls
</code></pre>
<p>Notice that we cannot, at this point, abstract <code>area</code>{.haskell} and
<code>area'</code>{.haskell} into a single function---these functions work on
specific types, and they have type-specific implementations. It is such
a waste for us to have to use different names of to describe the same
functionality.</p>
<p>The question then becomes, is it possible for us to define an
<code>area</code>{.haskell} function that is polymorphic (not fully parametrically
polymorphic) in some ad-hoc way? That is, can <code>area</code>{.haskell} have one
implementation when given an argument of type <code>Shape</code>{.haskell}, and
another implementation when given another argument of type
<code>House</code>{.haskell}?</p>
<h3 id="ad-hoc-polymorphism-in-python"><a class="header" href="#ad-hoc-polymorphism-in-python">Ad-Hoc Polymorphism in Python</a></h3>
<p>Notice that this is entirely possible in Python and other OO languages,
where different classes can define methods of the same name.</p>
<pre><code class="language-python">@dataclass
class Rectangle:
  w: float
  h: float
  def area(self) -&gt; float:
    return self.w * self.h

@dataclass
class Circle:
  r: float
  def area(self) -&gt; float:
    return pi * r ** 2

@dataclass
class House:
  ls: list[Rectangle]
  def area(self) -&gt; float:
    return sum(x.area() for x in self.ls)
</code></pre>
<p>All of these disparate types can define an <code>area</code>{.python} method with
its own type-specific implementation, this is known as method
<em>overloading</em>. In fact, Python allows us to use them in an ad-hoc manner
because Python does not enforce types. Therefore, a function like the
following will be totally fine.</p>
<pre><code class="language-python">def total_area(ls):
  return sum(x.area() for x in ls)

ls = [Rectangle(1, 2), House([Rectangle(3, 4)])]
print(total_area(ls)) # 14
</code></pre>
<p><code>total_area</code>{.python} works because Python uses <em>duck typing</em>---if it
walks like a duck, quacks like a duck, it is probably a duck. Therefore,
as long as the elements of the input list <code>ls</code>{.python} defines a method
<code>area</code>{.python} that returns something that can be summed over, no type
errors will present from program execution.</p>
<p>Python allows us to take this further by defining special methods to
overload operators. For example, we can define the <code>__add__</code>{.python}
method on any class to define how it should behave under the
<code>+</code>{.python} operator:</p>
<pre><code class="language-python">@dataclass
class Fraction:
  num: int
  den: int
  def __add__(self, f):
    num = self.num * f.den + f.num * self.den
    den = self.den * f.den
    return Fraction(num, den)

print(1 + 2) # 3
print(Fraction(1, 2) + Fraction(3, 4)) # Fraction(10, 8)
</code></pre>
<p>However, relying on duck typing alone forces us to ditch any hopes for
static type checking. From the definition of the <code>ls</code>{.python} variable
above:</p>
<pre><code class="language-python">ls = [Rectangle(1, 2), House([Rectangle(3, 4)])]
</code></pre>
<p><code>ls</code>{.python} cannot be given a suitable type that is useful. Great
thing is, Python has support for Protocols that allow us to group
classes that adhere to a common interface (without the need for class
extension):</p>
<pre><code class="language-python">class HasArea(Protocol):
  @abstractmethod
  def area(self) -&gt; float:
    pass

def total_area(ls: list[HasArea]) -&gt; float:
  return sum(x.area() for x in ls)

ls: list[HasArea] = [Rectangle(1, 2), House([Rectangle(3, 4)])]
print(total_area(ls)) # 14
</code></pre>
<p>This is great because we have the ability to perform ad-hoc polymorphism
without coupling the data with behaviour---the <code>HasArea</code>{.python}
protocol makes no mention of its inhabiting classes
<code>Rectangle</code>{.python}, <code>Circle</code>{.python} and <code>House</code>{.python}, and
vice-versa, and yet we have provided enough information for the
type-checker so that bogus code such as the following gets flagged
early.</p>
<pre><code class="language-python">ls: list[HasArea] = [1] # Type checker complains about this
print(total_area(ls)) # TypeError
</code></pre>
<h3 id="the-expression-problem-in-python"><a class="header" href="#the-expression-problem-in-python">The Expression Problem in Python</a></h3>
<p>There are several limitations of our solution using protocols. Firstly,
Python's type system is not powerful or expressive enough to describe
protocols involving higher-kinded types. Secondly, although we have
earlier achieved decoupling between classes and the protocols they abide
by, we are not able to decouple classes and their methods. If we wanted
to completely decouple them, we would define methods as plain functions,
and run into the same problems we have seen in the Haskell
implementation of <code>area</code>{.haskell} and <code>area'</code>{.haskell} above.</p>
<p>At the expense of type safety, let us attempt to properly decouple
<code>area</code>{.python} and their implementing classes. The idea is to define an
<code>area</code>{.python} function that receives a helper function that computes
the type specific area of an object:</p>
<pre><code class="language-python">def area(x, helper) -&gt; float:
  return helper(x)

def rectangle_area(rect: Rectangle) -&gt; float:
  return rect.w * rect.h
def house_area(house: House) -&gt; float:
  return sum(x.area() for x in house.ls)

r = Rectangle(1, 2)
h = House([Rectangle(3, 4)])
area(r, rectangle_area) # 2
area(h, house_area) # 12
</code></pre>
<p>This implementation is silly because we could easily one level of
indirection by invoking <code>rectangle_area</code>{.python} or
<code>house_area</code>{.python} directly. However, notice that the implementations
are specific to classes---or, types---thus, what we can do is to store
these helpers in a dictionary whose keys are the types they were meant
to be inhabiting. Then, the <code>area</code>{.python} function can look up the
right type-specific implementation based on the type of the argument.</p>
<pre><code class="language-python">HasArea = {} 

def area(x):
  helper = HasArea[type(x)]
  return helper(x)

HasArea[Rectangle] = lambda x: x.w * x.h
HasArea[House] = lambda house: sum(x.area() for x in house.ls)

r = Rectangle(1, 2)
h = House([Rectangle(3, 4)])
area(r) # 2
area(h) # 12
</code></pre>
<p>What's great about this approach is that (1) otherwise disparate classes
adhere to a common interface, and (2) the classes and methods are
completely decoupled. We can later on define additional classes and its
type-specific implementation of <code>area</code>{.python}, or define a
type-specific implementation of <code>area</code>{.python} for a class that has
already been defined!</p>
<pre><code class="language-python">@dataclass
class Triangle:
  w: float
  h: float

HasArea[Triangle] = lambda t: 0.5 * t.w * t.h

area(Triangle(5, 2)) # 5
</code></pre>
<p>Unfortunately, all of these gains came at the cost of type safety. Is
there a better way to do this? In Haskell, yes---with typeclasses!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="typeclasses"><a class="header" href="#typeclasses">Typeclasses</a></h1>
<p>Typeclasses are a type system construct that enables ad-hoc
polymorphism. Essentially, a typeclass is a nominal classification of
types that all support some specified behaviour, by having each type
providing its type-specific implementation for those behaviours.
Alternatively, a typeclass can be seen as a constraint for a type to
support specified behaviours.</p>
<p>Just like classes in OOP are blueprints for creating instances of the
class (objects), a typeclass is a blueprint for creating typeclass
instances. This time, a typeclass provides the
interface/specification/contract for members of the typeclass to adhere
to, and typeclass instances provide the actual type-specific
implementations of functions specified in the typeclass. In essence, a
typeclass constrains a type, and a typeclass instance is a witness that
a type meets the constraints.</p>
<p>To build on intuition, pretend that there is a super cool magic club,
and members of this club must have a magic assistant and a magic trick.
This club acts as a typeclass. Then suppose cats and dogs want to join
this club. To do so, they must provide proof to the club administrators
(in Haskell, the compiler) that they have a magic assistant and a magic
trick. Suppose that the cats come together with their mouse friends as
their magic assistants, and their magic trick is to cough up a furball,
and the dogs all present their chew toys as their magic assistants, and
their magic trick is to give their paw. The club administrator then puts
all these into boxes as certificates of their membership into the
club---in our analogy, these certificates are typeclass instances.</p>
<p>Let us return to the shape and house example we have seen at the start
of this chapter. We first define some types (slightly different from
before) that all have an area:</p>
<pre><code class="language-haskell">data Shape = Circle Double
           | Rectangle Double Double
           | Triangle Double Double
data House = H [Room]
data room = R { roomName :: String
              , shape    :: Shape }
</code></pre>
<p>Now, our goal is to describe the phenomenon that some types have an
area. For this, we shall describe a contract for such types to follow.
The contract is straightforward---all such types must have an
<code>area</code>{.haskell} function (known as a method).</p>
<pre><code class="language-haskell">class HasArea a where
  area :: a -&gt; Double
</code></pre>
<p>An important question one might ask is: why is <code>HasArea</code>{.haskell}
polymorphic? To give an analogy, recall in our Python implementation
with dictionaries that <code>HasArea</code>{.python} is a dictionary where we are
looking up type-specific implementations of <code>area</code>{.python} by type.
Essentially, it is a finite map or (partial) function from types to
functions. This essentially makes <code>HasArea</code>{.haskell} polymorphic,
because it acts as a function that produces different implementations
depending on the type!</p>
<p>Then, the <code>area</code>{.haskell} function should also receive a parameter of
type <code>a</code>{.haskell}---that is, if <code>a</code>{.haskell} is a member of the
<code>HasArea</code>{.haskell} typeclass, then there is a function
<code>area :: a -&gt; Double</code>{.haskell}. The example typeclass instances make
this clear:</p>
<pre><code class="language-haskell">instance HasArea Shape where
  area :: Shape -&gt; Double
  area (Circle r) = pi * r ^ 2
  area (Rectangle w h) = w * h
  area (Triangle w h) = w * h / 2

instance HasArea Room where
  area :: Room -&gt; Double
  area x = area $ shape x

instance HasArea House where
  area :: House -&gt; Double
  area (H rooms) = sum $ map area rooms
</code></pre>
<p>Each instance of <code>HasArea</code>{.haskell} provides a type-specific
implementation of <code>area</code>{.haskell}. For example, the
<code>HasArea Shape</code>{.haskell} instance acts as a witness that
<code>Shape</code>{.haskell} belongs to the <code>HasArea</code>{.haskell} typeclass. It does
so by providing an implementation of <code>area :: Shape -&gt; Double</code>{.haskell}
(in the obvious way). We do the same for rooms and houses, and now the
<code>area</code>{.haskell} function works for all (and only) these three types!</p>
<pre><code class="language-haskell">x :: Shape = Triangle 2 3
y :: Room = R "bedroom" (Rectangle 3 4)
z :: House = H [y]

ax = area x -- 3
ay = area y -- 12
az = area z -- 12
</code></pre>
<p>Now let us investigate the type of <code>area</code>{.haskell}:</p>
<pre><code class="language-haskell">ghci&gt; :t area
area :: forall a. HasArea a =&gt; a -&gt; double
</code></pre>
<p>The type of <code>area</code>{.haskell} is read as "a function for all
<code>a</code>{.haskell} where <code>a</code>{.haskell} is constrained by <code>HasArea</code>{.haskell},
and receives an <code>a</code>{.haskell}, and returns a <code>Double</code>{.haskell}".</p>
<p>Constrains on type variables are not limited to class methods. In fact,
we can, and probably should, make functions that use <code>area</code>{.haskell}
polymorphic over type variables, constrained by <code>HasArea</code>{.haskell}. Let
us consider a function that sums the area over a list of shapes, and
another one over a list of rooms:</p>
<pre><code class="language-haskell">totalArea :: [Shape] -&gt; Double
totalArea [] = 0
totalArea (x : xs) = area x + totalArea xs

-- alternatively
totalArea' :: [Shape] -&gt; Double
totalArea' = sum . map area

totalArea'' :: [Room] -&gt; Double
totalArea'' = sum . map area
</code></pre>
<p>Notice that both <code>totalArea'</code>{.haskell} and <code>totalArea''</code>{.haskell} have
precisely the same implementation, except that they operate over
<code>Shape</code>{.haskell} and <code>Room</code>{.haskell} respectively. Notice that we can
substitute these types for any type variable <code>a</code>{.haskell}, so long as
there is an instance of <code>HasArea a</code>{.haskell}! Therefore, the most
general type we should ascribe for this function would be</p>
<pre><code class="language-haskell">totalArea :: HasArea a =&gt; [a] -&gt; Double
totalArea = sum . map area
</code></pre>
<p>Now our <code>totalArea</code>{.haskell} function works on any list that contains a
type that has an instance of <code>HasArea</code>{.haskell}!</p>
<pre><code class="language-haskell">xs :: [Shape] = [Rectangle 1 2, Triangle 3 4]
ys :: [House] = [H [R "bedroom" (Rectangle 1 2)]]
axs = totalArea xs -- 8
ayx = totalArea ys -- 2
</code></pre>
<h3 id="how-typeclasses-work"><a class="header" href="#how-typeclasses-work">How Typeclasses Work</a></h3>
<p>By now, you should be able to observe that typeclasses allow (1)
otherwise disparate types adhering to a common interface, i.e. ad-hoc
polymorphism and (2) decoupling types and behaviour, all in a type-safe
way---this is very difficult (if not impossible) to achieve in other
languages like Python. The question then becomes: how does Haskell do
it?</p>
<p>The core idea behind typeclasses and typeclass instances are that
typeclasses are implemented as regular algebraic data types, and
typeclass instances are implemented as regular terms of typeclasses.
Using our <code>area</code>{.haskell} example, we can define the typeclass as</p>
<pre><code class="language-haskell">data HasArea a = HA { area :: a -&gt; Double }
</code></pre>
<p>Then, typeclass instances are merely helper-terms of the
<code>HasArea</code>{.haskell} type:</p>
<pre><code class="language-haskell">hasAreaShape :: HasArea Shape
hasAreaShape = HA $ \x -&gt; case x of
  Circle    r   -&gt; pi * r ^ 2
  Rectangle w h -&gt; w * h
  Triangle  w h -&gt; w * h / 2
</code></pre>
<p>Notice that <code>area</code>{.haskell} now has the type
<code>HasArea a -&gt; a -&gt; Double</code>{.haskell}. Clearly,
<code>area hasAreaShape</code>{.haskell} is now the <code>Shape</code>{.haskell}-specific
implementation for obtaining the area of a shape! We can take this
further by defining the helper-terms for other types that wish to
implement the <code>HasArea</code>{.haskell} typeclass:</p>
<pre><code class="language-haskell">hasAreaRoom :: HasArea Room
hasAreaRoom = HA $ \x -&gt; area hasAreaShape (shape x)

hasAreaHouse :: HasArea House
hasAreaHouse = HA $ \x -&gt; case x of
  H rooms -&gt; sum $ map (area hasAreaRoom) rooms
</code></pre>
<p>Finally, we can use the <code>area</code>{.haskell} function, together with the
type-specific helpers, to compute the area of shapes, rooms and houses!</p>
<pre><code class="language-haskell">x :: Shape = Triangle 2 3
y :: Room = R "bedroom" (Rectangle 3 4)
z :: House = H [y]

ax = area hasAreaShape x -- 3
ay = area hasAreaRoom y -- 12
az = area hasAreamHouse z -- 12
</code></pre>
<p>This is (more-or-less) how Haskell implements typeclasses and typeclass
instances. The only difference is that the Haskell compiler will
automatically <em>infer</em> the helper term when a typeclass method is used,
allowing us to omit them. This <em>term inference</em> that Haskell supports
allow us to define and use ad-hoc polymorphic functions in a type-safe
way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commonly-used-typeclasses"><a class="header" href="#commonly-used-typeclasses">Commonly-Used Typeclasses</a></h1>
<p>Let us have a look at some typeclasses and their methods that you have
already used.</p>
<pre><code class="language-haskell">class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool

class Num a where
  (+) :: a -&gt; a -&gt; a
  (-) :: a -&gt; a -&gt; a
  (*) :: a -&gt; a -&gt; a
  negate :: a -&gt; a
  abs :: a -&gt; a
  signum :: a -&gt; a
  fromInteger :: Integer a
</code></pre>
<h3 id="equality-comparisons"><a class="header" href="#equality-comparisons">Equality Comparisons</a></h3>
<p>The <code>Eq</code>{.haskell} typeclass describes types that are amenable to
equality comparisons; the <code>Num</code>{.haskell} typeclass describes types that
can behave as numbers, with support for typical numeric operations like
addition, subtraction and so on. Haskell's Prelude already ships with
the instances of these typeclasses for commonly-used types, such as
instances for <code>Num Int</code>{.haskell} and <code>Eq String</code>{.haskell}.</p>
<p>Let us try defining our own instance of <code>Eq</code>{.haskell}. Suppose we are
re-using the <code>Fraction</code>{.haskell} algebraic data type defined in the
previous chapter:</p>
<pre><code class="language-haskell">data Fraction = Fraction Int Int
</code></pre>
<p>Let us allow <code>Fraction</code>{.haskell} to be amenable to equality comparisons
by implementing a typeclass instance for <code>Eq Fraction</code>{.haskell}:</p>
<pre><code class="language-haskell">instance Eq Fraction where
  (==) :: Fraction -&gt; Fraction -&gt; Bool
  F a b == F c d = a == c &amp;&amp; b == d

  (/=) :: Fraction -&gt; Fraction -&gt; Bool
  F a b /= F c d = a /= c || b /= d
</code></pre>
<p>Firstly, notice that we are performing equality comparisons between the
numerators and denominators. This is okay because we know that the
numerators and denominators of fractions are integers, and there is
already an instance of <code>Eq Int</code>{.haskell}. Next, usually by definition,
<code>a /= b</code>{.haskell} is the same as <code>not (a == b)</code>{.haskell}. Therefore,
having to always define both <code>(==)</code>{.haskell} and <code>(/=)</code>{.haskell} for
every instance is cumbersome.</p>
<h3 id="minimal-instance-definitions"><a class="header" href="#minimal-instance-definitions">Minimal Instance Definitions</a></h3>
<p>Let us inspect the definition of the <code>Eq</code>{.haskell} typeclass:</p>
<pre><code class="language-haskell">ghci&gt; :i Eq
type Eq :: * -&gt; Constraint
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  (/=) :: a -&gt; a -&gt; Bool
  {-# MINIMAL (==) | (/=) #-}
    -- Defined in 'GHC.Classes'
</code></pre>
<p>Notice the <code>MINIMAL</code> <em>pragma</em>---the pragma states that we only need to
define either <code>(==)</code>{.haskell} <em>or</em> <code>(/=)</code>{.haskell} for a complete
instance definition! Therefore, we can omit the definition of
<code>(/=)</code>{.haskell} in our <code>Eq Fraction</code>{.haskell} instance, and we would
still have a complete definition:</p>
<pre><code class="language-haskell">instance Eq Fraction where
  (==) :: Fraction -&gt; Fraction -&gt; Bool
  F a b == F c d = a == c &amp;&amp; b == d
</code></pre>
<pre><code class="language-haskell">ghci&gt; Fraction 1 2 == Fraction 1 2
True
ghci&gt; Fraction 1 2 /= Fraction 1 2
False
</code></pre>
<p>A natural question to ask is, why not simply define <code>Eq</code>{.haskell} to
only have <code>(==)</code>{.haskell} and give <code>(/=)</code>{.haskell} for free?</p>
<pre><code class="language-haskell">class Eq a where
  (==) :: a -&gt; a -&gt; Bool

(/=) :: Eq a =&gt; a -&gt; a -&gt; Bool
x /= y = not (x == y)
</code></pre>
<p>By placing both functions as methods in the typeclass, programmers have
the option to define <em>either</em> <code>(==)</code>{.haskell} <em>or</em> <code>(/=)</code>{.haskell}, or
both, if specifying each implementation individually gives a more
efficient performance.</p>
<h3 id="typeclass-constraints-in-typeclasses-and-instances"><a class="header" href="#typeclass-constraints-in-typeclasses-and-instances">Typeclass Constraints in Typeclasses and Instances</a></h3>
<p>We can even define instances over polymorphic types. Here is an example
of how we can perform equality comparisons over trees:</p>
<pre><code class="language-haskell">data Tree a = Node (Tree a) a (Tree a)
            | Empty

instance Eq (Tree a) where
  (==) :: Tree a -&gt; Tree a -&gt; Bool
  Empty == Empty = True
  (Node l v r) == (Node l' v' r') = l == l' &amp;&amp; v == v' &amp;&amp; r == r'
  _ == _ = False
</code></pre>
<p>However, our instance will not type-check because the elements
<code>a</code>{.haskell} of the trees also need to be amenable to equality
comparisons for us to compare trees! Therefore, we should constrain
<code>a</code>{.haskell} with <code>Eq</code>{.haskell} in the <em>instance</em> declaration, like
so:</p>
<pre><code class="language-haskell">data Tree a = Node (Tree a) a (Tree a)
            | Empty

instance Eq a =&gt; Eq (Tree a) where
  (==) :: Tree a -&gt; Tree a -&gt; Bool
  Empty == Empty = True
  (Node l v r) == (Node l' v' r') = l == l' &amp;&amp; v == v' &amp;&amp; r == r'
  _ == _ = False
</code></pre>
<p>In fact, we can write typeclass constraints in typeclass declarations as
well. For example, the <code>Ord</code>{.haskell} typeclass describes (total)
orders on types, and all (totally) ordered types must also be amenable
to equality comparisons:</p>
<pre><code class="language-haskell">class Eq a =&gt; Ord a where
  (&lt;) :: a -&gt; a -&gt; Bool
  (&lt;=) :: a -&gt; a -&gt; Bool
  -- ...
</code></pre>
<h3 id="deriving-typeclasses"><a class="header" href="#deriving-typeclasses">Deriving Typeclasses</a></h3>
<p>In fact, some typeclasses are so straightforward that defining instances
of these classes are a tedium. For example, the <code>Eq</code>{.haskell} class is
(usually) very straightforward to define---two terms are equal if they
are built with the same constructor and their argument terms are
respectively equal. As such, the language should not require programmers
to implement straightforward instances of classes like <code>Eq</code>{.haskell}.</p>
<p>Haskell has a <em>deriving mechanism</em> that allows the compiler to
automatically synthesize typeclass instances for us. It is able to do so
for <code>Eq</code>{.haskell}, <code>Ord</code>{.haskell}, and others like <code>Enum</code>{.haskell}.
Doing so is incredibly straightforward:</p>
<pre><code class="language-haskell">data A = B | C

data Fraction = Fraction Int Int 
  deriving Eq -- deriving Eq Fraction instance

data Tree a = Empty | Node (Tree a) a (Tree a)
  deriving (Eq, Show) -- deriving Eq (Tree a) and Show (Tree a)

deriving instance Eq A -- stand-alone deriving declaration
</code></pre>
<p>These declarations tell the compiler to synthesize instance declarations
in the most obvious way. This way, we do not have to write our own
instance declarations for these typeclasses!</p>
<pre><code class="language-haskell">ghci&gt; x = Node Empty 1 Empty
ghci&gt; y = Node (Node Empty 1 Empty) 2 Empty
ghci&gt; x
Node Empty 1 Empty
ghci&gt; x == y
False
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-dependencies"><a class="header" href="#functional-dependencies">Functional Dependencies</a></h1>
<p>Observe the type signature of <code>(+)</code>{.haskell}:</p>
<pre><code class="language-haskell">:t (+)
(+) :: forall a. Num a =&gt; a -&gt; a
</code></pre>
<p>This behaviour is quite different in Python:</p>
<pre><code class="language-text">&gt;&gt;&gt; type(1 + 1)
class &lt;'int'&gt;
&gt;&gt;&gt; type(1 + 1.0)
class &lt;'float'&gt;
&gt;&gt;&gt; type(1.0 + 1)
class &lt;'float'&gt;
&gt;&gt;&gt; type(1.0 + 1.0)
class &lt;'float'&gt;
</code></pre>
<p>The <code>+</code>{.python} operator in Python behaves heterogenously---when given
two <code>int</code>{.python}s we get an <code>int</code>{.python}; when given at least one
<code>float</code>{.python} we get a <code>float</code>{.python}. How would we encode this in
Haskell?</p>
<p>Simple! Create a multi-parameter typeclass that describes the argument
types and the result type!</p>
<pre><code class="language-haskell">class (Num a, Num b, Num c) =&gt; HAdd a b c where
  (+#) :: a -&gt; b -&gt; c
</code></pre>
<p>Then we can write instances for the possible permutations of the desired
types:</p>
<pre><code class="language-haskell">instance Num a =&gt; HAdd a a a where
  (+#) :: a -&gt; a -&gt; a
  (+#) = (+)

instance HAdd Int Double Double where
  (+#) :: Int -&gt; Double -&gt; Double
  x +# y = fromIntegral x + y

instance HAdd Double Int Double where
  (+#) :: Double -&gt; Int -&gt; Double
  x +# y = x + fromIntegral y
</code></pre>
<p>However, trying to use <code>(+#)</code>{.haskell} is very cumbersome:</p>
<pre><code class="language-haskell">ghci&gt; x :: Int = 1
ghci&gt; y :: Double = 2.0
x +# y
&lt;interactive&gt;:3:1: error:
    - No instance for (HAdd Int Double ()) arising from a use of 'it'
    - In the first argument of 'print', namely 'it'
      In a stmt of an interactive GHCi command: print it
ghci&gt; x +# y :: Double
3.0
</code></pre>
<p>This occurs because without specifying the return type <code>c</code>{.haskell},
Haskell has no idea what it is as it may be ambiguous! As per the
definition, no one is stopping us from defining another
<code>instance HAdd Int Double String</code>{.haskell}! On the other hand, we know
that adding an <code>Int</code>{.haskell} and a <code>Double</code>{.haskell} <em>must</em> result in
a <code>Double</code>{.haskell} and nothing else; in other words, the types of the
arguments to <code>(+#)</code>{.haskell} <em>uniquely characterizes</em> the resulting
type.</p>
<p>The way we introduce this dependency between these type variables by
introducing <em>functional dependencies</em> on typeclass declarations, which,
adding them to our declaration of <code>HAdd</code>{.haskell}, looks something like
the following:</p>
<pre><code class="language-haskell">{-# LANGUAGE FunctionalDependencies #-}
class (Num a, Num b, Num c) =&gt; HAdd a b c | a b -&gt; c where
  (+#) :: a -&gt; b -&gt; c
</code></pre>
<p>The way to read the clause <code>a b -&gt; c</code> is "<code>a</code> and <code>b</code> <em>uniquely
characterizes</em>/<em>determines</em> <code>c</code>", or in other words, <code>c</code> is a <em>function</em>
of <code>a</code> and <code>b</code>, i.e. it is not possible that given a <em>fixed</em> <code>a</code> and <code>b</code>
that we have two different inhabitants of <code>c</code>. This (1) prevents the
programmer from introducing different values of <code>c</code> for the same <code>a</code> and
<code>b</code> (which we haven't) and (2) allows the compiler to infer the right
instance just with <code>a</code> and <code>b</code> alone.</p>
<pre><code class="language-haskell">ghci&gt; x :: Int = 1
ghci&gt; y :: Double = 2.0
ghci&gt; x +# y
3.0
ghci&gt; :{
ghci| instance HAdd Int Double String where
ghci|   x +# y = show x
ghci| :}
&lt;interactive&gt;:8:10: error:
    Functional dependencies conflict between instance declarations:
      instance [safe] HAdd Int Double Double
        -- Defined at &lt;interactive&gt;:17:10
      instance HAdd Int Double String -- Defined at &lt;interactive&gt;:21:10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h1>
<p>::: exercise
[]{#q:whatarethetypestypeclasses label="q:whatarethetypestypeclasses"}
Without using GHCI, determine the types of the following expressions:</p>
<ol>
<li>
<p><code>1 + 2 * 3</code>{.haskell}</p>
</li>
<li>
<p><code>(show . )</code>{.haskell}</p>
</li>
<li>
<p><code>( . show)</code>{.haskell}</p>
</li>
<li>
<p><code>\ (a, b) -&gt; a == b</code>{.haskell}
:::</p>
</li>
</ol>
<p>::: exercise
[]{#q:protocols label="q:protocols"} You are given the following untyped
program:</p>
<pre><code class="language-python">type Tree[a] = Empty | TreeNode[a]
type List[a] = Empty | ListNode[a]

@dataclass
class Empty:
    def to_list(self):
        return []

@dataclass
class ListNode[a]:
    head: a
    tail: List[a]
    def to_list(self):
        return [self.head] + self.tail.to_list()

@dataclass
class TreeNode[a]:
    l: Tree[a]
    v: a
    r: Tree[a]
    def to_list(self):
      return self.l.to_list() + [self.v] + self.r.to_list()

def flatten(ls):
    if not ls: return []
    return ls[0].to_list() + flatten(ls[1:])

ls = [ListNode(1, Empty()), TreeNode(Empty(), 2, Empty())]
ls2 = flatten(ls)
</code></pre>
<p>Fill in the type signatures of all the methods and functions and the
type annotations for the <code>ls</code>{.python} and <code>ls2</code>{.python} variables so
that the type-checker can verify that the program is type-safe. The
given type annotations should be general enough such that defining a new
class and adding an instance of it to <code>ls</code>{.python} requires no change
in type annotation:</p>
<pre><code class="language-python">@dataclass
class Singleton[a]:
  x: a
  def to_list(self):
    return [self.x]
    
ls = [ListNode(1, Empty()), TreeNode(Empty(), 2, Empty()),
  Singleton(3)]
# ...
</code></pre>
<p>:::</p>
<p>::: exercise
[]{#q:colours label="q:colours"}
:::</p>
<p>::: exercise
[]{#q:exprtypeclass label="q:exprtypeclass"} Recall in
<a href="typeclasses/sections/exercises.html#ch:types">[ch:types]</a>{reference-type="autoref" reference="ch:types"}
where we defined our <code>Expr</code>{.haskell} GADT.</p>
<pre><code class="language-haskell">data Expr a where
  LitNumExpr :: Int -&gt; Expr Int
  AddExpr :: Expr Int -&gt; Expr Int -&gt; Expr Int
  -- ...

eval :: Expr a -&gt; a
eval (LitNumExpr x) = x
eval (AddExpr e1 e2) = eval e1 + eval e2
  -- ... 
</code></pre>
<p>Now that we have learnt typeclasses, let us attempt to <em>separate</em> each
constructor of <code>Expr</code>{.haskell} as <em>individual types</em>, while still
preserving functionality; the purpose of this being to keep the
<code>Expr</code>{.haskell} type modular and extensible:</p>
<pre><code class="language-haskell">data LitNumExpr = -- ...
data AddExpr = -- ...
</code></pre>
<p>While still being able to apply <code>eval</code>{.haskell} on any of those
expressions:</p>
<pre><code class="language-haskell">-- 2 + 3
ghci&gt; eval (AddExpr (LitNumExpr 2) (LitNumExpr 3))
5
-- if 2 == 1 + 1 then 1 + 2 else 4
ghci&gt; eval (CondExpr 
  (EqExpr (LitNumExpr 2) 
          (AddExpr (LitNumExpr 1) (LitNumExpr 1))) 
  (AddExpr (LitNumExpr 1) (LitNumExpr 2))
  (LitNumExpr 4))
3
</code></pre>
<p>Proceed to define all these different types of expressions and their
corresponding implementations for <code>eval</code>{.haskell}:</p>
<ul>
<li>
<p><code>LitNumExpr</code>{.haskell}. A literal integer, such as
<code>LitNumExpr 3</code>{.haskell}.</p>
</li>
<li>
<p><code>AddExpr</code>{.haskell}. An addition expression in the form of
$e_1 + e_2$, such as
<code>AddExpr (LitNumExpr 1) (LitNumExpr 2)</code>{.haskell} representing
$1 + 2$</p>
</li>
<li>
<p><code>EqExpr</code>{.haskell}. An equality comparison expression in the form of
$e_1 == e_2$, such as <code>Eq (LitNumExpr 1) (LitNumExpr 2)</code>{.haskell}
representing $1 = 2$</p>
</li>
<li>
<p><code>CondExpr</code>{.haskell}. A conditional expression in the form of
$\text{if }e\text{ then } e_1 \text{ else }e_2$
:::</p>
</li>
</ul>
<p>::: exercise
[]{#q:mergesort label="q:mergesort"} Implement the mergesort algorithm
as a function <code>mergesort</code>{.haskell}. Ignoring time complexity, your
algorithm should split the list in two, recursively mergesort each half,
and merge the two sorted sublists together. Example runs follow:</p>
<pre><code class="language-haskell">ghci&gt; mergesort [5,2,3,1,2]
[1,2,2,3,5]
ghci&gt; mergesort "edcba"
"abcde"
</code></pre>
<p>:::</p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="app:recap-recursion"><a class="header" href="#app:recap-recursion">Recursion</a></h1>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Something is recursive if it is defined using itself. A simple (albeit
hardly useful and contrived) example is the following function:</p>
<pre><code class="language-python">def f(n):
    return f(n + 1)
</code></pre>
<p>As defined, the body of function <code>f</code>{.python} invokes itself. In other
words, it is <em>defined using itself</em>. Readers who are unconvinced that
<code>f</code>{.python} is not a recursive definition may see that it is analogous
to the following mathematical definition, which is clearly recursive:
$$f(n) = f(n + 1) = f(n + 2) = f(n + 3) = \dots$$</p>
<p>Data types can also be defined recursively:</p>
<pre><code class="language-python">from abc import ABC
from dataclasses import dataclass

class SinglyLinkedList(ABC):
    pass

class Empty(SinglyLinkedList):
    pass

@dataclass
class Node(SinglyLinkedList):
    head: object
    tail: SinglyLinkedList
</code></pre>
<p>Likewise, you can see that the <code>SinglyLinkedList</code> class has a subclass
<code>Node</code> which itself holds another <code>SinglyLinkedList</code>. This makes
<code>SinglyLinkedList</code> a recursive data structure.</p>
<p>The core idea we present in this section is that we can write recursive
functions by thinking <em>structural-inductively</em>.</p>
<h3 id="induction"><a class="header" href="#induction">Induction</a></h3>
<p>We shall begin by describing a <em>proof by induction</em> for a statement over
the natural numbers. The principle of a proof by induction is as
follows. Given a <em>predicate</em> $P(n)$ over the natural numbers, if we can
show:</p>
<ol>
<li>
<p>$P(0)$ is true</p>
</li>
<li>
<p>$\forall n \in \mathbb{N}.~P(n)\to P(n + 1)$ (for all natural
numbers $n$, $P(n)$ implies $P(n + 1)$)</p>
</li>
</ol>
<p>Then $P(n)$ is true for all natural numbers $n$. This works because of
<em>modus ponens</em>:</p>
<p>::: center
::: prooftree
[[Modus Ponens]q]{.smallcaps}
:::
:::</p>
<p><em>Modus Ponens</em> codifies the following idea: if a proposition $p$ is
true, and if $p$ implies $q$, then $q$ is true. To show how this allows
proofs by induction, we see that we have a proof of $P(0)$. Since we
also know that $P(0)$ implies $P(0 + 1) = P(1)$, by <em>modus ponens</em>,
$P(1)$ is true. We also know that $P(1)$ implies $P(2)$, and since from
earlier $P(1)$ is true, by <em>modus ponens</em>, $P(2)$ is also true, and so
on.</p>
<p>Let us attempt to write a proof by induction. We start with an
implementation of the factorial function, then prove that it is correct:</p>
<pre><code class="language-python">def factorial(n):
    return 1 if not n else \
           n * factorial(n - 1)
</code></pre>
<p>::: proposition
Let $P(n)$ be the proposition that <code>factorial(n)</code>{.python} returns $n!$.
Then, for all natural numbers $n$, $P(n)$ is true.
:::</p>
<p>::: proof
<em>Proof.</em> We prove $P(0)$ and $\forall n\in\mathbb{N}.~P(n)\to P(n + 1)$
separately.<br />
<strong>Basis</strong>. Trivial. $0! = 1$. Furthermore, by definition,
<code>factorial(0)</code>{.python} returns <code>1</code>{.python}. In other words, $P(0)$ is
true.<br />
<strong>Inductive</strong>. Suppose for some natural number $k$,
<code>factorial(k)</code>{.python} returns
$k! = k \times (k - 1) \times \dots \times 1$. By definition of
<code>factorial</code>{.python}, <code>factorial(k + 1)</code>{.python} returns
<code>(k + 1) * factorial(k)</code>{.python}. By our supposition, this evaluates to
$(k + 1) \times k!$, which is, by definition, $(k + 1)!$. Thus, if for
some $k$, <code>factorial(k)</code>{.python} returns $k!$, then
<code>factorial(k + 1)</code>{.python} returns $(k + 1)!$. In other words,
$\forall k\in\mathbb{N}.~P(k) \to P(k + 1)$.<br />
As such, since we have proven $P(0)$ and
$\forall k\in\mathbb{N}.~P(k)\to P(k+1)$, we have proven
$\forall n\in\mathbb{N}.~P(n)$ by induction. ◻
:::</p>
<h3 id="recursion-via-inductive-reasoning"><a class="header" href="#recursion-via-inductive-reasoning">Recursion via Inductive Reasoning</a></h3>
<p>Naturally (haha), the next question to ask would be, "how do we make use
of induction to write recursive functions?" As above, the recipe for a
proof by induction involves (broadly) two steps:</p>
<ol>
<li>
<p>Proof of the basis, e.g. $P(0)$</p>
</li>
<li>
<p>The inductive proof, e.g. $P(k)\to P(k + 1)$. Typically, the
inductive step is completed by <strong>supposing</strong> $P(k)$ for some $k$,
and showing $P(k + 1)$.</p>
</li>
</ol>
<p>We can write recursive functions similarly by providing:</p>
<ol>
<li>
<p>Non-recursive computation for the result of the base-case, e.g.
$f(0)$;</p>
</li>
<li>
<p>Recursive computation of $f(k + 1)$ based on the result of $f(k)$
<strong>assuming</strong> that $f(k)$ gives the correct result.</p>
</li>
</ol>
<p>However, induction doesn't only work for the natural numbers. To see
this, let us start with a simple description of the natural numbers:
$$\begin{aligned}
0 &amp;\in \mathbb{N} &amp;&amp;\triangleright~0\text{ is a natural number}\
n \in \mathbb{N} &amp;\to S(n) \in \mathbb{N} &amp;&amp; \triangleright~\text{if }n \text{ is a natural number then it has a successor that is also a natural number}
\end{aligned}$$ In our usual understanding of the natural numbers,
$S(n) = n + 1$.</p>
<p>A formulation of the natural numbers in Python might be the following:</p>
<pre><code class="language-python">class Nat: pass

@dataclass
class Zero(Nat): pass

@dataclass
class Succ(Nat):
    pred: Nat
</code></pre>
<p>In which case, the number $3$ can be written as follows:</p>
<pre><code class="language-python">three = Succ(Succ(Succ(Zero())))
</code></pre>
<p>Let us attempt to define addition over the natural numbers as we have
formulated above, recursively:</p>
<pre><code class="language-python">&gt;&gt;&gt; three = Succ(Succ(Succ(Zero())))
&gt;&gt;&gt; two = Succ(Succ(Zero()))
&gt;&gt;&gt; add(three, two)
Succ(pred=Succ(pred=Succ(pred=Succ(pred=Succ(pred=Zero())))))
</code></pre>
<p>We might decide to perform recursion on the first addend (doing so on
the second addend is fine as well). In computing $m + n$ there are two
possibilities for what $m$ could be: $0$, or the successor of some
natural number $k$. The first case is straightforward since $0$ itself
is non-recursive (see the definition of <code>Zero</code> above), and $0 + n$ is
just $n$. In the other case of $m + n$ where $m = S(k)= k + 1$ for some
$k$, assuming (via our inductive hypothesis) that <code>add(k, n)</code>{.python}
correctly gives $k + n$, then $m + n$ is $(k + n) + 1$ which can be done
by <code>Succ(add(k, n))</code>{.python}. Therefore, we arrive at the following
solution:</p>
<pre><code class="language-python">def add(m, n):
    return n if m == Zero() else \
           Succ(add(m.pred, n))
</code></pre>
<p>Using <em>structural pattern matching</em> which we present in
<a href="recap/sections/recursion.html#ch:types">[ch:types]</a>{reference-type="autoref"
reference="ch:types"}, we may also write the following definition which
might be more intuitive:</p>
<pre><code class="language-python">def add(m, n):
    match m:
        case Zero(): return n
        case Succ(k): return Succ(add(k, n))
</code></pre>
<p>At this point you might be wondering why we had given such an odd
formulation of the natural numbers in Python, when we could have used
the <code>int</code>{.python} type instead (we totally could). One core idea we
would like to make apparent in this formulation, is that recursion via
inductive reasoning can be done over the <em>structure</em> of data. Our
formulation shows that natural numbers are recursive data structures,
where the successor of a natural number has a predecessor who is also,
likewise, a natural number. This should make writing recursive functions
over other kinds of recursive data structures not too far of a leap from
writing recursive functions over natural numbers. To show this, consult
our <code>SinglyLinkedList</code> data structure from above before we proceed to
write recursive functions over them using inductive reasoning.</p>
<p>First, we shall write a function that appends an element to the end of a
singly-linked list.</p>
<pre><code class="language-python">&gt;&gt;&gt; append(1, Empty())
Node(head=1,tail=Empty())
&gt;&gt;&gt; append(2, append(1, Empty()))
Node(head=1,tail=Node(head=2,tail=Empty()))
</code></pre>
<p>We can perform recursion over the structure of the list. There are two
possible structures of the list, the first being the empty list, and the
second being a node of a head element and a tail list. In the former we
append to an empty list, which should give the singleton. Note once
again that because the empty list is non-recursive, our solution for
appending to the empty list likewise requires no recursion. For the
second case of $[e_1, e_2,\dots,e_n]$ (shorthand for
$\mathtt{Node}(e_1, [e_2,\dots,e_n])$), assume that our solution is
correct for the substructure of the <code>Node</code>, i.e.
$\mathtt{append}(x, [e_2,\dots,e_n]) = [e_2,\dots,e_n, x]$. Our goal is
to have
$$\mathtt{append}(x, \mathtt{Node}(e_1, [e_2,\dots,e_n])) = \mathtt{Node}(e_1, [e_2,\dots,e_n,x])$$
Observe that: $$\begin{aligned}
\mathtt{append}(x, \mathtt{Node}(e_1, [e_2,\dots,e_n])) &amp;= \mathtt{Node}(e_1, [e_2,\dots,e_n,x])\
&amp;= \mathtt{Node}(e_1, \mathtt{append}(x, [e_2,\dots,e_n]))
\end{aligned}$$</p>
<p>Therefore, we can write:</p>
<pre><code class="language-python">def append(x, ls):
    if ls == Empty():
        return Node(x, Empty())
    return Node(ls.head, append(x, ls.tail))

# Using structural pattern matching:
def append2(x, ls):
    match ls:
        case Empty():
            return Node(x, Empty())
        case Node(e1, xs):
            return Node(e1, append2(x, xs))
</code></pre>
<p>We shall give another example by writing list reversals recursively,
going straight into our derivation. Reversing the empty list gives the
empty list. For nonempty lists our goal is to have
$\mathtt{reverse}([e_1,\dots,e_n])=[e_n,\dots,e_1]$. Assuming that
$\mathtt{reverse}([e_2,\dots,e_n])=[e_n,\dots,e_2]$, we can see that
$[e_n,\dots,e_1] = \mathtt{append}(e_1, [e_n,\dots,e_2])$, giving us the
following formulation:</p>
<pre><code class="language-python">def reverse(ls):
    if ls == Empty():
        return Empty()
    return append(ls.head, reverse(ls.tail))

# Using structural pattern matching:
def reverse2(ls):
    match ls:
        case Empty(): return Empty()
        case Node(e1, xs): return append(e1, reverse(xs))
</code></pre>
<p>By this point you should be able to see that recursion can be done via
the following based on the structure of the data:</p>
<ol>
<li>
<p>If the data is non-recursive, provide a non-recursive computation
that computes the result directly</p>
</li>
<li>
<p>If the data is recursive, recursively solve the problem on the
substructure(s) of the data (e.g. <code>pred</code> or <code>tail</code> of the natural
number or list), and include its result in your main result</p>
</li>
</ol>
<p>You should be well aware that data structures may be more complex. For
example, solving a problem for a structure may require more than one
recursive calls, one non-recursive call and one recursive call, etc. To
make this apparent, let us look at a formulation of a binary tree of
integers:</p>
<pre><code class="language-python">class Tree: pass

@dataclass
class EmptyTree(Tree): pass

@dataclass
class TreeNode(Tree):
    left: Tree
    val: int
    right: Tree
</code></pre>
<p>Now let us attempt to write a function that sums all integers in the
tree. Again there are two possible structures a tree can have: the first
being the empty tree, which has sum 0. For tree nodes, we have two
subtrees, <code>left</code> and <code>right</code>, from whom we may recursively obtain their
sums using our function. Then, the sum of the entire tree is just the
total of the value at the node, the sum of the left subtree and the sum
of the right subtree:</p>
<pre><code class="language-python">def sum_tree(t):
    if t == EmptyTree():
        return 0
    return t.val + sum_tree(t.left) + sum_tree(t.right)

# Structural pattern matching
def sum_tree(t):
    match t:
        case EmptyTree(): return 0
        case TreeNode(l, v, r):
            return sum_tree(l) + v + sum_tree(r)
</code></pre>
<p>Clearly, our recursive case can make more than one recursive call.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
